<!DOCTYPE html>
<html class="no-js" lang="en">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"  >

    <script>
      var SC_benchmarkPreloadEvents = { headStart: new Date().getTime() };
      var docElem = window.documentElement || document.documentElement;
      if(docElem) {
        docElem.className = docElem.className.replace(/(^|\s)no-js(\s|$)/, '$1js$2');
        docElem = null;
      }
    </script>

    <meta http-equiv="Content-type" content="text/html; charset=utf-8"  >
    <meta http-equiv="Content-Script-Type" content="text/javascript"  >
    <meta name="apple-mobile-web-app-capable" content="yes"  >
    <meta name="apple-mobile-web-app-status-bar-style" content="default"  >
    <meta name="viewport" content="initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"  >

    <link rel="apple-touch-icon" href=""  >
    <link rel="apple-touch-startup-image" media="screen and (orientation:portrait)" href=""  >
    <link rel="apple-touch-startup-image" media="screen and (orientation:landscape)" href=""  >

    <link rel="shortcut icon" href="" type="image/x-icon"  >


    <title>Sproutcore Datastore</title>

    <script>
      window.SC = window.SC || { MODULE_INFO: {}, LAZY_INSTANTIATION: {} };
      SC.buildMode = 'debug';
      SC.buildNumber = 'current';
      SC.buildLocale = 'en';
    </script>

    <script type="text/javascript">String.preferredLanguage = "en";</script>
<script type="text/javascript">
/* >>>>>>>>>> BEGIN source/core.js */
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Strobe Inc. and contributors.
//            Portions ©2008-2011 Apple Inc. All rights reserved.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================


/* >>>>>>>>>> BEGIN source/system/browser.js */
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Strobe Inc. and contributors.
//            Portions ©2008-2011 Apple Inc. All rights reserved.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================

window.SC = window.SC || { MODULE_INFO: {}, LAZY_INSTANTIATION: {} };


/**
  The list of browsers that are automatically identified.

  @static
  @constant
*/
SC.BROWSER = {
  android: 'android',
  blackberry: 'blackberry',
  chrome: 'chrome',
  firefox: 'firefox',
  ie: 'ie',
  opera: 'opera',
  safari: 'safari',
  unknown: 'unknown'
};

/**
  The list of devices that are automatically identified.

  @static
  @constant
*/
SC.DEVICE = {
  android: 'android',
  blackberry: 'blackberry',
  desktop: 'desktop',
  ipad: 'ipad',
  iphone: 'iphone',
  ipod: 'ipod',
  mobile: 'mobile'
};

/**
  The list of browser engines that are automatically identified.

  @static
  @constant
*/
SC.ENGINE = {
  gecko: 'gecko',
  opera: 'opera',
  presto: 'presto',
  trident: 'trident',
  webkit: 'webkit'
};

/**
  The list of operating systems that are automatically identified.

  @static
  @constant
*/
SC.OS = {
  android: 'android',
  blackberry: 'blackberry',
  ios: 'ios',
  linux: 'linux',
  mac: 'mac',
  win: 'windows'
};


/**
  Detects browser properties based on the given userAgent and language.

  @private
*/
SC.detectBrowser = function(userAgent, language) {
  var browser = {},
      device,
      engineAndVersion,
      isIOSDevice,
      conExp = '(?:[\\/:\\::\\s:;])', // Match the connecting character
      numExp = '(\\S+[^\\s:;:\\)]|)', // Match the "number"
      nameAndVersion,
      osAndVersion,
      override;

  // Use the current values if none are provided.
  userAgent = (userAgent || navigator.userAgent).toLowerCase();
  language = language || navigator.language || navigator.browserLanguage;

  // Calculations to determine the device.  See SC.DEVICE.
  device =
    userAgent.match( new RegExp('(android|ipad|iphone|ipod|blackberry)') ) ||
    userAgent.match( new RegExp('(mobile)') ) ||
    ['', SC.DEVICE.desktop];

  /**
    @name SC.browser.device
    @type {SC.DEVICE}
  */
  browser.device = device[1];


  // It simplifies further matching by recognizing this group of devices.
  isIOSDevice =
    browser.device === SC.DEVICE.ipad ||
    browser.device === SC.DEVICE.iphone ||
    browser.device === SC.DEVICE.ipod;


  // Calculations to determine the name and version.  See SC.BROWSER.

  nameAndVersion =
    // Match the specific names first, avoiding commonly spoofed browsers.
    userAgent.match( new RegExp('(opera|chrome|firefox|android|blackberry)' + conExp + numExp) ) ||
    userAgent.match( new RegExp('(ie|safari)' + conExp + numExp) ) ||
    ['', SC.BROWSER.unknown, '0'];

  // If the device is an iOS device, use SC.BROWSER.safari for browser.name.
  if (isIOSDevice) { nameAndVersion[1] = SC.BROWSER.safari; }

  // If a `Version` number is found, use that over the `Name` number
  override = userAgent.match( new RegExp('(version)' + conExp + numExp) );
  if (override) { nameAndVersion[2] = override[2]; }
  // If there is no `Version` in Safari, don't use the Safari number since it is
  // the Webkit number.
  else if (nameAndVersion[1] === SC.BROWSER.safari) { nameAndVersion[2] = '0'; }


  /**
    @name SC.browser.name
    @type {SC.BROWSER}
  */
  browser.name = nameAndVersion[1];

  /**
    @name SC.browser.version
    @type String
  */
  browser.version = nameAndVersion[2];


  // Calculations to determine the engine and version.  See SC.ENGINE.
  engineAndVersion =
    // Match the specific engines first, avoiding commonly spoofed browsers.
    userAgent.match( new RegExp('(presto)' + conExp + numExp) ) ||
    userAgent.match( new RegExp('(opera|trident|webkit|gecko)' + conExp + numExp) ) ||
    ['', SC.BROWSER.unknown, '0'];

  // If the browser is SC.BROWSER.ie, use SC.ENGINE.trident.
  override = browser.name === SC.BROWSER.ie ? SC.ENGINE.trident : false;
  if (override) { engineAndVersion[1] = override; }

  // If the engineVersion is unknown and the browser is SC.BROWSER.ie, use
  // browser.version for browser.engineVersion.
  override = browser.name === SC.BROWSER.ie && engineAndVersion[2] === '0';
  if (override) { engineAndVersion[2] = browser.version; }

  // If a `rv` number is found, use that over the engine number.
  override = userAgent.match( new RegExp('(rv)' + conExp + numExp) );
  if (override) { engineAndVersion[2] = override[2]; }


  /**
    @name SC.browser.engine
    @type {SC.ENGINE}
    @type {SC.BROWSER.unknown}
  */
  browser.engine = engineAndVersion[1];

  /**
    @name SC.browser.engineVersion
    @type String
  */
  browser.engineVersion = engineAndVersion[2];


  // If we don't know the name of the browser, use the name of the engine.
  if (browser.name === SC.BROWSER.unknown) { browser.name = browser.engine; }

  // Calculations to determine the os and version.  See SC.OS.
  osAndVersion =
    // Match the specific names first, avoiding commonly spoofed os's.
    userAgent.match( new RegExp('(blackberry)') ) ||
    userAgent.match( new RegExp('(android|iphone(?: os)|windows(?: nt))' + conExp + numExp) ) ||
    userAgent.match( new RegExp('(os|mac(?: os)(?: x))' + conExp + numExp) ) ||
    userAgent.match( new RegExp('(linux)') ) ||
    [null, SC.BROWSER.unknown, '0'];

  // Normalize the os name.
  if (isIOSDevice) { osAndVersion[1] = SC.OS.ios; }
  else if (osAndVersion[1] === 'mac os x' || osAndVersion[1] === 'mac os') { osAndVersion[1] = SC.OS.mac; }
  else if (osAndVersion[1] === 'windows nt') { osAndVersion[1] = SC.OS.win; }

  // Normalize the os version.
  osAndVersion[2] = osAndVersion[2] ? osAndVersion[2].replace(/_/g, '.') : '0';


  /**
    @name SC.browser.os
    @type {SC.OS}
    @type {SC.BROWSER.unknown}
  */
  browser.os = osAndVersion[1];

  /**
    @name SC.browser.osVersion
    @type String
  */
  browser.osVersion = osAndVersion[2];


  // The following long list of properties have all been deprecated.  While they
  // are a bit less verbose then the above constants, they lack standardization
  // and can be prone to failure.  Rather than continuing to expand this list
  // with more and more one-off comparisons, which often muddle the line between
  // the browser, the engine, the os and the device, it seems more practical to
  // only maintain the 7 identifiable properties listed above:  device, name,
  // version, os, osVersion, engine and engineVersion.

  /** @deprecated Since version 1.7. Use browser.os === SC.OS.windows.
    @name SC.browser.isWindows
    @type Boolean
  */
  browser.windows = browser.isWindows = browser.os === SC.OS.windows;

  /** @deprecated Since version 1.7. Use browser.os === SC.OS.mac.
    @name SC.browser.isMac
    @type Boolean
  */
  browser.mac = browser.isMac = browser.os === SC.OS.mac;

  /** @deprecated Since version 1.7. Use browser.os === SC.OS.mac && browser.compare(browser.osVersion, '10.7') == 0
    @name SC.browser.isLion
    @type Boolean
  */
  browser.lion = browser.isLion = !!(/mac os x 10_7/.test(userAgent) && !/like mac os x 10_7/.test(userAgent));

  /** @deprecated Since version 1.7. Use browser.device === SC.DEVICE.iphone.
    @name SC.browser.isiPhone
    @type Boolean
  */
  browser.iPhone = browser.isiPhone = browser.device === SC.DEVICE.iphone;

  /** @deprecated Since version 1.7. Use browser.device === SC.DEVICE.ipod.
    @name SC.browser.isiPod
    @type Boolean
  */
  browser.iPod = browser.isiPod = browser.device === SC.DEVICE.ipod;

  /** @deprecated Since version 1.7. Use browser.device === SC.DEVICE.ipad.
    @name SC.browser.isiPad
    @type Boolean
  */
  browser.iPad = browser.isiPad = browser.device === SC.DEVICE.ipad;

  /** @deprecated Since version 1.7. Use browser.os === SC.OS.ios.
    @name SC.browser.isiOS
    @type Boolean
  */
  browser.iOS = browser.isiOS = browser.os === SC.OS.ios;

  /** @deprecated Since version 1.7. Use browser.os === SC.OS.android or browser.name === SC.BROWSER.android or browser.device === SC.DEVICE.android.
    @name SC.browser.isAndroid
    @type Boolean
  */
  browser.android = browser.isAndroid = browser.os === SC.OS.android;

  /** @deprecated Since version 1.7. Use browser.version or browser.engineVersion.
    @name SC.browser.opera
    @type String
  */
  browser.opera = browser.name === SC.BROWSER.opera ? browser.version : '0';

  /** @deprecated Since version 1.7. Use browser.name === SC.BROWSER.opera.
    @name SC.browser.isOpera
    @type Boolean
  */
  browser.isOpera = browser.name === SC.BROWSER.opera;

  /** @deprecated Since version 1.7. Use browser.version or browser.engineVersion.
    @name SC.browser.msie
    @type String
  */
  browser.msie = browser.name === SC.BROWSER.ie ? browser.version : '0';

  /** @deprecated Since version 1.7. Use browser.engine === SC.ENGINE.trident.
    @name SC.browser.isIE
    @type Boolean
  */
  browser.isIE = browser.engine === SC.ENGINE.trident;

  /** @deprecated Since version 1.7. Use browser.compare(browser.version, '8') <= 0.
    @name SC.browser.isIE8OrLower
    @type Boolean
  */
  browser.isIE8OrLower = browser.name === SC.BROWSER.ie && browser.version <= 8;

  /** @deprecated Since version 1.7. Use browser.version or browser.engineVersion.
    @name SC.browser.mozilla
    @type String
  */
  browser.mozilla = browser.engine === SC.ENGINE.gecko ? browser.version : '0';

  /** @deprecated Since version 1.7. Use browser.name === SC.BROWSER.firefox or browser.engine === SC.ENGINE.gecko.
    @name SC.browser.isMozilla
    @type Boolean
  */
  browser.isMozilla = browser.engine === SC.ENGINE.gecko;

  /** @deprecated Since version 1.7. Use browser.engineVersion.
    @name SC.browser.webkit
    @type String
  */
  browser.webkit = browser.engine === SC.ENGINE.webkit ? browser.engineVersion : '0';

  /** @deprecated Since version 1.7. Use browser.engine === SC.ENGINE.webkit.
    @name SC.browser.isWebkit
    @type Boolean
  */
  browser.isWebkit = browser.engine === SC.ENGINE.webkit;

  /** @deprecated Since version 1.7. Use browser.version.
    @name SC.browser.chrome
    @type String
  */
  browser.chrome = browser.name === SC.BROWSER.chrome ? browser.version : '0';

  /** @deprecated Since version 1.7. Use browser.name === SC.BROWSER.chrome.
    @name SC.browser.isChrome
    @type Boolean
  */
  browser.isChrome = browser.name === SC.BROWSER.chrome;

  /** @deprecated Since version 1.7. Use browser.version.
    @name SC.browser.mobileSafari
    @type String
  */
  browser.mobileSafari = browser.os === SC.OS.ios ? browser.version : '0';

  /** @deprecated Since version 1.7. Use browser.name === SC.BROWSER.safari && browser.os === SC.OS.ios
    @name SC.browser.isMobileSafari
    @type Boolean
  */
  browser.isMobileSafari = browser.name === SC.BROWSER.safari && browser.os === SC.OS.ios;

  /** @deprecated Since version 1.7. Use browser.version.
    @name SC.browser.iPadSafari
    @type String
  */
  browser.iPadSafari = browser.device === SC.DEVICE.ipad && browser.name === SC.BROWSER.safari ?
    browser.version : 0;

  /** @deprecated Since version 1.7. Use browser.device === SC.DEVICE.ipad && browser.name === SC.BROWSER.safari
    @name SC.browser.isiPadSafari
    @type Boolean
  */
  browser.isiPadSafari = browser.device === SC.DEVICE.ipad && browser.name === SC.BROWSER.safari;

  /** @deprecated Since version 1.7. Use browser.version.
    @name SC.browser.iPhoneSafari
    @type String
  */
  browser.iPhoneSafari = browser.device === SC.DEVICE.iphone && browser.name === SC.BROWSER.safari ?
    browser.version : 0;

  /** @deprecated Since version 1.7. Use browser.device === SC.DEVICE.iphone && browser.name === SC.BROWSER.safari
    @name SC.browser.isiPhoneSafari
    @type Boolean
  */
  browser.isiPhoneSafari = browser.device === SC.DEVICE.iphone && browser.name === SC.BROWSER.safari;

  /** @deprecated Since version 1.7. Use browser.version.
    @name SC.browser.iPodSafari
    @type String
  */
  browser.iPodSafari = browser.device === SC.DEVICE.ipod && browser.name === SC.BROWSER.safari ?
    browser.version : 0;

  /** @deprecated Since version 1.7. Use browser.device === SC.DEVICE.ipod && browser.name === SC.BROWSER.safari
    @name SC.browser.isiPodSafari
    @type Boolean
  */
  browser.isiPodSafari = browser.device === SC.DEVICE.ipod && browser.name === SC.BROWSER.safari;

  /** @deprecated Since version 1.7. Use SC.platform.standalone.
    @name SC.browser.isiOSHomeScreen
    @type Boolean
  */
  browser.isiOSHomeScreen = browser.isMobileSafari && !(/apple.*mobile.*safari/.test(userAgent));

  /** @deprecated Since version 1.7. Use browser.version.
    @name SC.browser.safari
    @type String
  */
  browser.safari = browser.name === SC.BROWSER.safari && browser.os === SC.OS.mac ?
    browser.version : 0;

  /** @deprecated Since version 1.7. Use browser.name === SC.BROWSER.safari && browser.os === SC.OS.mac.
    @name SC.browser.isSafari
    @type Boolean
  */
  browser.isSafari = browser.name === SC.BROWSER.safari && browser.os === SC.OS.mac;

  /**
    @name SC.browser.language
    @type String
  */
  browser.language = language.split('-', 1)[0];

  /**
    @name SC.browser.countryCode
    @type String
  */
  browser.countryCode = language.split('-')[1] ? language.split('-')[1].toLowerCase() : undefined;

  /** @deprecated Since version 1.7. Use browser.name.  See SC.BROWSER for possible values.
    Possible values:

      - 'ie'
      - 'mozilla'
      - 'chrome'
      - 'safari'
      - 'opera'
      - 'mobile-safari'
      - 'unknown'

    @name SC.browser.current
    @type String
    @default 'unknown'
  */
  browser.current = browser.name;

  return browser;
};


/** @class

  This object contains information about the browser environment SproutCore is
  running in. This includes the following properties:

    - browser.device                  ex. SC.DEVICE.ipad
    - browser.name                    ex. SC.BROWSER.chrome
    - browser.version                 ex. '16.0.2.34'
    - browser.os                      ex. SC.OS.mac
    - browser.osVersion               ex. '10.6'
    - browser.engine                  ex. SC.ENGINE.webkit
    - browser.engineVersion           ex. '533.29'

  Note: User agent sniffing does not provide guaranteed results and spoofing may
  affect the accuracy.  Therefore, as a general rule, it is much better
  to rely on the browser's verified capabilities in SC.platform.

  Based on the unit test samples, the most stable browser properties appear to
  be `engine` and `engineVersion`.

  @since SproutCore 1.0
*/
SC.browser = SC.detectBrowser();

/* >>>>>>>>>> BEGIN source/system/bench.js */
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Strobe Inc. and contributors.
//            Portions ©2008-2011 Apple Inc. All rights reserved.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*global SC_benchmarkPreloadEvents*/
// sc_require("system/browser")
if (typeof SC_benchmarkPreloadEvents !== "undefined") {
  SC.benchmarkPreloadEvents = SC_benchmarkPreloadEvents;
  SC_benchmarkPreloadEvents = undefined;
} else {
  SC.benchmarkPreloadEvents = { headStart: new Date().getTime() };
}
/* >>>>>>>>>> BEGIN source/system/loader.js */
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Strobe Inc. and contributors.
//            Portions ©2008-2011 Apple Inc. All rights reserved.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================

// sc_require("system/browser");

SC.setupBodyClassNames = function() {
  var el = document.body,
      browser, platform, shadows, borderRad, classNames, style, ieVersion;
  if (!el) return ;

  browser = SC.browser.current ;
  platform = SC.browser.isWindows ? 'windows' : SC.browser.isMac ? 'mac' : 'other-platform' ;
  style = document.documentElement.style;
  shadows = (style.MozBoxShadow !== undefined) ||
                (style.webkitBoxShadow !== undefined) ||
                (style.oBoxShadow !== undefined) ||
                (style.boxShadow !== undefined);

  borderRad = (style.MozBorderRadius !== undefined) ||
              (style.webkitBorderRadius !== undefined) ||
              (style.oBorderRadius !== undefined) ||
              (style.borderRadius !== undefined);

  classNames = el.className ? el.className.split(' ') : [] ;
  if(shadows) classNames.push('box-shadow');
  if(borderRad) classNames.push('border-rad');
  classNames.push(browser, platform) ;

  // This isn't a perfectly correct way to compare versions, but should be okay
  // in practical usage.
  ieVersion = parseInt(SC.browser.version, 10);
  if (SC.browser.isIE) {
    if (ieVersion === 7) {
      classNames.push('ie7');
    }
    else if (ieVersion === 8) {
      classNames.push('ie8');
    }
    else if (ieVersion === 9) {
      classNames.push('ie9');
    }
  }

  if(browser==="safari" || browser==="chrome") classNames.push('webkit');
  if (SC.browser.isMobileSafari) classNames.push('mobile-safari') ;
  if ('createTouch' in document) classNames.push('touch');
  el.className = classNames.join(' ') ;
} ;





</script>


    <script>
      (function() {
        var styles = [];
        if (window.devicePixelRatio == 2 || window.location.search.indexOf("2x") > -1) {
          styles = ["/static/sproutcore/testing/en/current/stylesheet.css?1373048692"];
          SC.APP_IMAGE_ASSETS = [];
        } else {
          styles = ["/static/sproutcore/testing/en/current/stylesheet.css?1373048692"];
          SC.APP_IMAGE_ASSETS = [];
        }


        var head = document.getElementsByTagName("head")[0],
            len = styles.length, idx, css;
        for (idx = 0; idx < len; idx++) {
          css = document.createElement('link');
          css.rel   = 'stylesheet';
          css.type  = 'text/css';
          css.href  = styles[idx];
          css.media = 'screen'
          head.appendChild(css);
        }
      })();
    </script>

    
    <script>
      SC.benchmarkPreloadEvents['headEnd'] = new Date().getTime();
    </script>
  </head>

  <body class="sc-theme sc-focus">
    <script>
      SC.benchmarkPreloadEvents['bodyStart'] = new Date().getTime();
    </script>
<script type="text/javascript">
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Strobe Inc. and contributors.
//            Portions ©2008-2011 Apple Inc. All rights reserved.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================

// sc_resource('setup_body_class_names'); // publish into inline format

if (SC.setupBodyClassNames) SC.setupBodyClassNames() ;

</script>


  <script type="text/javascript" src="/static/sproutcore/jquery/en/current/javascript.js?1373048692"></script>
  <script type="text/javascript" src="/static/sproutcore/debug/en/current/javascript.js?1373048692"></script>
  <script type="text/javascript" src="/static/sproutcore/testing/en/current/javascript.js?1373048692"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/javascript.js?1373048692"></script>
  <script type="text/javascript" src="/static/sproutcore/datetime/core/en/current/javascript.js?1373048692"></script>
  <script type="text/javascript" src="/static/sproutcore/datastore/en/current/javascript.js?1373048692"></script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/data_sources/cascade.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test Sample */

var store;

module("SC.CascadeDataSource", {
  setup: function () {
    SC.RunLoop.begin();

    var Sample = (window.Sample = SC.Object.create());

    Sample.FooDataSource = SC.DataSource.extend({
      commitRecords: function (st, createStoreKeys, updateStoreKeys, destroyStoreKeys, params) {
        equals(store, st, "should equal store");
        equals(0, createStoreKeys[0], "should equal [0]");
        equals(1, updateStoreKeys[0], "should equal [1]");
        equals(2, destroyStoreKeys[0], "should equal [2]");
        equals('world', params.hello, 'should equal { hello: "world" }');
        return YES;
      },

      retriveRecords: function () {
        ok(true, "retriveRecords should be handled by baz");
        return NO;
      },

      fetch: function (store, query) {
        ok(true, "fetch should be handled by bar");
        return NO;
      },

      cancel: function (st, storeKeys) {
        equals(store, st, "should equal store");
        equals(1, storeKeys[0], "should equal [1]");
        return NO;
      }
    });
    Sample.fooDataSource = Sample.FooDataSource.create();

    Sample.BarDataSource = SC.DataSource.extend({
      commitRecords: function () {
        ok(false, "should never be called, since foo handles commitRecords first");
        return NO;
      },

      retriveRecords: function () {
        ok(true, "retriveRecords should be handled by baz");
        return NO;
      },

      fetch: function (st, query) {
        equals(store, st, "should equal store");
        equals('query', query, "should equal 'query'");
        return YES;
      }
    });
    Sample.barDataSource = Sample.BarDataSource.create();

    Sample.BazDataSource = SC.DataSource.extend({
      commitRecords: function () {
        ok(false, "should never be called, since foo handles commitRecords first");
        return NO;
      },

      retrieveRecords: function (st, storeKeys, ids) {
        equals(store, st, "should equal store");
        equals(0, storeKeys[0], "should equal [0]");
        equals("id", ids[0], 'should equal ["id"]');
        return YES;
      },

      fetch: function () {
        ok(false, "should never be called, since bar handles fetch first");
        return NO;
      }
    });
    Sample.bazDataSource = Sample.BazDataSource.create();

    Sample.dataSource = SC.CascadeDataSource.create({
      dataSources: "foo bar baz".w(),

      foo: Sample.fooDataSource,
      bar: Sample.barDataSource,
      baz: Sample.bazDataSource
    });

    store = SC.Store.create({ dataSource: Sample.dataSource });
  },

  teardown: function () {
    SC.RunLoop.end();
  }
});

test("Verify dataSources points to the actual dataSource", function () {
  var dataSource = Sample.dataSource;
  equals(dataSource.dataSources[0], dataSource.foo, 'should equal data source foo');
  equals(dataSource.dataSources[1], dataSource.bar, 'should equal data source bar');
  equals(dataSource.dataSources[2], dataSource.baz, 'should equal data source baz');
});

test("Verify dataSources added using 'from' are appended in order", function () {
  Sample.dataSource = SC.CascadeDataSource.create()
       .from(Sample.fooDataSource)
       .from(Sample.barDataSource)
       .from(Sample.bazDataSource);

  var dataSource = Sample.dataSource;
  equals(dataSource.dataSources[0], Sample.fooDataSource, 'should equal data source foo');
  equals(dataSource.dataSources[1], Sample.barDataSource, 'should equal data source bar');
  equals(dataSource.dataSources[2], Sample.bazDataSource, 'should equal data source baz');
});

test("Verify dataSource returns 'YES' when handled by a child dataSource for commitRecords", function () {
  ok(Sample.dataSource.commitRecords(store, [0], [1], [2], { hello: "world" }),
     "commitRecords should be handled by foo");
});

test("Verify dataSource returns 'YES' when handled by a child dataSource for fetch", function () {
  ok(Sample.dataSource.fetch(store, 'query'), "fetch should be handled by bar");
});

test("Verify dataSource returns 'YES' when handled by a child dataSource for retriveRecords", function () {
  ok(Sample.dataSource.retrieveRecords(store, [0], ['id']), "retrieveRecords should be handled by baz");
});

test("Verify dataSource returns 'NO' when not handled by a child dataSource", function () {
  ok(!Sample.dataSource.cancel(store, [1]), "cancel should be handled by no data source");
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/data_sources/data_source.js"; 
}
(function() {
// ==========================================================================
// Project:   SC.DataSource Unit Test
// Copyright: ©2011 Junction Networks and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals JN module test ok equals same stop start */

var MyApp, wasCalled, resetWasCalled;
module("SC.DataSource", {
  setup: function () {
    MyApp = window.MyApp = {};
    MyApp.store = SC.Store.create();
    MyApp.Foo = SC.Record.extend();

    MyApp.DataSource = SC.DataSource.extend({
      fetch: function (store, query) {
        wasCalled = true;
        equals(arguments.length, 2);
        return YES;
      },

      createRecord: function (store, storeKey, params) {
        wasCalled = true;
        equals(arguments.length, 3);
        return YES;
      },

      updateRecord: function (store, storeKey, params) {
        wasCalled = true;
        equals(arguments.length, 3);
        return YES;
      },

      retrieveRecord: function (store, storeKey, params) {
        wasCalled = true;
        equals(arguments.length, 3);
        return YES;
      },

      destroyRecord: function (store, storeKey, params) {
        wasCalled = true;
        equals(arguments.length, 3);
        return YES;
      },

      reset: function() {
        resetWasCalled = true;
        return this;
      }
    });
    SC.RunLoop.begin();
  },

  teardown: function () {
    SC.RunLoop.end();
  }
});

test("The dataSource will forward calls to the appropriate methods", function () {
  var ds = MyApp.DataSource.create();
  MyApp.store.set('dataSource', ds);
  ok(MyApp.store.find(SC.Query.remote(MyApp.Foo)),
     "the fetch should return a record array");
  ok(wasCalled, "`fetch` should have been called");
  wasCalled = NO;

  ok(MyApp.store.find(MyApp.Foo, "testing retrieve"),
     "retrieve should return a new record (because the dataSource handled the request YES)");
  ok(wasCalled, "`retrieve` should have been called");
  wasCalled = NO;

  var rec = MyApp.store.createRecord(MyApp.Foo, {});

  equals(MyApp.store.commitRecord(MyApp.Foo, 'foo', rec.get('storeKey')), YES,
         "commiting a new record should return YES");
  ok(wasCalled, "`createRecord` should have been called");
  wasCalled = NO;

  MyApp.store.writeStatus(rec.get('storeKey'), SC.Record.READY_CLEAN);

  rec.set('zero', 0);
  equals(MyApp.store.commitRecord(MyApp.Foo, 'foo', rec.get('storeKey')), YES,
         "updating a record should return YES");
  ok(wasCalled, "`updateRecord` should have been called");
  wasCalled = NO;

  MyApp.store.writeStatus(rec.get('storeKey'), SC.Record.READY_CLEAN);

  rec.destroy();
  // broken in SC.Store
  equals(MyApp.store.commitRecord(MyApp.Foo, 'foo', rec.get('storeKey')), YES,
     "destroying the record should return YES");
  ok(wasCalled, "`destroyRecord` should have been called");
});

test("The dataSource will return YES when all records committed return YES", function () {
  var ds = MyApp.DataSource.create({
    createRecord: function () { return YES; },
    updateRecord: function () { return YES; },
    destroyRecord: function () { return YES; }
  });

  MyApp.store.set('dataSource', ds);

  var rec1 = MyApp.store.createRecord(MyApp.Foo, {}),
      rec2, rec3;

  equals(MyApp.store.commitRecords(), YES,
         "commiting a single new record should return YES");

  MyApp.store.writeStatus(rec1.get('storeKey'), SC.Record.READY_CLEAN);

  rec1.set('zero', 0);
  rec2 = MyApp.store.createRecord(MyApp.Foo, {});

  equals(MyApp.store.commitRecords(), YES,
         "commiting records for an 'update' and 'create' should return YES");

  MyApp.store.writeStatus(rec1.get('storeKey'), SC.Record.READY_CLEAN);
  MyApp.store.writeStatus(rec2.get('storeKey'), SC.Record.READY_CLEAN);

  rec1.destroy();
  rec2.set('one', 1);
  rec3 = MyApp.store.createRecord(MyApp.Foo, {});

  equals(MyApp.store.commitRecords(), YES,
         "commiting records for an 'update', 'create', and 'destroy' should return YES");
});

test("The dataSource will return SC.MIXED_STATE when all records committed return YES and NO", function () {
  var ds = MyApp.DataSource.create({
    createRecord: function () { return NO; },
    updateRecord: function () { return YES; },
    destroyRecord: function () { return NO; }
  });

  MyApp.store.set('dataSource', ds);

  var rec1 = MyApp.store.createRecord(MyApp.Foo, {}),
      rec2, rec3;

  equals(MyApp.store.commitRecords(), NO,
         "commiting a single new record should return NO");

  MyApp.store.writeStatus(rec1.get('storeKey'), SC.Record.READY_CLEAN);

  rec1.set('zero', 0);
  rec2 = MyApp.store.createRecord(MyApp.Foo, {});

  equals(MyApp.store.commitRecords(), SC.MIXED_STATE,
         "commiting records for an 'update' and 'create' should return %@".fmt(SC.MIXED_STATE));

  MyApp.store.writeStatus(rec1.get('storeKey'), SC.Record.READY_CLEAN);
  MyApp.store.writeStatus(rec2.get('storeKey'), SC.Record.READY_CLEAN);

  rec1.destroy();
  rec2.set('one', 1);
  rec3 = MyApp.store.createRecord(MyApp.Foo, {});

  equals(MyApp.store.commitRecords(), SC.MIXED_STATE,
         "commiting records for an 'update', 'create', and 'destroy' should return %@".fmt(SC.MIXED_STATE));
});

test("The dataSource will return NO when all records committed return NO", function () {
  var ds = MyApp.DataSource.create({
    createRecord: function () { return NO; },
    updateRecord: function () { return NO; },
    destroyRecord: function () { return NO; }
  });
  MyApp.store.set('dataSource', ds);

  var rec1 = MyApp.store.createRecord(MyApp.Foo, {}),
      rec2, rec3;

  equals(MyApp.store.commitRecords(), NO,
         "commiting a single new record should return NO");

  MyApp.store.writeStatus(rec1.get('storeKey'), SC.Record.READY_CLEAN);

  rec1.set('zero', 0);
  rec2 = MyApp.store.createRecord(MyApp.Foo, {});

  equals(MyApp.store.commitRecords(), NO,
         "commiting records for an 'update' and 'create' should return NO");

  MyApp.store.writeStatus(rec1.get('storeKey'), SC.Record.READY_CLEAN);
  MyApp.store.writeStatus(rec2.get('storeKey'), SC.Record.READY_CLEAN);

  rec1.destroy();
  rec2.set('one', 1);
  rec3 = MyApp.store.createRecord(MyApp.Foo, {});

  equals(MyApp.store.commitRecords(), NO,
         "commiting records for an 'update', 'create', and 'destroy' should return NO");
});

test("The store calls reset on the dataSource when reset", function(){
  MyApp.store.set('dataSource', MyApp.DataSource.create());
  resetWasCalled = NO; // Just to be sure

  MyApp.store.reset();
  ok(resetWasCalled, "should have called reset");
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/data_sources/fixtures.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp Sample */

var store, fds, storeKey1,storeKey2;

module("SC.FixturesDataSource", {
  setup: function() {
    SC.RunLoop.begin();
    
    var Sample = (window.Sample= SC.Object.create());
    Sample.File = SC.Record.extend({ test:'hello'});

    // files
    Sample.File.FIXTURES = [
    { guid: '10', name: 'Home', url: '/emily_parker', isDirectory: true, parent: null, children: 'Collection'},
    { guid: '11', name: 'Documents', fileType: 'documents', url: '/emily_parker/Documents', isDirectory: true, parent: '10', children: 'Collection', createdAt: 'June 15, 2007', modifiedAt: 'October 21, 2007', filetype: 'directory', isShared: false},
    { guid: '137',name: 'Library', fileType: 'library', url: '/emily_parker/Library', isDirectory: true, parent: '10', children: 'Collection', createdAt: 'June 15, 2007', modifiedAt: 'October 21, 2007', filetype: 'directory', isShared: false},
    { guid: '12', name: 'Movies', fileType: 'movies', url: '/emily_parker/Movies', isDirectory: true, parent: '10', children: 'Collection', createdAt: 'June 15, 2007', modifiedAt: 'June 15, 2007', filetype: 'directory', isShared: true, sharedAt: 'October 15, 2007', sharedUntil: 'March 31, 2008', sharedUrl: '2fhty', isPasswordRequired: true},
    { guid: '134',name: 'Music', fileType: 'music', url: '/emily_parker/Music', isDirectory: true, parent: '10', children: 'Collection', createdAt: 'June 15, 2007', modifiedAt: 'June 15, 2007', filetype: 'directory', isShared: true, sharedAt: 'October 15, 2007', sharedUntil: 'March 31, 2008', sharedUrl: '2fhty', isPasswordRequired: true},
    { guid: '135',name: 'Pictures', fileType: 'pictures', url: '/emily_parker/Pictures', isDirectory: true, parent: '10', children: 'Collection', createdAt: 'June 15, 2007', modifiedAt: 'June 15, 2007', filetype: 'directory', isShared: true, sharedAt: 'October 15, 2007', sharedUntil: 'March 31, 2008', sharedUrl: '2fhty', isPasswordRequired: true},
    { guid: '13', name: 'Auto Insurance', fileType: 'folder', url: '/emily_parker/Documents/Auto%20Insurance', isDirectory: true, parent: '11', children: 'Collection', createdAt: 'June 15, 2007', modifiedAt: 'October 21, 2007', filetype: 'directory', isShared: false},
    { guid: '150', name: 'Birthday Invitation.pdf', fileType: 'file', url: '/emily_parker/Documents/Birthday%20Invitation', isDirectory: false, parent: '11', createdAt: 'October 17, 2007', modifiedAt: 'October 21, 2007', filetype: 'pdf', isShared: false},
    { guid: '136', name: 'Software', fileType: 'software', url: '/emily_parker/Software', isDirectory: true, parent: '10', children: 'Collection', createdAt: 'June 15, 2007', modifiedAt: 'June 15, 2007', filetype: 'directory', isShared: true, sharedAt: 'October 15, 2007', sharedUntil: 'March 31, 2008', sharedUrl: '2fhty', isPasswordRequired: true}
    ];
    
    store = SC.Store.create().from(SC.Record.fixtures);
  },
  
  teardown: function() {
    SC.RunLoop.end();
  }
});

test("Verify find() loads all fixture data", function() {

  var result = store.find(Sample.File),
      rec, storeKey, dataHash;
  
  ok(result, 'should return a result');
  equals(result.get('length'), Sample.File.FIXTURES.get('length'), 'should return records for each item in FIXTURES');
  
  // verify storeKeys actually return Records
  var idx, len = result.get('length'), expected = [];
  for(idx=0;idx<len;idx++) {
    rec = result.objectAt(idx);
    storeKey = rec ? rec.get('storeKey') : null;
    dataHash = storeKey ? store.readDataHash(storeKey) : null;

    ok(!!dataHash, 'storeKey at result[%@] (%@) should return dataHash'.fmt(idx, storeKey));
    
    expected.push(rec); // save record for later test
  }
  
  // verify multiple calls to findAll() returns SAME data
  result = store.find(Sample.File);
  
  equals(result.get('length'), expected.length, 'second result should have same length as first');
  len = result.get('length');
  for(idx=0;idx<len;idx++) {
    rec = result.objectAt(idx);
    equals(rec, expected[idx], 'record returned at index %@ should be same as previous'.fmt(idx));
  }
});

test("Verify find() loads data from store", function() {
  var sk=store.find(Sample.File, "150");
  equals(sk.get('name'), 'Birthday Invitation.pdf', 'returns record should have name from fixture');
});


test("Destroy a record and commit", function() {
  var ret      = store.find(Sample.File, "136"),
      storeKey = ret.get('storeKey'),
      fixtures = store.get('dataSource');
      
  ok(ret, 'precond - must have record in store');
  ok(fixtures.fixtureForStoreKey(store, storeKey), 'precond - fixtures should have data for record');
  
  store.destroyRecord(Sample.File, "136");
  store.commitRecords();
  ok(!fixtures.fixtureForStoreKey(store, storeKey), 'fixtures should no longer have data for record');
});

test("Create a record and commit it", function() {

  var fixtures = store.get('dataSource'),
      dataHash = { guid: '200', name: 'Software', fileType: 'software', url: '/emily_parker/Software', isDirectory: true, parent: '10', children: 'Collection', createdAt: 'June 15, 2007', modifiedAt: 'June 15, 2007', filetype: 'directory', isShared: true, sharedAt: 'October 15, 2007', sharedUntil: 'March 31, 2008', sharedUrl: '2fhty', isPasswordRequired: true },
      storeKey ;
  
  store.createRecord(Sample.File, dataHash) ;
  store.commitRecords();

  storeKey = Sample.File.storeKeyFor(dataHash.guid);
  ok(fixtures.fixtureForStoreKey(store, storeKey), 'should have data hash in fixtures');
});


test("Update and commit a record", function() {

  var rec      = store.find(Sample.File, "10"),
      storeKey = Sample.File.storeKeyFor("10"),
      fixtures = store.get('dataSource'), 
      fixture = fixtures.fixtureForStoreKey(store, storeKey);

  equals(fixture.name, rec.get('name'), 'precond - fixture state should match name');
  equals(rec.get('status'), SC.Record.READY_CLEAN, "Status should be READY_CLEAN because no changes have been made");

  rec.set('name', 'foo');
  equals(rec.get('status'), SC.Record.READY_DIRTY, "Status should be READY_DIRTY after changing name");

  store.commitRecords();
  equals(store.readStatus(storeKey), SC.Record.READY_CLEAN, "Status in store should be READY_CLEAN after save");
  equals(rec.get('status'), SC.Record.READY_CLEAN, "Status in record should be READY_CLEAN after save");

  fixture = fixtures.fixtureForStoreKey(store, storeKey);
  equals(fixture.name, rec.get('name'), 'fixture state should update to match new name');
    
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/integration/contact_model.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Strobe Inc. and contributors.
//            Portions ©2008-2011 Apple Inc. All rights reserved.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module test ok equals same AB */

var AB;
module("Sample Model from an address book app", { 
  setup: function() {

    // define the application space
    AB = SC.Application.create({
      store: SC.Store.create(SC.Record.fixtures)
    });

    // Describes a single contact detail such as a phone number, address,
    // email, etc.
    AB.ContactDetail = SC.Record.extend({
      
    });
    
    // Describes a generic contact.  A contact has contact details, which 
    // describe contact info.  A contact also has a fullName, which changes
    // depending on the type.
    AB.Contact = SC.Record.extend({

      details: SC.Record.toMany(AB.ContactDetail)
      
    });
    
    AB.ContactGroup = SC.Record.extend({
      
      // creates a computed property that will fetch with a keyname 'contacts'
      // and params 'group': this.  Collection will be setup with newRecord
      // to create contact records.
      contacts: SC.Collection.fetch({
        inverse: 'group',
        recordType: 'AB.Contact'
      })
      
    });
    
    // a generic contact detail must always have a label, kind, and value
    AB.ContactDetail = SC.Record.extend({
      validateLabel: SC.Record.validate(String).required(),
      validateKind:  SC.Record.validate(String).required()
    });

    AB.PhoneNumber   = AB.ContactDetail.extend({
      kindDefault:  'phone',
      labelDefault: 'home'
    });
    
    AB.Contact = SC.Record.extend({

      // firstName, lastName, middleName
      // companyName
      isCompany: SC.Record.property(Boolean, { defaultValue: NO }),
      
      // contact has one or more phones stored in a hash.  
      phones: SC.Collection.inline({ recordType: 'AB.PhoneNumber' })
    });

    /* IDEA: Every record has an "owner".  The owner can be a Store or a
       Collection.  When the record is destroyed or updated, it will notify
       its owner.
       
       A Collection can be inlined, referenced, or fetched.  Inlined means 
       the full record data is stored in the parent itself.  Referenced means
       only the primaryKey is stored.  Fetched means the collection is loaded
       from the store dynamically.
       
       A Collection can also indicate that it's records are dependent.  
       Dependent records are owned exclusively by the parent record.  Deleting
       parent will delete the collection also.
       
       Otherwise deleting the record will remove it from the store only.
      */
      
    /* hm -- a record could have details stored inline for optimization, but 
       it is not actually owned there.  it should just be loaded into the 
       store and treated independently.
    */
    
    // A contact has contactDetails, which is an array of inlined contact 
    // details.
    AB.Contact = SC.Record.extend({
      
      firstNameType: String,
      lastNameType:  String,
      
      contactDetailsType: SC.Collection.inline({
        isDependent: YES,
        recordType:  'AB.ContactDetail'
      }),
      
      // a contact belongs to one or more groups stored as an array on 
      // the contact.  You can change the groups array by replacing the 
      // array.
      groups: function(key, groups) {

        // if groups is replaced, write back guids
        // also, each group record should have it's contacts invalidated.
        if (groups !== undefined) {
          this.writeAttribute('groups', groups.getEach('guid')) ;
          groups.invoke('notifyPropertyChange', 'contacts');
        }
        return this.get('store').records(this.readAttribute('groups'));
      }.property().cacheable()
      
    });
    
    AB.ContactAddress = SC.Record.extend({
      
      descriptionType: String,
      street1: String,
      street2: String,
      city: String,
      state: String,
      country: String,   
      
      // the contact the address belongs to.
      contact: function() {
        this.get('store').record(this.readAttribute('contact'));
      }
    });
    
  }
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/integration/cyclical_relationship.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Strobe Inc. and contributors.
//            Portions ©2008-2011 Apple Inc. All rights reserved.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module test ok equals same AB */

module("Cyclical relationships", { 
  setup: function() {

    // define the application space
    window.AB = SC.Object.create({
      store: SC.Store.create().from(SC.Record.fixtures)
    }); 

    // ..........................................................
    // MODEL
    // 
    
    // Describes a single contact
    AB.Contact = SC.Record.extend({
      name: SC.Record.attr(String),
      group: SC.Record.toOne('AB.Group'),
      isFavorite: SC.Record.attr(Boolean)
    });
    
    AB.Group = SC.Record.extend({
      name: SC.Record.attr(String),
      
      // dynamically discover contacts for a group using a foreign key
      contacts: function() {
        var q = SC.Query.local(AB.Contact, "group = {record}", {
          record: this
        });  
        return this.get('store').find(q);
      }.property().cacheable(),
      
      // discover favorite contacts only
      favoriteContacts: function() {
        return this.get('contacts').filterProperty('isFavorite', YES);
      }.property('contacts').cacheable(),
      
      // we need to reset favoriteContacts whenever the contacts themselves
      // change
      contactsContentDidChange: function() {
        this.notifyPropertyChange('favoriteContacts');
      }.observes('.contacts*[]')
      
    });
    
    AB.Group.FIXTURES = [
      { guid: 100, name: "G1" },
      { guid: 101, name: "G2" }
    ];

    AB.Contact.FIXTURES = [
      { guid: 1,
        name: "G1-Fav1",
        group: 100,
        isFavorite: YES },

      { guid: 2,
        name: "G1-Fav2",
        group: 100,
        isFavorite: YES },

      { guid: 3,
        name: "G1-Norm1",
        group: 100,
        isFavorite: NO },

      { guid: 4,
        name: "G2-Fav1",
        group: 101,
        isFavorite: YES },

      { guid: 5,
        name: "G1-Norm1",
        group: 101,
        isFavorite: NO }
    ];
    
    
    SC.RunLoop.begin();
    
  },
  
  teardown: function() {
    SC.RunLoop.end(); 
    AB = null;
  }
});

test("getting all contacts in a group", function() {
  var group  = AB.store.find(AB.Group, 100);
  var expected = AB.store.find(AB.Contact).filterProperty('group', group);
  same(group.get('contacts').toArray(), expected, 'contacts');
});

test("finding favoriteContacts", function() {
  var group  = AB.store.find(AB.Group, 100);
  var expected = AB.store.find(AB.Contact)
    .filterProperty('group', group)
    .filterProperty('isFavorite', YES);
    
  same(group.get('favoriteContacts'), expected, 'contacts');
  
  var c = AB.store.find(AB.Contact, 4) ;
  c.set('group', group); // move to group...
  SC.RunLoop.end();
  SC.RunLoop.begin();
  
  expected.push(c);
  same(group.get('favoriteContacts'), expected, 'favoriteContacts after adding extra');
  
});



})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/integration/mail_model.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Strobe Inc. and contributors.
//            Portions ©2008-2011 Apple Inc. All rights reserved.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module test ok equals same */

var Mail;
module("Sample Model from a webmail app", { 
  setup: function() {

    // namespace
    Mail = SC.Object.create({
      store: SC.Store.create()
    });

    // Messages are stored in mailboxes.
    Mail.Mailbox = SC.Record.extend({

      name:    SC.Record.attr(String, {
        isRequired: YES
      }),

      // here is the mailbox type.  must be one of INBOX, TRASH, OTHER
      mailbox: SC.Record.attr(String, {
        isRequired: YES,
        only: 'INBOX TRASH OTHER'.w()
      }),
      
      // this is the sortKey that should be used to order the mailbox.
      sortKey: SC.Record.attr(String, {
        isRequired: YES,
        only: 'subject date from to'.w()
      }),
      
      // load the list of messages.  We use the mailbox guid to load the 
      // messages.  Messages use a foreign key to move the message around.
      // an edit should cause this fetched property to reload.
      //
      // when you get messages, it will fetch "mailboxMessages" from the 
      // owner store, passing the receiver as the param unless you implement
      // the mailboxMessageParams property.
      messages: SC.Record.fetch('Mail.Message')
    });
    
    // A message has a subject, date, sender, mailboxes, and messageDetail
    // which is a to-one relationship.  mailboxes is kept as an array of 
    // guids.
    Mail.Message = SC.Record.extend({

      date:        SC.Record.attr(Date, { isRequired: YES }),
      
      mailboxes:   SC.Record.toMany('Mail.Mailbox', {
        inverse: 'messages',
        isMaster: YES,
        minimum: 1 // you cannot have less than one mailbox.
      }),
      
      // describe the message detail.
      messageDetail: SC.Record.toOne('Mail.MessageDetail', {
        inverse: "message", // MessageDetail.message should == this.primaryKey
        isDependent: YES 
      }),

      // access the named property through another property.
      body:    SC.Record.through('messageDetail'),
      cc:      SC.Record.through('messageDetail'),
      bcc:     SC.Record.through('messageDetail'),
      subject: SC.Record.through('messageDetail')
    });
    
    Mail.Contact = SC.Record.extend({
      firstName: SC.Record.attr(String),
      lastName:  SC.Record.attr(String),
      email:     SC.Record.attr(String)
    });
    
    // define server.  RestServer knows how to automatically save records to 
    // the server.  You need to define your fetch requests here though.
    Mail.server = SC.RestServer.create({
      
      // fetch request for mailboxes.
      fetchMailboxes: function(params) {
        return this.fetchRequest('/ma/mailboxes?alt=json') ;
      }
    });

  }
});


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/integration/many_array.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Strobe Inc. and contributors.
//            Portions ©2008-2011 Apple Inc. All rights reserved.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================

var MyDataSource = SC.DataSource.extend({
  retrieveRecordsArguments: [],

  retrieveRecords: function(store, storeKeys) {
    this.get('retrieveRecordsArguments').push(storeKeys);
    arguments.callee.base.apply(this,arguments);
  }
});

var MyApp = {};

MyApp.Todo = SC.Record.extend({
  title: SC.Record.attr(String),
  project: SC.Record.toOne("MyApp.Project", {
    inverse: "todos", isMaster: NO
  })
});

MyApp.Project = SC.Record.extend({
  name: SC.Record.attr(String),
  todos: SC.Record.toMany("MyApp.Todo", {
    inverse: "project", isMaster: YES
  })
});

module("SC.Record.toMany array with data source", {
  setup: function() {
    window.MyApp = MyApp;
    window.MyDataSource = MyDataSource;
  },
  teardown: function() {
    window.MyApp = null;
    window.MyDataSource = null;
  }
});

test("when retrieving records with toMany association, it should call retrieveRecords once instead of calling retrieveRecord multiple times", function() {
  var store = SC.Store.create().from("MyDataSource");
  SC.RunLoop.begin();
  store.loadRecords(MyApp.Project, [
    {
      guid: 1,
      name: 'SproutCore',
      todos: [1, 2, 3]
    }
  ]);
  SC.RunLoop.end();

  SC.RunLoop.begin();
  var todos = store.find(MyApp.Project, 1).get('todos').toArray();
  SC.RunLoop.end();

  same(todos.length, 3);
  // retrieveRecords should be called only once
  same(store.get('dataSource').get('retrieveRecordsArguments').length, 1);
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/integration/test_runner_model.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Strobe Inc. and contributors.
//            Portions ©2008-2011 Apple Inc. All rights reserved.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module test ok equals same */

var TestRunner;
module("Sample Model from TestRunner Application", { 
  setup: function() {

    // namespace
    TestRunner = SC.Object.create({
      store: SC.Store.create()
    });

    // describes a single target.  has target name, target type, and url to 
    // load tests.
    TestRunner.Target = SC.Record.extend({

      /** test name */
      name: SC.Record.attr(String),
      
      /** test type - one of 'app', 'framework', 'sproutcore' */
      type: SC.Record.attr(String, { only: 'single group all'.w() }),

      /** Fetches list of tests dynamically */
      tests: SC.Record.fetch('TestRunner.Test')

    });

    /* JSON:
    
     { 
       link_test:  "url to laod test",
        },
    */ 
    TestRunner.Test = SC.Record.extend({
      
      // testName
      testUrl: SC.Record.attr({
        key: 'link_test'
      }),
      
      target: SC.Record.attr('TestRunner.Target', {
        inverse: 'tests',
        isMaster: YES,
        isEditable: NO
      })
      
    });

  }
});


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/models/datetime_recordattribute.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test */

// This file tests both SC.DateTime which is in the foundation framework and
// SC.RecordAttribute which is in the datastore framework. The desktop
// framework might not be the best place for it but it works because the
// desktop framework requires both datestore and foundation frameworks.

var sprocket, nullSprocket, d1, d2, d3;

module('SC.DateTime transform', {

  setup: function() {
    
    d1 = SC.DateTime.create({ year: 2009, month: 3, day: 1, hour: 20, minute: 30, timezone: 480 });
    d2 = SC.DateTime.create({ year: 2009, month: 3, day: 1, hour: 20, minute: 30, timezone: SC.DateTime.timezone });
    d3 = SC.DateTime.create({ year: 2009, month: 3, day: 1, hour: 20, minute: 30, timezone: 0 });
    
    var MyApp = SC.Object.create({
      store: SC.Store.create()
    });
    
    MyApp.Sprocket = SC.Record.extend({
      createdAt: SC.Record.attr(SC.DateTime),
      frenchCreatedAt: SC.Record.attr(SC.DateTime, { format: '%d/%m/%Y %H:%M:%S' }),
      unixTimeCreatedAt: SC.Record.attr(SC.DateTime, { useUnixTime: YES })
    });
        
    SC.RunLoop.begin();
    MyApp.store.loadRecords(MyApp.Sprocket, [
      { 
        guid: '1', 
        createdAt: '2009-03-01T20:30:00-08:00',
        frenchCreatedAt: '01/03/2009 20:30:00',
        unixTimeCreatedAt: 1235939400
      },
      { 
        guid: '2', 
        createdAt: null,
        frenchCreatedAt: null,
        unixTimeCreatedAt: 'invalidValue'
      }
    ]);
    SC.RunLoop.end();
    
    sprocket = MyApp.store.find(MyApp.Sprocket, '1');
    nullSprocket = MyApp.store.find(MyApp.Sprocket, '2');
  }

});

test("reading a DateTime should successfully parse the underlying string value", function() {
  equals(sprocket.get('createdAt'), d1, 'reading a DateTime should return the correct SC.DateTime object');
  equals(sprocket.get('frenchCreatedAt'), d2, 'reading a DateTime with a custom format should return the correct SC.DateTime object');
});

test("writing a DateTime should successfully format the value into a string", function() {
  d1 = d1.advance({ year: 1, hour: 2, minute: 28 });
  d2 = d2.advance({ month: -2, minute: 16 });
  
  sprocket.set('createdAt', d1);
  sprocket.set('frenchCreatedAt', d2);
  
  equals(sprocket.readAttribute('createdAt'), '2010-03-01T22:58:00-08:00', 'writing a DateTime should successfully format the value into the a string');
  equals(sprocket.readAttribute('frenchCreatedAt'), '01/01/2009 20:46:00', 'writing a DateTime with a custom format should successfully format the value into the a string');
});

test("reading or writing null values should work", function() {
  sprocket.set('createdAt', null);
  equals(sprocket.readAttribute('createdAt'), null);
  
  equals(nullSprocket.get('createdAt'), null);
});

test("reading and writing a DateTime should successfully convert to/from unix time", function() {
  // Reading test
  equals(sprocket.get('unixTimeCreatedAt'), d3, 'reading a DateTime stored in unix time format should return the correct SC.DateTime object');
  
  // Writing test
  d3 = d3.advance({ year: 2, month: 7, day: 14, hour: -3 });
  sprocket.set('unixTimeCreatedAt', d3);
  equals(sprocket.readAttribute('unixTimeCreatedAt'), 1318699800, 'writing a DateTime attribute that stored in unix time format should store the correct attribute');
});

test("unix time should default to 0 ms when invalid value is provided", function() {
  equals(nullSprocket.get('unixTimeCreatedAt'), SC.DateTime.create({ milliseconds: 0, timezone: 0 }), 'reading a DateTime store in unix time should default to 0ms when an invalid value is provided');
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/models/many_attribute.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// test core array-mapping methods for ManyArray with ManyAttribute
var storeKeys, rec, rec2, rec3, rec4;
var foo1, foo2, foo3, bar1, bar2, bar3;

module("SC.ManyAttribute core methods", {
  setup: function() {
    SC.RunLoop.begin();
    MyApp = SC.Object.create({
      store: SC.Store.create()
    });
    
    MyApp.Foo = SC.Record.extend({
      
      // test simple reading of a pass-through prop
      firstName: SC.Record.attr(String),

      // test mapping to another internal key
      otherName: SC.Record.attr(String, { key: "firstName" }),
      
      // test mapping Date
      date: SC.Record.attr(Date),
      
      // used to test default value
      defaultValue: SC.Record.attr(String, {
        defaultValue: "default"
      }),
      
      // test toMany relationships
      fooMany: SC.Record.toMany('MyApp.Foo'),

      // test toMany relationships with different key
      fooManyKeyed: SC.Record.toMany('MyApp.Foo', {
        key: 'fooIds'
      }),

      // test many-to-many relationships with inverse
      barToMany: SC.Record.toMany('MyApp.Bar', {
        inverse: 'fooToMany', isMaster: YES, orderBy: 'name'
      }),
      
      // test many-to-one relationships with inverse
      barToOne: SC.Record.toMany('MyApp.Bar', {
        inverse: 'fooToOne', isMaster: NO
      })
      
    });
    
    MyApp.Bar = SC.Record.extend({
      
      // test many-to-many
      fooToMany: SC.Record.toMany('MyApp.Foo', {
        inverse: 'barToMany', isMaster: NO
      }),
      
      // test many-to-one
      fooToOne: SC.Record.toOne('MyApp.Foo', {
        inverse: 'barToOne', isMaster: YES
      })
    });
    
    storeKeys = MyApp.store.loadRecords(MyApp.Foo, [
      { guid: 1, 
        firstName: "John", 
        lastName: "Doe",
        barToMany: ['bar1'],
        barToOne:  ['bar1', 'bar2'] 
      },
      
      { guid: 2, 
        firstName: "Jane", 
        lastName: "Doe",
        barToMany: ['bar1', 'bar2'],
        barToOne:  [] 
      },
      
      { guid: 3, 
        firstName: "Emily", 
        lastName: "Parker", 
        fooMany: [1,2],
        barToMany: ['bar2'],
        barToOne: [] 
      },
      
      { guid: 4,
        firstName: "Johnny",
        lastName: "Cash",
        fooIds: [1,2]
      }
    ]);
    
    MyApp.store.loadRecords(MyApp.Bar, [
      { guid: "bar1", name: "A", fooToMany: [1,2], fooToOne: 1 },
      { guid: "bar2", name: "Z", fooToMany: [2,3], fooToOne: 1 },
      { guid: "bar3", name: "C" }
    ]);
    
    foo1 = rec = MyApp.store.find(MyApp.Foo, 1);
    foo2 = rec2 = MyApp.store.find(MyApp.Foo, 2);
    foo3 = rec3 = MyApp.store.find(MyApp.Foo, 3);
    rec4 = MyApp.store.find(MyApp.Foo, 4);
    equals(rec.storeKey, storeKeys[0], 'should find record');
    
    bar1 = MyApp.store.find(MyApp.Bar, "bar1");
    bar2 = MyApp.store.find(MyApp.Bar, 'bar2');
    bar3 = MyApp.store.find(MyApp.Bar, 'bar3');
    
    SC.RunLoop.end();
  },
  
  teardown: function() {
    MyApp = rec = rec2 = rec3 = 
    foo1 = foo2 = foo3 = bar1 = bar2 = null;
  }
});

// ..........................................................
// READING
// 

test("pass-through should return builtin value" ,function() {
  equals(rec.get('firstName'), 'John', 'reading prop should get attr value');
});

test("getting toMany relationship should map guid to real records", function() {
  var rec3 = MyApp.store.find(MyApp.Foo, 3);
  equals(rec3.get('id'), 3, 'precond - should find record 3');
  equals(rec3.get('fooMany').objectAt(0), rec, 'should get rec1 instance for rec3.fooMany');
  equals(rec3.get('fooMany').objectAt(1), rec2, 'should get rec2 instance for rec3.fooMany');
});

test("getting toMany relationship should map guid to real records when using different key", function() {
  var rec4 = MyApp.store.find(MyApp.Foo, 4);
  equals(rec4.get('id'), 4, 'precond - should find record 4');
  equals(rec4.get('fooManyKeyed').objectAt(0), rec, 'should get rec1 instance for rec4.fooManyKeyed');
  equals(rec4.get('fooManyKeyed').objectAt(1), rec2, 'should get rec2 instance for rec4.fooManyKeyed');
});
 
test("getting toMany relation should not change record state", function() {
  equals(rec3.get('status'), SC.Record.READY_CLEAN, 'precond - status should be READY_CLEAN');
  
  var recs = rec3.get('fooMany');
  ok(recs, 'rec3.get(fooMany) should return records');
  equals(rec3.get('status'), SC.Record.READY_CLEAN, 'getting toMany should not change state');
});

test("reading toMany in chained store", function() {
  var recs1, recs2, store, rec3a;
  
  recs1 = rec3.get('fooMany');
  store = MyApp.store.chain();
  
  rec3a = store.find(rec3);
  recs2 = rec3a.get('fooMany');
      
  same(recs2.getEach('storeKey'), recs1.getEach('storeKey'), 'returns arrays from chained and parent should be same');
  ok(recs2 !== recs1, 'returned arrays should not be same instance');
  
});

test("reading a null relation", function() {
  
  // note: rec1 hash has NO array
  equals(rec.readAttribute('fooMany'), null, 'rec1.fooMany attr should be null');
  
  var ret = rec.get('fooMany');
  equals(ret.get('length'), 0, 'rec1.get(fooMany).length should be 0'); 
  same(ret.getEach('storeKey'), [], 'rec1.get(fooMany) should return empty array');
});

// ..........................................................
// WRITING
// 

test("writing to a to-many relationship should update set guids", function() {
  var rec3 = MyApp.store.find(MyApp.Foo, 3);
  equals(rec3.get('id'), 3, 'precond - should find record 3');
  equals(rec3.get('fooMany').objectAt(0), rec, 'should get rec1 instance for rec3.fooMany');
  
  SC.RunLoop.begin();
  rec3.set('fooMany', [rec2, rec4]);
  SC.RunLoop.end();
  
  equals(rec3.get('fooMany').objectAt(0), rec2, 'should get rec2 instance for rec3.fooMany');
  equals(rec3.get('fooMany').objectAt(1), rec4, 'should get rec4 instance for rec3.fooMany');
});

test("writing to a to-many relationship should update set guids when using a different key", function() {
  var rec4 = MyApp.store.find(MyApp.Foo, 4);
  equals(rec4.get('id'), 4, 'precond - should find record 4');
  equals(rec4.get('fooManyKeyed').objectAt(0), rec, 'should get rec1 instance for rec4.fooManyKeyed');

  SC.RunLoop.begin();
  rec4.set('fooManyKeyed', [rec2, rec3]);
  SC.RunLoop.end();

  ok(rec4.get('fooIds').isEqual([2,3]), 'should get array of guids (2, 3) for rec4.fooIds');
});

test("pushing an object to a to-many relationship attribute should update set guids", function() {
  var rec3 = MyApp.store.find(MyApp.Foo, 3);
  equals(rec3.get('id'), 3, 'precond - should find record 3');
  equals(rec3.get('fooMany').length(), 2, 'should be 2 foo instances related');
  
  rec3.get('fooMany').pushObject(rec4);
  
  equals(rec3.get('fooMany').length(), 3, 'should be 3 foo instances related');
  
  equals(rec3.get('fooMany').objectAt(0), rec, 'should get rec instance for rec3.fooMany');
  equals(rec3.get('fooMany').objectAt(1), rec2, 'should get rec2 instance for rec3.fooMany');
  equals(rec3.get('fooMany').objectAt(2), rec4, 'should get rec4 instance for rec3.fooMany');
});
 
test("modifying a toMany array should mark the record as changed", function() {
  var recs = rec3.get('fooMany');
  equals(rec3.get('status'), SC.Record.READY_CLEAN, 'precond - rec3.status should be READY_CLEAN');
  ok(!!rec4, 'precond - rec4 should be defined');
  
  SC.RunLoop.begin();
  recs.pushObject(rec4);
  SC.RunLoop.end();
  
  equals(rec3.get('status'), SC.Record.READY_DIRTY, 'record status should have changed to dirty');

});

test("Modifying a toMany array using replace", function() {
  var recs = rec.get('barToOne'),
      objectForRemoval = recs.objectAt(1);
  
  recs.replace(1, 1, null); // the object should be removed
  
  ok(objectForRemoval !== recs.objectAt(1), "record should not be present after a replace");
  equals(bar2.get('fooToOne'), null, "record should have notified attribute of change");
});


test("modifying a toMany array within a nested store", function() {

  var child = MyApp.store.chain() ; // get a chained store
  var parentFooMany = rec3.get('fooMany'); // base foo many
  
  var childRec3 = child.find(rec3); 
  var childFooMany = childRec3.get('fooMany'); // get the nested fooMany
  
  // save store keys before modifying for easy testing
  var expected = parentFooMany.getEach('storeKey');
  
  // now trying modifying...
  var childRec4 = child.find(rec4);
  equals(childFooMany.get('length'), 2, 'precond - childFooMany should be like parent');
  childFooMany.pushObject(childRec4);
  equals(childFooMany.get('length'), 3, 'childFooMany should have 1 more item');
  
  SC.RunLoop.end(); // allow notifications to process, if there were any...
  
  same(parentFooMany.getEach('storeKey'), expected, 'parent.fooMany should not have changed yet');
  equals(rec3.get('status'), SC.Record.READY_CLEAN, 'parent rec3 should still be READY_CLEAN');
  
  expected = childFooMany.getEach('storeKey'); // update for after commit

  SC.RunLoop.begin();
  child.commitChanges();
  SC.RunLoop.end();
  
  // NOTE: not getting fooMany from parent again also tests changing an array
  // underneath.  Does it clear caches, etc?
  equals(parentFooMany.get('length'), 3, 'parent.fooMany length should have changed');
  same(parentFooMany.getEach('storeKey'), expected, 'parent.fooMany should now have changed form child store');
  equals(rec3.get('status'), SC.Record.READY_DIRTY, 'parent rec3 should now be READY_DIRTY');
  
});

test("should be able to modify an initially empty record", function() {
  
  same(rec.get('fooMany').getEach('storeKey'), [], 'precond - fooMany should be empty');
  rec.get('fooMany').pushObject(rec4);
  same(rec.get('fooMany').getEach('storeKey'), [rec4.get('storeKey')], 'after edit should have new array');
});


// ..........................................................
// MANY-TO-MANY RELATIONSHIPS
// 

function checkAllClean() {
  SC.A(arguments).forEach(function(r) {
    equals(r.get('status'), SC.Record.READY_CLEAN, 'PRECOND - %@.status should be READY_CLEAN'.fmt(r.get('id')));
  }, this);
}

test("removing a record from a many-to-many", function() {
  ok(foo1.get('barToMany').indexOf(bar1) >= 0, 'PRECOND - foo1.barToMany should contain bar1');
  ok(bar1.get('fooToMany').indexOf(foo1) >= 0, 'PRECOND - bar1.fooToMany should contain foo1');
  checkAllClean(foo1, bar1);
  
  foo1.get('barToMany').removeObject(bar1);

  ok(foo1.get('barToMany').indexOf(bar1) < 0, 'foo1.barToMany should NOT contain bar1');
  ok(bar1.get('fooToMany').indexOf(foo1) < 0, 'bar1.fooToMany should NOT contain foo1');

  equals(foo1.get('status'), SC.Record.READY_DIRTY, 'foo1.status should be READY_DIRTY');
  equals(bar1.get('status'), SC.Record.READY_CLEAN, 'bar1.status should be READY_CLEAN');
  
});

test("removing a record from a many-to-many; other side", function() {
  ok(foo1.get('barToMany').indexOf(bar1) >= 0, 'PRECOND - foo1.barToMany should contain bar1');
  ok(bar1.get('fooToMany').indexOf(foo1) >= 0, 'PRECOND - bar1.fooToMany should contain foo1');
  checkAllClean(foo1, bar1);
  
  bar1.get('fooToMany').removeObject(foo1);

  ok(foo1.get('barToMany').indexOf(bar1) < 0, 'foo1.barToMany should NOT contain bar1');
  ok(bar1.get('fooToMany').indexOf(foo1) < 0, 'bar1.fooToMany should NOT contain foo1');

  equals(foo1.get('status'), SC.Record.READY_DIRTY, 'foo1.status should be READY_DIRTY');
  equals(bar1.get('status'), SC.Record.READY_CLEAN, 'bar1.status should be READY_CLEAN');
  
});

test("adding a record to a many-to-many; bar side", function() {
  ok(foo2.get('barToMany').indexOf(bar3) < 0, 'PRECOND - foo1.barToMany should NOT contain bar1');
  ok(bar3.get('fooToMany').indexOf(foo2) < 0, 'PRECOND - bar3.fooToMany should NOT contain foo1');
  checkAllClean(foo2, bar3);
  
  bar3.get('fooToMany').pushObject(foo2);

  // v-- since bar3 is added through inverse, it should follow orderBy
  equals(foo2.get('barToMany').indexOf(bar3), 1, 'foo1.barToMany should contain bar1');
  ok(bar3.get('fooToMany').indexOf(foo2) >= 0, 'bar1.fooToMany should contain foo1');

  equals(foo2.get('status'), SC.Record.READY_DIRTY, 'foo1.status should be READY_DIRTY');
  equals(bar1.get('status'), SC.Record.READY_CLEAN, 'bar1.status should be READY_CLEAN');
});


test("adding a record to a many-to-many; foo side", function() {
  ok(foo2.get('barToMany').indexOf(bar3) < 0, 'PRECOND - foo1.barToMany should NOT contain bar3');
  ok(bar3.get('fooToMany').indexOf(foo2) < 0, 'PRECOND - bar3.fooToMany should NOT contain foo1');
  checkAllClean(foo2, bar3);
  
  foo2.get('barToMany').pushObject(bar3);

  ok(foo2.get('barToMany').indexOf(bar3) >= 0, 'foo1.barToMany should contain bar3');
  ok(bar3.get('fooToMany').indexOf(foo2) >= 0, 'bar1.fooToMany should contain foo3');

  equals(foo2.get('status'), SC.Record.READY_DIRTY, 'foo1.status should be READY_DIRTY');
  equals(bar1.get('status'), SC.Record.READY_CLEAN, 'bar3.status should be READY_CLEAN');
});

// ..........................................................
// ONE-TO-MANY RELATIONSHIPS
// 

test("removing a record from a one-to-many", function() {
  ok(foo1.get('barToOne').indexOf(bar1) >= 0, 'PRECOND - foo1.barToOne should contain bar1');
  equals(bar1.get('fooToOne'), foo1, 'PRECOND - bar1.fooToOne should eq foo1');
  checkAllClean(foo1, bar1);
  
  foo1.get('barToOne').removeObject(bar1);

  ok(foo1.get('barToOne').indexOf(bar1) < 0, 'foo1.barToOne should NOT contain bar1');
  equals(bar1.get('fooToOne'), null, 'bar1.fooToOne should eq null');

  equals(foo1.get('status'), SC.Record.READY_CLEAN, 'foo1.status should be READY_CLEAN');
  equals(bar1.get('status'), SC.Record.READY_DIRTY, 'bar1.status should be READY_DIRTY');
  
});


test("removing a record from a one-to-many; other-side", function() {
  ok(foo1.get('barToOne').indexOf(bar1) >= 0, 'PRECOND - foo1.barToOne should contain bar1');
  equals(bar1.get('fooToOne'), foo1, 'PRECOND - bar1.fooToOne should eq foo1');
  checkAllClean(foo1, bar1);
  
  bar1.set('fooToOne', null);

  ok(foo1.get('barToOne').indexOf(bar1) < 0, 'foo1.barToOne should NOT contain bar1');
  equals(bar1.get('fooToOne'), null, 'bar1.fooToOne should eq null');

  equals(foo1.get('status'), SC.Record.READY_CLEAN, 'foo1.status should be READY_CLEAN');
  equals(bar1.get('status'), SC.Record.READY_DIRTY, 'bar1.status should be READY_DIRTY');
  
});


test("add a record to a one-to-many; many-side", function() {
  ok(foo1.get('barToOne').indexOf(bar3) < 0, 'PRECOND - foo1.barToOne should NOT contain bar3');
  equals(bar3.get('fooToOne'), null, 'PRECOND - bar3.fooToOne should eq null');
  checkAllClean(foo1, bar1);
  
  foo1.get('barToOne').pushObject(bar3);

  ok(foo1.get('barToOne').indexOf(bar3) >= 0, 'foo1.barToOne should contain bar3');
  equals(bar3.get('fooToOne'), foo1, 'bar3.fooToOne should eq foo1');

  equals(foo1.get('status'), SC.Record.READY_CLEAN, 'foo1.status should be READY_CLEAN');
  equals(bar3.get('status'), SC.Record.READY_DIRTY, 'bar3.status should be READY_DIRTY');
  
});


test("add a record to a one-to-many; one-side", function() {
  ok(foo1.get('barToOne').indexOf(bar3) < 0, 'PRECOND - foo1.barToOne should NOT contain bar3');
  equals(bar3.get('fooToOne'), null, 'PRECOND - bar3.fooToOne should eq null');
  checkAllClean(foo1, bar1);
  
  bar3.set('fooToOne', foo1);

  ok(foo1.get('barToOne').indexOf(bar3) >= 0, 'foo1.barToOne should contain bar3');
  equals(bar3.get('fooToOne'), foo1, 'bar3.fooToOne should eq foo1');

  equals(foo1.get('status'), SC.Record.READY_CLEAN, 'foo1.status should be READY_CLEAN');
  equals(bar3.get('status'), SC.Record.READY_DIRTY, 'bar3.status should be READY_DIRTY');
  
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/models/nested_records/data_store.js"; 
}
(function() {
/**
 * Nested Records and the Data Store(SC.Record) Unit Test
 *
 * @author Evin Grano
 */

// ..........................................................
// Basic Set up needs to move to the setup and teardown
//
var NestedRecord, store, storeKeys;

var initModels = function(){
  NestedRecord.Directory = SC.Record.extend({
    /** Child Record Namespace */
    nestedRecordNamespace: NestedRecord,
    name: SC.Record.attr(String),
    contents: SC.Record.toMany('SC.Record', { isNested: true })
  });

  NestedRecord.File = SC.Record.extend({
    name: SC.Record.attr(String)
  });

};

// ..........................................................
// Basic SC.Record Stuff
//
module("Data Store Tests for Nested Records", {

  setup: function() {
    NestedRecord = SC.Object.create({
      store: SC.Store.create()
    });
    store = NestedRecord.store;
    initModels();
    SC.RunLoop.begin();
    storeKeys = store.loadRecords([NestedRecord.Directory, NestedRecord.File], [
      {
        type: 'Directory',
        name: 'Dir 1',
        guid: 1,
        contents: [
          {
            type: 'Directory',
            name: 'Dir 2',
            guid: 2,
            contents: [
              {
                type: 'File',
                guid: 3,
                name: 'File 1'
              },
              {
                type: 'File',
                guid: 4,
                name: 'File 2'
              }
            ]
          }
        ]
      },
      {
        type: 'File',
        id: 5,
        name: 'File 3'
      }
    ]);
    SC.RunLoop.end();
  },

  teardown: function() {
    delete NestedRecord.Directory;
    delete NestedRecord.File;
    NestedRecord = null;
    store = null;
  }
});

test("Proper Initialization",function() {
  var first, second;
  equals(storeKeys.get('length'), 2, "number of primary store keys should be 2");

  // First
  first = store.materializeRecord(storeKeys[0]);
  ok(SC.kindOf(first, SC.Record), "first record is a kind of a SC.Record Object");
  ok(SC.instanceOf(first, NestedRecord.Directory), "first record is a instance of a NestedRecord.Directory Object");

  // Second
  second = store.materializeRecord(storeKeys[1]);
  ok(SC.kindOf(second, SC.Record), "second record is a kind of a SC.Record Object");
  ok(SC.instanceOf(second, NestedRecord.File), "second record is a instance of a NestedRecord.File Object");
});

test("Proper Status",function() {
  var first, second;

  // First
  first = store.materializeRecord(storeKeys[0]);
  equals(first.get('status'), SC.Record.READY_CLEAN, 'first record has a READY_CLEAN State');

  // Second
  second = store.materializeRecord(storeKeys[1]);
  equals(second.get('status'), SC.Record.READY_CLEAN, 'second record has a READY_CLEAN State');
});

test("Can Push onto child array",function() {
  var first, contents;

  // First
  first = store.materializeRecord(storeKeys[0]);
  first = first.get('contents').objectAt(0);
  contents = first.get('contents');
  equals(contents.get('length'), 2, "should have two items");
  contents.forEach(function(f){
    ok(SC.instanceOf(f, NestedRecord.File), "should be a NestedRecord.File");
    ok(f.get('name'), "should have a name property");
  });

  contents.pushObject({type: 'File', name: 'File 4', id: 12});

  equals(contents.get('length'), 3, "should have three items");
  contents.forEach(function(f){
    ok(SC.instanceOf(f, NestedRecord.File), "should be a NestedRecord.File");
    ok(f.get('name'), "should have a name property");
    equals(f.get('status'), SC.Record.READY_DIRTY, 'second record has a READY_CLEAN State');

  });

});

test("Use in Nested Store", function(){
  var nstore, dir, c, file,
      pk, id, nFile, nDir;

  // First, find the first file
  dir = store.find(NestedRecord.Directory, 1);
  ok(dir, "Directory id:1 exists");
  equals(dir.get('name'), 'Dir 1', "Directory id:1 has a name of 'Dir 1'");
  c = dir.get('contents');
  ok(c, "Content of Directory id:1 exists");
  dir = c.objectAt(0);
  ok(dir, "Directory id:2 exists");
  equals(dir.get('name'), 'Dir 2', "Directory id:2 has a name of 'Dir 2'");
  c = dir.get('contents');
  ok(c, "Content of Directory id:2 exists");
  file = c.objectAt(0);
  ok(file, "File id:1 exists");
  equals(file.get('name'), 'File 1', "File id:1 has a name of 'File 1'");

  // Second, create nested store
  nstore = store.chain();
  SC.RunLoop.begin();
  pk = file.get('primaryKey');
  id = file.get(pk);
  nFile = nstore.find(NestedRecord.File, id);
  SC.RunLoop.end();
  ok(nFile, "Nested > File id:1 exists");
  equals(nFile.get('name'), 'File 1', "Nested > File id:1 has a name of 'File 1'");

  // Third, change the name of the nested store and see what happens
  nFile.set('name', 'Change Name');
  equals(nFile.get('name'), 'Change Name', "Nested > File id:1 has changed the name to 'Changed Name'");
  equals(file.get('name'), 'File 1', "Base > File id:1 still has the name of 'File 1'");
  nDir = nstore.find(NestedRecord.Directory, 1);

  // Fourth, commit the changes
  nstore.commitChanges();
  nstore.destroy();
  nstore = null;
  equals(file.get('name'), 'Change Name', "Base > File id:1 has changed to name of 'Changed Name'");

  // Fifth, double check that the change exists
  dir = store.find(NestedRecord.Directory, 1);
  file = dir.get('contents').objectAt(0).get('contents').objectAt(0);
  equals(dir.get('status'), SC.Record.READY_DIRTY, 'Base > Directory id:1 has a READY_DIRTY State');
  equals(file.get('status'), SC.Record.READY_DIRTY, 'Base > File id:1 has a READY_DIRTY State');
  equals(file.get('name'), 'Change Name', "Base > File id:1 has actually changed to name of 'Changed Name'");

});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/models/nested_records/nested_record.js"; 
}
(function() {
/**
 * Nested Records (SC.Record) Unit Test
 *
 * @author Evin Grano
 */

// ..........................................................
// Basic Set up needs to move to the setup and teardown
//
var NestedRecord, store, testParent, testParent2, testParent3, childData1;

var initModels = function() {
  NestedRecord.ParentRecordTest = SC.Record.extend({
    /** Child Record Namespace */
    nestedRecordNamespace: NestedRecord,

    name: SC.Record.attr(String),
    info: SC.Record.toOne('NestedRecord.ChildRecordTest', { nested: true })
  });

  NestedRecord.ChildRecordTest = SC.Record.extend({
    name: SC.Record.attr(String),
    value: SC.Record.attr(String)
  });
};

// ..........................................................
// Basic SC.Record Stuff
//
module("Basic SC.Record Functions w/ Parent > Child", {

  setup: function() {
    NestedRecord = SC.Object.create({
      store: SC.Store.create()
    });
    window.NestedRecord = NestedRecord;
    store = NestedRecord.store;
    initModels();
    SC.RunLoop.begin();
    // Test Parent 1
    testParent = store.createRecord(NestedRecord.ParentRecordTest, {
      guid: 'p1',
      name: 'Parent Name',
      info: {
        type: 'ChildRecordTest',
        name: 'Child Name',
        value: 'Blue Goo',
        guid: '5001'
      }
    });
    // Test parent 2
    testParent2 = NestedRecord.store.createRecord(NestedRecord.ParentRecordTest, {
      guid: 'p2',
      name: 'Parent Name 2',
      info: {
        type: 'ChildRecordTest',
        name: 'Child Name 2',
        value: 'Purple Goo',
        guid: '5002'
      }
    });
    // Test parent 3
    testParent3 = NestedRecord.store.createRecord(NestedRecord.ParentRecordTest, {
      guid: 'p3',
      name: 'Parent Name 3',
      info: {
        type: 'ChildRecordTest',
        name: 'Child Name 3',
        value: 'Pink Goo'
      }
    });
    SC.RunLoop.end();


    // ..........................................................
    // Child Data
    //
    childData1 = {
      type: 'ChildRecordTest',
      name: 'Child Name',
      value: 'Green Goo',
      guid: '5002'
    };
  },

  teardown: function() {
    delete NestedRecord.ParentRecordTest;
    delete NestedRecord.ChildRecordTest;
    testParent = null;
    testParent2 = null;
    store = null;
    childData1 = null;
    NestedRecord = null;
    //delete(window.NestedRecord);
  }
});

test("Function: readAttribute()", function() {
  equals(testParent.readAttribute('name'), 'Parent Name', "readAttribute should be correct for name attribute");

  equals(testParent.readAttribute('nothing'), null, "readAttribute should be correct for invalid key");

  same(testParent.readAttribute('info'),
    {
      type: 'ChildRecordTest',
      name: 'Child Name',
      value: 'Blue Goo',
      guid: '5001'
    },
    "readAttribute should be correct for info child attribute");

});

test("Support Multiple Parent Records With Different Child Records", function() {

  same(testParent3.readAttribute('info'),
    {
      type: 'ChildRecordTest',
      name: 'Child Name 3',
      value: 'Pink Goo'
    },
    "readAttribute should be correct for info child attribute on new record");
  equals(testParent3.get('info').get('value'), 'Pink Goo', "get should retrieve the proper value on new record");

  same(testParent2.readAttribute('info'),
    {
      type: 'ChildRecordTest',
      name: 'Child Name 2',
      value: 'Purple Goo',
      guid: '5002'
    },
    "readAttribute should be correct for info child attribute on new record");
  equals(testParent2.get('info').get('value'), 'Purple Goo', "get should retrieve the proper value on new record");

  same(testParent.readAttribute('info'),
    {
      type: 'ChildRecordTest',
      name: 'Child Name',
      value: 'Blue Goo',
      guid: '5001'
    },
    "readAttribute should be correct for info child attribute on first record");
  equals(testParent.get('info').get('value'), 'Blue Goo', "get should retrieve the proper value on first record");
});

test("Function: writeAttribute()", function() {

  testParent.writeAttribute('name', 'New Parent Name');
  equals(testParent.get('name'), 'New Parent Name', "writeAttribute should be the new name attribute");

  testParent.writeAttribute('nothing', 'nothing');
  equals(testParent.get('nothing'), 'nothing', "writeAttribute should be correct for new key");

  testParent.writeAttribute('info', {
    type: 'ChildRecordTest',
    name: 'New Child Name',
    value: 'Red Goo'
  });
  same(testParent.readAttribute('info'),
    {
      type: 'ChildRecordTest',
      name: 'New Child Name',
      value: 'Red Goo'
    },
    "writeAttribute with readAttribute should be correct for info child attribute");

  testParent3.writeAttribute('info', {
    type: 'ChildRecordTest',
    name: 'New Child Name',
    value: 'Red Goo'
  });
  same(testParent3.readAttribute('info'),
    {
      type: 'ChildRecordTest',
      name: 'New Child Name',
      value: 'Red Goo'
    },
    "writeAttribute with readAttribute should be correct for info child attribute");
});

test("Basic Read", function() {
  var id;
  // Test general gets
  equals(testParent.get('name'), 'Parent Name', "get should be correct for name attribute");
  equals(testParent.get('nothing'), null, "get should be correct for invalid key");

  // Test Child Record creation
  var cr = testParent.get('info');
  // Check Model Class information
  ok(SC.kindOf(cr, SC.Record), "get() creates an actual instance that is a kind of a SC.Record Object");
  ok(SC.instanceOf(cr, NestedRecord.ChildRecordTest), "get() creates an actual instance of a ChildRecordTest Object");

  // Check reference information
  var pm = cr.get('primaryKey');
  var key = cr.get(pm);
  var storeRef = store.find(NestedRecord.ChildRecordTest, key);
  ok(storeRef, 'checking that the store has the instance of the child record with proper primary key');
  equals(cr, storeRef, "checking the parent reference is the same as the direct store reference");

  // Check to see if the attributes of a Child Record match the reference of the parent
  same(storeRef.get('attributes'), testParent.readAttribute('info'), "check that the ChildRecord's attributes are the same as the ParentRecord's readAttribute for the reference");

  // Duplication check
  var sameCR = testParent.get('info');
  ok(sameCR, "check to see if we have an instance of a child record again");
  var oldKey = cr.get(pm), newKey = sameCR.get(pm);
  equals(oldKey, newKey, "check to see if the Primary Key are the same");
  same(sameCR, cr, "check to see that it is the same child record as before");
});

test("Basic Read when Child Record has no primary key", function() {
  var id;
  // Test general gets
  equals(testParent3.get('name'), 'Parent Name 3', "get should be correct for name attribute");
  equals(testParent3.get('nothing'), null, "get should be correct for invalid key");

  // Test Child Record creation
  var cr = testParent3.get('info');
  // Check Model Class information
  ok(SC.kindOf(cr, SC.Record), "get() creates an actual instance that is a kind of a SC.Record Object");
  ok(SC.instanceOf(cr, NestedRecord.ChildRecordTest), "get() creates an actual instance of a ChildRecordTest Object");

  // Check reference information
  var key = cr.get('id');
  var storeRef = store.find(NestedRecord.ChildRecordTest, key);
  ok(storeRef, 'checking that the store has the instance of the child record with proper primary key');
  equals(cr, storeRef, "checking the parent reference is the same as the direct store reference");

  // Check to see if the attributes of a Child Record match the reference of the parent
  same(storeRef.get('attributes'), testParent3.readAttribute('info'), "check that the ChildRecord's attributes are the same as the ParentRecord's readAttribute for the reference");

  // Duplication check
  var sameCR = testParent3.get('info');
  ok(sameCR, "check to see if we have an instance of a child record again");
  var oldKey = cr.get('id'), newKey = sameCR.get('id');
  equals(oldKey, newKey, "check to see if the Primary Key are the same");
  same(sameCR, cr, "check to see that it is the same child record as before");
});

test("Basic Write As a Hash", function() {

  // Test general gets
  testParent.set('name', 'New Parent Name');
  equals(testParent.get('name'), 'New Parent Name', "set() should change name attribute");
  testParent.set('nothing', 'nothing');
  equals(testParent.get('nothing'), 'nothing', "set should change non-existent property to a new property");

  // Test Child Record creation
  var oldCR = testParent.get('info');
  testParent.set('info', {
    type: 'ChildRecordTest',
    name: 'New Child Name',
    value: 'Red Goo',
    guid: '6001'
  });
  var cr = testParent.get('info');
  // Check Model Class information
  ok(SC.kindOf(cr, SC.Record), "set() with an object creates an actual instance that is a kind of a SC.Record Object");
  ok(SC.instanceOf(cr, NestedRecord.ChildRecordTest), "set() with an object creates an actual instance of a ChildRecordTest Object");

  // Check reference information
  var pm = cr.get('primaryKey');
  var key = cr.get(pm);
  var storeRef = store.find(NestedRecord.ChildRecordTest, key);
  ok(storeRef, 'after a set() with an object, checking that the store has the instance of the child record with proper primary key');
  equals(cr, storeRef, "after a set with an object, checking the parent reference is the same as the direct store reference");
  var oldKey = oldCR.get(pm);
  ok(!(oldKey === key), 'check to see that the old child record has a different key from the new child record');

  // Check for changes on the child bubble to the parent.
  cr.set('name', 'Child Name Change');
  equals(cr.get('name'), 'Child Name Change', "after a set('name', <new>) on child, checking that the value is updated");
  ok(cr.get('status') & SC.Record.DIRTY, 'check that the child record is dirty');
  ok(testParent.get('status') & SC.Record.DIRTY, 'check that the parent record is dirty');
  var newCR = testParent.get('info');
  same(newCR, cr, "after a set('name', <new>) on child, checking to see that the parent has received the changes from the child record");
  same(testParent.readAttribute('info'), cr.get('attributes'), "after a set('name', <new>) on child, readAttribute on the parent should be correct for info child attributes");
});

test("Basic Write As a Hash when Child Record has no primary key", function() {

  // Test general gets
  testParent3.set('name', 'New Parent Name');
  equals(testParent3.get('name'), 'New Parent Name', "set() should change name attribute");
  testParent3.set('nothing', 'nothing');
  equals(testParent3.get('nothing'), 'nothing', "set should change non-existent property to a new property");

  // Test Child Record creation
  var oldCR = testParent3.get('info');
  testParent3.set('info', {
    type: 'ChildRecordTest',
    name: 'New Child Name',
    value: 'Red Goo'
  });
  var cr = testParent3.get('info');
  // Check Model Class information
  ok(SC.kindOf(cr, SC.Record), "set() with an object creates an actual instance that is a kind of a SC.Record Object");
  ok(SC.instanceOf(cr, NestedRecord.ChildRecordTest), "set() with an object creates an actual instance of a ChildRecordTest Object");

  // Check reference information
  var key = cr.get('id');
  var storeRef = store.find(NestedRecord.ChildRecordTest, key);
  ok(storeRef, 'after a set() with an object, checking that the store has the instance of the child record with proper primary key');
  equals(cr, storeRef, "after a set with an object, checking the parent reference is the same as the direct store reference");
  var oldKey = oldCR.get('id');
  ok((oldKey === key), 'check to see that the old child record has the same key as the new child record');

  // Check for changes on the child bubble to the parent.
  cr.set('name', 'Child Name Change');
  equals(cr.get('name'), 'Child Name Change', "after a set('name', <new>) on child, checking that the value is updated");
  ok(cr.get('status') & SC.Record.DIRTY, 'check that the child record is dirty');
  ok(testParent3.get('status') & SC.Record.DIRTY, 'check that the parent record is dirty');
  var newCR = testParent3.get('info');
  same(newCR, cr, "after a set('name', <new>) on child, checking to see that the parent has received the changes from the child record");
  same(testParent3.readAttribute('info'), cr.get('attributes'), "after a set('name', <new>) on child, readAttribute on the parent should be correct for info child attributes");
});

test("Basic Write As a Child Record", function() {

  // Test general gets
  testParent.set('name', 'New Parent Name');
  equals(testParent.get('name'), 'New Parent Name', "set() should change name attribute");
  testParent.set('nothing', 'nothing');
  equals(testParent.get('nothing'), 'nothing', "set should change non-existent property to a new property");

  // Test Child Record creation
  var store = testParent.get('store');
  var cr = store.createRecord(NestedRecord.ChildRecordTest, {type: 'ChildRecordTest', name: 'New Child Name', value: 'Red Goo', guid: '6001'});
  // Check Model Class information
  ok(SC.kindOf(cr, SC.Record), "before the set(), check for actual instance that is a kind of a SC.Record Object");
  ok(SC.instanceOf(cr, NestedRecord.ChildRecordTest), "before the set(), check for actual instance of a ChildRecordTest Object");
  testParent.set('info', cr);
  cr = testParent.get('info');
  // Check Model Class information
  ok(SC.kindOf(cr, SC.Record), "set() with an object creates an actual instance that is a kind of a SC.Record Object");
  ok(SC.instanceOf(cr, NestedRecord.ChildRecordTest), "set() with an object creates an actual instance of a ChildRecordTest Object");

  // Check reference information
  var pm = cr.get('primaryKey');
  var key = cr.get(pm);
  var storeRef = store.find(NestedRecord.ChildRecordTest, key);
  ok(storeRef, 'after a set() with an object, checking that the store has the instance of the child record with proper primary key');
  equals(cr, storeRef, "after a set with an object, checking the parent reference is the same as the direct store reference");

  // Check for changes on the child bubble to the parent.
  cr.set('name', 'Child Name Change');
  equals(cr.get('name'), 'Child Name Change', "after a set('name', <new>) on child, checking that the value is updated");
  ok(cr.get('status') & SC.Record.DIRTY, 'check that the child record is dirty');
  ok(testParent.get('status') & SC.Record.DIRTY, 'check that the parent record is dirty');
  var newCR = testParent.get('info');
  same(newCR, cr, "after a set('name', <new>) on child, checking to see that the parent has received the changes from the child record");
  same(testParent.readAttribute('info'), cr.get('attributes'), "after a set('name', <new>) on child, readAttribute on the parent should be correct for info child attributes");

  // Make sure you can set the child to null.
  testParent.set('info', null);
  equals(testParent.get('info'), null, 'should be able to set child record to null');
});

test("Basic Write As a Child Record when Child Record has no primary key", function() {

  // Test general gets
  testParent3.set('name', 'New Parent Name');
  equals(testParent3.get('name'), 'New Parent Name', "set() should change name attribute");
  testParent3.set('nothing', 'nothing');
  equals(testParent3.get('nothing'), 'nothing', "set should change non-existent property to a new property");

  // Test Child Record creation
  var store = testParent3.get('store');
  var cr = store.createRecord(NestedRecord.ChildRecordTest, {type: 'ChildRecordTest', name: 'New Child Name', value: 'Red Goo', guid: '6001'});
  // Check Model Class information
  ok(SC.kindOf(cr, SC.Record), "before the set(), check for actual instance that is a kind of a SC.Record Object");
  ok(SC.instanceOf(cr, NestedRecord.ChildRecordTest), "before the set(), check for actual instance of a ChildRecordTest Object");
  testParent3.set('info', cr);
  cr = testParent3.get('info');
  // Check Model Class information
  ok(SC.kindOf(cr, SC.Record), "set() with an object creates an actual instance that is a kind of a SC.Record Object");
  ok(SC.instanceOf(cr, NestedRecord.ChildRecordTest), "set() with an object creates an actual instance of a ChildRecordTest Object");

  // Check reference information
  var key = cr.get('id');
  var storeRef = store.find(NestedRecord.ChildRecordTest, key);
  ok(storeRef, 'after a set() with an object, checking that the store has the instance of the child record with proper primary key');
  equals(cr, storeRef, "after a set with an object, checking the parent reference is the same as the direct store reference");

  // Check for changes on the child bubble to the parent.
  cr.set('name', 'Child Name Change');
  equals(cr.get('name'), 'Child Name Change', "after a set('name', <new>) on child, checking that the value is updated");
  ok(cr.get('status') & SC.Record.DIRTY, 'check that the child record is dirty');
  ok(testParent3.get('status') & SC.Record.DIRTY, 'check that the parent record is dirty');
  var newCR = testParent3.get('info');
  same(newCR, cr, "after a set('name', <new>) on child, checking to see that the parent has received the changes from the child record");
  same(testParent3.readAttribute('info'), cr.get('attributes'), "after a set('name', <new>) on child, readAttribute on the parent should be correct for info child attributes");

  // Make sure you can set the child to null.
  testParent3.set('info', null);
  equals(testParent3.get('info'), null, 'should be able to set child record to null');
});

test("Writing over a child record should remove caches in the store.", function() {
  // Test Child Record creation
  var cr, key, store = testParent.get('store'), cacheLength;

  // Get the child record once before setting it in order to test that this child
  // doesn't become abandoned in the store.
  cr = testParent.get('info');

  // Once we get the child record, certain caches are created in the store.
  // Verify the cache lengths to prove that there are no leaked objects.
  cacheLength = 0;
  for (key in store.parentRecords) { cacheLength += 1; }
  equals(cacheLength, 1, 'there should only be one parent record registered in the store');

  cacheLength = 0;
  for (key in store.childRecords) { cacheLength += 1; }
  equals(cacheLength, 1, 'there should only be one child record registered in the store');

  cacheLength = 0;
  for (key in store.records) { cacheLength += 1; }
  equals(cacheLength, 4, 'there should be four records cached in the store');

  cacheLength = 0;
  for (key in store.dataHashes) { if (store.dataHashes[key] !== null) cacheLength += 1; }
  equals(cacheLength, 4, 'there should be four non-null datahashes in the store');

  // Overwrite the child record with a new child record with the same guid.
  testParent.set('info', {type: 'ChildRecordTest', name: 'New Child Name', value: 'Red Goo', guid: '5001'});
  cr = testParent.get('info');

  // Verify the cache lengths to prove that there are no leaked objects.
  cacheLength = 0;
  for (key in store.parentRecords) { cacheLength += 1; }
  equals(cacheLength, 1, 'there should only be one parent record registered in the store after replacing child record once');

  cacheLength = 0;
  for (key in store.childRecords) { cacheLength += 1; }
  equals(cacheLength, 1, 'there should only be one child record registered in the store after replacing child record once');

  cacheLength = 0;
  for (key in store.records) { cacheLength += 1; }
  equals(cacheLength, 4, 'there should be four records cached in the store after replacing child record once');

  cacheLength = 0;
  for (key in store.dataHashes) { if (store.dataHashes[key] !== null) cacheLength += 1; }
  equals(cacheLength, 4, 'there should be four non-null datahashes in the store after replacing child record once');

  // Overwrite the child record with a new child record with the same guid.
  testParent.set('info', store.createRecord(NestedRecord.ChildRecordTest, {type: 'ChildRecordTest', name: 'New Child Name', value: 'Orange Goo', guid: '6001'}));
  cr = testParent.get('info');

  // Verify the cache lengths to prove that there are no leaked objects.
  cacheLength = 0;
  for (key in store.parentRecords) { cacheLength += 1; }
  equals(cacheLength, 1, 'there should only be one parent record registered in the store after replacing child record twice');

  cacheLength = 0;
  for (key in store.childRecords) { cacheLength += 1; }
  equals(cacheLength, 1, 'there should only be one child record registered in the store after replacing child record twice');

  cacheLength = 0;
  for (key in store.records) { cacheLength += 1; }
  equals(cacheLength, 4, 'there should be four records cached in the store after replacing child record twice');

  cacheLength = 0;
  for (key in store.dataHashes) { if (store.dataHashes[key] !== null) cacheLength += 1; }
  equals(cacheLength, 4, 'there should be four non-null datahashes in the store after replacing child record twice');

  // Make sure you can set the child to null.
  testParent.set('info', null);
  cr = testParent.get('info');

  // Verify the cache lengths to prove that there are no leaked objects.
  cacheLength = 0;
  for (key in store.parentRecords) { cacheLength += 1; }
  equals(cacheLength, 1, 'there should only be one parent record registered in the store after removing child record');

  cacheLength = 0;
  for (key in store.childRecords) { cacheLength += 1; }
  equals(cacheLength, 0, 'there should be no child record registered in the store after removing child record');

  cacheLength = 0;
  for (key in store.records) { cacheLength += 1; }
  equals(cacheLength, 3, 'there should be three records cached in the store after removing child record');

  cacheLength = 0;
  for (key in store.dataHashes) { if (store.dataHashes[key] !== null) cacheLength += 1; }
  equals(cacheLength, 3, 'there should be three non-null datahashes in the store after removing child record');
});

test("Child Status Changed", function() {
  var cr;
  cr = testParent.get('info');
  equals(cr.get('status'), testParent.get('status'), 'after initializing the parent to READY_NEW, check that the child record matches');

  SC.RunLoop.begin();
  store.writeStatus(testParent.storeKey, SC.Record.READY_DIRTY);
  store.dataHashDidChange(testParent.storeKey);
  equals(cr.get('status'), testParent.get('status'), 'after setting the parent to READY_DIRTY, check that the child record matches');
  SC.RunLoop.end();

  SC.RunLoop.begin();
  store.writeStatus(testParent.storeKey, SC.Record.BUSY_REFRESH);
  store.dataHashDidChange(testParent.storeKey);
  equals(cr.get('status'), testParent.get('status'), 'after setting the parent to BUSY_REFRESH, check that the child record matches');
  SC.RunLoop.end();
});

test("Child Status Matches Store Status", function() {
  var cr;
  var storeStatus;
  cr = testParent.get('info');

  storeStatus = store.readStatus(cr.storeKey);
  equals(storeStatus, cr.get('status'), 'after initializing the parent to READY_NEW, check that the store status matches for the child');
  equals(cr.get('status'), testParent.get('status'), 'after initializing the parent to READY_NEW, check that the child record matches');

  SC.RunLoop.begin();
  store.writeStatus(testParent.storeKey, SC.Record.READY_CLEAN);
  store.dataHashDidChange(testParent.storeKey);
  SC.RunLoop.end();

  storeStatus = store.readStatus(cr.storeKey);
  equals(testParent.get('status'), SC.Record.READY_CLEAN, 'parent status should be READY_CLEAN');
  equals(storeStatus, cr.get('status'), 'after setting the parent to READY_CLEAN, the child\'s status and store status should be READY_CLEAN before calling get(\'status\') on the child');
  equals(cr.get('status'), testParent.get('status'), 'after setting the parent to READY_CLEAN, check that the child record matches');

  SC.RunLoop.begin();
  store.writeStatus(testParent.storeKey, SC.Record.READY_DIRTY);
  store.dataHashDidChange(testParent.storeKey);
  SC.RunLoop.end();

  storeStatus = store.readStatus(cr.storeKey);
  equals(testParent.get('status'), SC.Record.READY_DIRTY, 'parent status should be READY_DIRTY');
  equals(storeStatus, cr.get('status'), 'after setting the parent to READY_DIRTY, the child\'s status and store status should be READY_DIRTY before calling get(\'status\') on the child');
  equals(cr.get('status'), testParent.get('status'), 'after setting the parent to READY_DIRTY, check that the child record matches');

  SC.RunLoop.begin();
  store.writeStatus(testParent.storeKey, SC.Record.BUSY_REFRESH);
  store.dataHashDidChange(testParent.storeKey);
  storeStatus = store.readStatus(cr.storeKey);
  SC.RunLoop.end();

  equals(testParent.get('status'), SC.Record.BUSY_REFRESH, 'parent status should be BUSY_REFRESH');
  equals(storeStatus, cr.get('status'), 'after setting the parent to BUSY_REFRESH, the child\'s status and store status should be BUSY_REFRESH before calling get(\'status\') on the child');
  equals(cr.get('status'), testParent.get('status'), 'after setting the parent to BUSY_REFRESH, check that the child record matches');
});

/**
  This test illustrates that unloading the parent record also unloads the child
  record.
*/
test("Unloading the parent record also unloads the child record.", function() {
  var parentId, child, childId, parentStoreKey, childStoreKey;

  parentId = testParent3.get('id');
  parentStoreKey = testParent3.get('storeKey');
  child = testParent3.get('info');
  childId = child.get('id');
  childStoreKey = child.get('storeKey');

  store.unloadRecord(NestedRecord.ParentRecordTest, parentId);

  equals(testParent3.get('status'), SC.Record.EMPTY, 'parent status should be EMPTY');
  equals(child.get('status'), SC.Record.EMPTY, 'child status should be EMPTY');
});

/**
  This test illustrates that reloading the parent record doesn't create
  duplicates of the child record.
*/
test("Reloading the parent record uses same child record.", function() {
  var parentId, child, childId, parentStoreKey, childStoreKey, newChildStoreKey;
  var key, cacheLength;

  parentId = testParent3.get('id');
  parentStoreKey = testParent3.get('storeKey');
  child = testParent3.get('info');
  childId = child.get('id');
  childStoreKey = child.get('storeKey');

  // Once we get the child record, certain caches are created in the store.
  // Verify the cache lengths to prove that there are no leaked objects.
  cacheLength = 0;
  for (key in store.parentRecords) { cacheLength += 1; }
  equals(cacheLength, 1, 'there should only be one parent record registered in the store');

  cacheLength = 0;
  for (key in store.childRecords) { cacheLength += 1; }
  equals(cacheLength, 1, 'there should only be one child record registered in the store');

  cacheLength = 0;
  for (key in store.records) { cacheLength += 1; }
  equals(cacheLength, 4, 'there should be four records cached in the store');

  cacheLength = 0;
  for (key in store.dataHashes) { if (store.dataHashes[key] !== null) cacheLength += 1; }
  equals(cacheLength, 4, 'there should be four non-null datahashes in the store');

  // Unload the record
  store.unloadRecord(NestedRecord.ParentRecordTest, parentId);

  equals(testParent3.get('status'), SC.Record.EMPTY, 'parent status should be EMPTY');
  equals(child.get('status'), SC.Record.EMPTY, 'child status should be EMPTY');

  // Verify the cache lengths to prove that there are no leaked objects.
  cacheLength = 0;
  for (key in store.parentRecords) { cacheLength += 1; }
  equals(cacheLength, 1, 'there should only be one parent record registered in the store');

  cacheLength = 0;
  for (key in store.childRecords) { cacheLength += 1; }
  equals(cacheLength, 1, 'there should only be one child record registered in the store');

  cacheLength = 0;
  for (key in store.records) { cacheLength += 1; }
  equals(cacheLength, 4, 'there should be four records cached in the store');

  cacheLength = 0;
  for (key in store.dataHashes) { if (store.dataHashes[key] !== null) cacheLength += 1; }
  equals(cacheLength, 2, 'there should be two non-null datahashes in the store');

  // Reload the record
  SC.RunLoop.begin();
  store.loadRecord(NestedRecord.ParentRecordTest, {
      name: 'Parent Name 3',
      info: {
        type: 'ChildRecordTest',
        name: 'Child Name 3',
        value: 'Pink Goo'
      }
    },
    parentId);
  SC.RunLoop.end();

  child = testParent3.get('info');
  equals(testParent3.get('status'), SC.Record.READY_CLEAN, 'parent status should be READY_CLEAN');
  equals(child.get('status'), SC.Record.READY_CLEAN, 'child status should be READY_CLEAN');

  // Verify the cache lengths to prove that there are no leaked objects.
  cacheLength = 0;
  for (key in store.parentRecords) { cacheLength += 1; }
  equals(cacheLength, 1, 'there should only be one parent record registered in the store');

  cacheLength = 0;
  for (key in store.childRecords) { cacheLength += 1; }
  equals(cacheLength, 1, 'there should only be one child record registered in the store');

  cacheLength = 0;
  for (key in store.records) { cacheLength += 1; }
  equals(cacheLength, 4, 'there should be four records cached in the store');

  cacheLength = 0;
  for (key in store.dataHashes) { if (store.dataHashes[key] !== null) cacheLength += 1; }
  equals(cacheLength, 4, 'there should be four non-null datahashes in the store');
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/models/nested_records/nested_record_array.js"; 
}
(function() {
/**
 * Nested Record Array of SC.Records Unit Test
 *
 * @author Evin Grano
 */

// ..........................................................
// Basic Set up needs to move to the setup and teardown
//
var NestedRecord, store, testParent, testParent2;

var initModels = function(){

  NestedRecord.ChildRecordTest1 = SC.Record.extend({
    name: SC.Record.attr(String),
    value: SC.Record.attr(String)
  });

  NestedRecord.ChildRecordTest2 = SC.Record.extend({
     name: SC.Record.attr(String),
     info: SC.Record.attr(String),
     value: SC.Record.attr(String)
   });

  NestedRecord.ParentRecordTest = SC.Record.extend({
    /** Child Record Namespace */
    nestedRecordNamespace: NestedRecord,

    name: SC.Record.attr(String),
    elements: SC.Record.toMany('SC.Record', { nested: true }),

    defaultElements: SC.Record.toMany(NestedRecord.ChildRecordTest1, {
      isNested: true,
      defaultValue: function(record, key) {
        var array = [];
        array.pushObject({});
        return array;
      }
    }),

    defaultPolymorphicElements: SC.Record.toMany('SC.Record', {
      isNested: true,
      defaultValue: function(record, key) {
        var array = [];
        array.pushObject({
          type: 'ChildRecordTest1',
          name: 'Default Child 1',
          value: 'burninate'
        });
        return array;
      }
    })
  });
};


// ..........................................................
// Basic SC.Record with an Array of Children
//
module("Basic SC.Record w/ a Parent > Array of Children", {

  setup: function() {
    NestedRecord = SC.Object.create({
      store: SC.Store.create()
    });
    store = NestedRecord.store;
    initModels();
    SC.RunLoop.begin();
    testParent = store.createRecord(NestedRecord.ParentRecordTest, {
      name: 'Parent Name',
      elements: [
        {
          type: 'ChildRecordTest1',
          name: 'Child 1',
          value: 'eeney'
        },
        {
          type: 'ChildRecordTest2',
          name: 'Child 2',
          info: 'This is the other type',
          value: 'meeney'
        },
        {
          type: 'ChildRecordTest1',
          name: 'Child 3',
          value: 'miney'
        },
        {
          type: 'ChildRecordTest1',
          name: 'Child 4',
          value: 'moe'
        }
      ]
    });

    // FIXME: [EG] this configuration should work
    testParent2 = store.createRecord(NestedRecord.ParentRecordTest, {
      name: 'Parent 2',
      elements: []
    });
    SC.RunLoop.end();
  },

  teardown: function() {
    delete NestedRecord.ParentRecordTest;
    delete NestedRecord.ChildRecordTest;
    testParent = null;
    testParent2 = null;
    store = null;
    NestedRecord = null;
  }
});

test("Function: readAttribute()", function() {
  var elemsAry = testParent.readAttribute('elements');
  ok(elemsAry, "check to see that the child records array exists");
  equals(elemsAry.get('length'), 4, "checking to see that the length of the elements array is 4");
  same(elemsAry[0],
    {
      type: 'ChildRecordTest1',
      name: 'Child 1',
      value: 'eeney'
    },
    "check to see if the first child is as expected");
  same(elemsAry[3],
    {
      type: 'ChildRecordTest1',
      name: 'Child 4',
      value: 'moe'
    },
    "check to see if the last child is as expected");
});

test("Function: writeAttribute()", function() {

  testParent.writeAttribute('elements',
    [
      {
        type: 'ChildRecordTest1',
        name: 'Tom',
        value: 'Jones'
      },
      {
        type: 'ChildRecordTest1',
        name: 'Dick',
        value: 'Smothers'
      },
      {
        type: 'ChildRecordTest1',
        name: 'Harry',
        value: 'Balls'
      }
    ]
  );
  var elemsAry = testParent.readAttribute('elements');
  ok(elemsAry, "after writeAttribute(), check to see that the child records array exists");
  equals(elemsAry.length, 3, "after writeAttribute(), checking to see that the length of the elements array is 3");
  same(elemsAry[0],
    {
      type: 'ChildRecordTest1',
      name: 'Tom',
      value: 'Jones'
    },
    "check to see if the first child is as expected");
  same(elemsAry[2],
    {
      type: 'ChildRecordTest1',
      name: 'Harry',
      value: 'Balls'
    },
    "check to see if the last child is as expected");
});

test("Basic Read", function() {

  // Test general gets
  equals(testParent.get('name'), 'Parent Name', "get should be correct for name attribute");
  equals(testParent.get('nothing'), null, "get should be correct for invalid key");

  // Test Child Record creation
  var arrayOfCRs = testParent.get('elements');
  // Check Model Class information

  ok(SC.instanceOf(arrayOfCRs, SC.ChildArray), "check that get() creates an actual instance of a SC.ChildArray");
  equals(arrayOfCRs.get('length'), 4, "check that the length of the array of child records is 4");
  var cr = arrayOfCRs.objectAt(0);
  ok(SC.kindOf(cr, SC.Record), "check that first ChildRecord from the get() creates an actual instance that is a kind of a SC.Record Object");
  ok(SC.instanceOf(cr, NestedRecord.ChildRecordTest1), "check that first ChildRecord from the get() creates an actual instance of a ChildRecordTest1 Object");

  // Test Default Child Record creation
  var arrayOfDRs = testParent.get('defaultElements');
  ok(SC.instanceOf(arrayOfDRs, SC.ChildArray), "check that get() creates an actual instance of a SC.ChildArray");
  equals(arrayOfDRs.get('length'), 1, "check that the length of the array of default records is 1");
  var dr = arrayOfDRs.objectAt(0);
  ok(SC.kindOf(dr, SC.Record), "check that first default ChildRecord from the get() creates an actual instance that is a kind of a SC.Record Object");
  ok(SC.instanceOf(dr, NestedRecord.ChildRecordTest1), "check that first default ChildRecord from the get() creates an actual instance of a ChildRecordTest1 Object");

  // Test Default Polymorphic Child Record creation
  var arrayOfDPRs = testParent.get('defaultPolymorphicElements');
  ok(SC.instanceOf(arrayOfDPRs, SC.ChildArray), "check that get() creates an actual instance of a SC.ChildArray");
  equals(arrayOfDPRs.get('length'), 1, "check that the length of the array of default records is 1");
  var dpr = arrayOfDPRs.objectAt(0);
  ok(SC.kindOf(dpr, SC.Record), "check that first default polymorphic ChildRecord from the get() creates an actual instance that is a kind of a SC.Record Object");
  ok(SC.instanceOf(dpr, NestedRecord.ChildRecordTest1), "check that first default polymorphic ChildRecord from the get() creates an actual instance of a ChildRecordTest1 Object");

  // Check reference information
  var key = cr.get('id');
  var storeRef = store.find(NestedRecord.ChildRecordTest1, key);
  ok(storeRef, 'check that first ChildRecord that the store has the instance of the child record with proper primary key');
  equals(cr, storeRef, "check the parent reference to the first child is the same as the direct store reference");

  // Check to see if the attributes of a Child Record match the reference of the parent
  var parentArray = testParent.readAttribute('elements');
  ok(!SC.instanceOf(parentArray, SC.ChildArray), "check that get() creates an actual instance of a SC.ChildArray");
  same(parentArray[0], storeRef.get('attributes'), "check that the ChildRecord's attributes are the same as the ParentRecord's readAttribute for the reference");

  // // Duplication check
  var sameArray = testParent.get('elements');
  ok(sameArray, 'check to see that we get an array on the second call to the parent for the child records');
  equals(sameArray.get('length'), 4, "check that the length of the array of child records is still 4");
  var sameCR = sameArray.objectAt(0);
  ok(sameCR, "check to see if we have an instance of a child record again");
  var oldKey = cr.get('id'), newKey = sameCR.get('id');
  equals(oldKey, newKey, "check to see if the primary key are the same");
  equals(SC.guidFor(cr), SC.guidFor(sameCR), "check to see if the guid are the same");
  same(sameCR, cr, "check to see that it is the same child record as before");
});

test("Basic Write", function() {

  // Test general gets
  testParent.set('name', 'New Parent Name');
  equals(testParent.get('name'), 'New Parent Name', "set() should change name attribute");
  testParent.set('nothing', 'nothing');
  equals(testParent.get('nothing'), 'nothing', "set should change non-existent property to a new property");

  // Test Child Record creation
  var oldCR = testParent.get('elements');
  var newChildren = [
   { type: 'ChildRecordTest1', name: 'Tom', value: 'Jones'},
   { type: 'ChildRecordTest1', name: 'Dick', value: 'Smothers'},
   { type: 'ChildRecordTest1', name: 'Harry', value: 'Balls'}
  ];

  testParent.set('elements', newChildren);
  var newArray = testParent.get('elements');
  ok(SC.instanceOf(newArray, SC.ChildArray), "check that get() creates an actual instance of a SC.ChildArray");
  equals(newArray.get('length'), 3, "after set() on parent, check that the length of the array of child records is 3");
  var cr = newArray.objectAt(0);

  ok(SC.kindOf(cr, SC.Record), "check that first ChildRecord from the get() creates an actual instance that is a kind of a SC.Record Object");
  ok(SC.instanceOf(cr, NestedRecord.ChildRecordTest1), "check that first ChildRecord from the get() creates an actual instance of a ChildRecordTest1 Object");
});

test("Basic Write: reference tests", function() {
   var elems, cr, key, storeRef, newElems;

   elems = testParent.get('elements');
   cr = elems.objectAt(0);
   // TODO: [EG] Add test to make sure the number of ChildRecords in store

   // Check reference information
   key = cr.get('id');
   storeRef = store.find(NestedRecord.ChildRecordTest1, key);
   ok(storeRef, 'after a set() with an object, checking that the store has the instance of the child record with proper primary keys');
   equals(cr, storeRef, "after a set with an object, checking the parent reference is the same as the direct store reference");

   // Check for changes on the child bubble to the parent.
   cr.set('name', 'Child Name Change');
   equals(cr.get('name'), 'Child Name Change', "after a set('name', <new>) on child, checking that the value is updated");
   ok(cr.get('status') & SC.Record.DIRTY, 'check that the child record is dirty');
   ok(testParent.get('status') & SC.Record.DIRTY, 'check that the parent record is dirty');
   newElems = testParent.get('elements');
   var newCR = newElems.objectAt(0);
   same(newCR, cr, "after a set('name', <new>) on child, checking to see that the parent has received the changes from the child record");
   var readAttrsArray = testParent.readAttribute('elements');
   ok(readAttrsArray, "checks to make sure the readAttibute works with a change to the name in the first child.");
   equals(readAttrsArray.length, 4, "after set() on parent, check that the length of the attribute array of child records is 4");
   same(readAttrsArray[0], newCR.get('attributes'), "after a set('name', <new>) on child, readAttribute on the parent should be correct for info child attributes");
});

test("Basic Array Functionality: pushObject w/ HASH", function() {
  var elements, elementsAttrs, cr, crFirst, crLast;
  // Add something to the array
  elements = testParent.get('elements');
  // PushObject Tests
  elements.pushObject({ type: 'ChildRecordTest1', name: 'Testikles', value: 'God Of Fertility'});
  elements = testParent.get('elements');
  equals(elements.get('length'), 5, "after pushObject() on parent, check that the length of the array of child records is 5");
  cr = elements.objectAt(4);
  ok(SC.kindOf(cr, SC.Record), "check that newly added ChildRecord creates an actual instance that is a kind of a SC.Record Object");
  ok(SC.instanceOf(cr, NestedRecord.ChildRecordTest1), "check that newly added ChildRecord creates an actual instance of a ChildRecordTest1 Object");
  equals(cr.get('name'), 'Testikles', "after a pushObject on parent, check to see if it has all the right values for the attributes");
  ok(cr.get('status') & SC.Record.DIRTY, 'check that the child record is dirty');
  ok(testParent.get('status') & SC.Record.DIRTY, 'check that the parent record is dirty');

  // Verify the Attrs
  elementsAttrs = testParent.readAttribute('elements');
  equals(elementsAttrs.length, 5, "after pushObject() on parent, check that the length of the attribute array of child records is 5");
  crFirst = elements.objectAt(0).get('attributes');
  crLast = elements.objectAt(4).get('attributes');
  same(elementsAttrs[0], crFirst, "verify that parent attributes are the same as the first individual child attributes");
  same(elementsAttrs[4], crLast, "verify that parent attributes are the same as the last individual child attributes");
});

test("Basic Array Functionality: pushObject w/ ChildRecord", function() {
  var elements, elementsAttrs, cr, crFirst, crLast;
  // Add something to the array
  elements = testParent.get('elements');
  // PushObject Tests
  cr = store.createRecord(NestedRecord.ChildRecordTest1, { type: 'ChildRecordTest1', name: 'Testikles', value: 'God Of Fertility'});
  elements.pushObject(cr);
  elements = testParent.get('elements');
  equals(elements.get('length'), 5, "after pushObject() on parent, check that the length of the array of child records is 5");
  cr = elements.objectAt(4);
  ok(SC.kindOf(cr, SC.Record), "check that newly added ChildRecord creates an actual instance that is a kind of a SC.Record Object");
  ok(SC.instanceOf(cr, NestedRecord.ChildRecordTest1), "check that newly added ChildRecord creates an actual instance of a ChildRecordTest1 Object");
  equals(cr.get('name'), 'Testikles', "after a pushObject on parent, check to see if it has all the right values for the attributes");
  ok(cr.get('status') & SC.Record.DIRTY, 'check that the child record is dirty');
  ok(testParent.get('status') & SC.Record.DIRTY, 'check that the parent record is dirty');

  // Verify the Attrs
  elementsAttrs = testParent.readAttribute('elements');
  equals(elementsAttrs.length, 5, "after pushObject() on parent, check that the length of the attribute array of child records is 5");
  crFirst = elements.objectAt(0).get('attributes');
  crLast = elements.objectAt(4).get('attributes');
  same(elementsAttrs[0], crFirst, "verify that parent attributes are the same as the first individual child attributes");
  same(elementsAttrs[4], crLast, "verify that parent attributes are the same as the last individual child attributes");
});


test("Basic Array Functionality: popObject", function() {
  var elements, elementsAttrs, cr, crFirst, crLast;
  // Add something to the array
  elements = testParent.get('elements');
  // PushObject Tests
  elements.popObject();
  elements = testParent.get('elements');
  equals(elements.get('length'), 3, "after popObject() on parent, check that the length of the array of child records is 3");
  ok(testParent.get('status') & SC.Record.DIRTY, 'check that the parent record is dirty');

  // Verify the Attrs
  elementsAttrs = testParent.readAttribute('elements');
  equals(elementsAttrs.length, 3, "after pushObject() on parent, check that the length of the attribute array of child records is 3");
  crFirst = elements.objectAt(0).get('attributes');
  crLast = elements.objectAt(2).get('attributes');
  same(elementsAttrs[0], crFirst, "verify that parent attributes are the same as the first individual child attributes");
  same(elementsAttrs[2], crLast, "verify that parent attributes are the same as the last individual child attributes");
});

test("Basic Array Functionality: shiftObject", function() {
  var elements, cr;
  // Add something to the array
  elements = testParent.get('elements');
  // PushObject Tests
  elements.shiftObject();
  elements = testParent.get('elements');
  equals(elements.get('length'), 3, "after shiftObject() on parent, check that the length of the array of child records is 3");
  ok(testParent.get('status') & SC.Record.DIRTY, 'check that the parent record is dirty');
});

test("Basic Array Functionality: unshiftObject", function() {
  var elements, elementsAttrs, cr, crFirst, crLast;
  // Add something to the array
  elements = testParent.get('elements');
  // PushObject Tests
  elements.unshiftObject({ type: 'ChildRecordTest1', name: 'Testikles', value: 'God Of Fertility'});
  elements = testParent.get('elements');
  equals(elements.get('length'), 5, "after pushObject() on parent, check that the length of the array of child records is 5");
  cr = elements.objectAt(0);
  ok(SC.kindOf(cr, SC.Record), "check that newly added ChildRecord creates an actual instance that is a kind of a SC.Record Object");
  ok(SC.instanceOf(cr, NestedRecord.ChildRecordTest1), "check that newly added ChildRecord creates an actual instance of a ChildRecordTest1 Object");
  equals(cr.get('name'), 'Testikles', "after a pushObject on parent, check to see if it has all the right values for the attributes");
  ok(cr.get('status') & SC.Record.DIRTY, 'check that the child record is dirty');
  ok(testParent.get('status') & SC.Record.DIRTY, 'check that the parent record is dirty');

  // Verify the Attrs
  elementsAttrs = testParent.readAttribute('elements');
  equals(elementsAttrs.length, 5, "after pushObject() on parent, check that the length of the attribute array of child records is 5");
  crFirst = elements.objectAt(0).get('attributes');
  crLast = elements.objectAt(4).get('attributes');
  same(elementsAttrs[0], crFirst, "verify that parent attributes are the same as the first individual child attributes");
  same(elementsAttrs[4], crLast, "verify that parent attributes are the same as the last individual child attributes");
});

test("Create Parent with Broken Child Array", function(){
  var elements = testParent2.get('elements');
  ok (!SC.none(elements), "elements should be something");
  var isChildRecordArrays = elements.instanceOf(SC.ChildArray);
  ok(isChildRecordArrays, 'elements array is of right type');

  var length = elements.get('length');
  equals(length, 0, 'length should be zero');

  elements.pushObject({type: 'ChildRecordTest1',name: 'Child 1',value: 'eeney'});
  length = elements.get('length');
  equals(length, 1, 'length should be one');

});

test("pushObject should trigger an arrayContentDidChange with only 1 added item", function() {
  var didChangeCalls = [], target;

  target = SC.Object.create({
    willChange: function() {},
    didChange: function() {
      didChangeCalls.push(arguments);
    }
  });

  testParent.get('elements').addArrayObservers({
    target: target,
    willChange: 'willChange',
    didChange: 'didChange'
  });
  testParent.get('elements').pushObject({});

  equals(didChangeCalls.length, 1, 'didChange should only be called once');
  equals(didChangeCalls[0][0], 4, 'didChange should be called with a start index of 4');
  equals(didChangeCalls[0][1], 0, 'didChange should be called with a removed count of 0');
  equals(didChangeCalls[0][2], 1, 'didChange should be called with an added count of 1');
});

test("replace should trigger an arrayContentDidChange with only 1 added item", function() {
  var didChangeCalls = [], target;

  target = SC.Object.create({
    willChange: function() {},
    didChange: function() {
      didChangeCalls.push(arguments);
    }
  });

  testParent.get('elements').addArrayObservers({
    target: target,
    willChange: 'willChange',
    didChange: 'didChange'
  });
  testParent.get('elements').replace(3, 1, [{}]);

  equals(didChangeCalls.length, 1, 'didChange should only be called once');
  equals(didChangeCalls[0][0], 3, 'didChange should be called with a start index of 3');
  equals(didChangeCalls[0][1], 1, 'didChange should be called with a removed count of 1');
  equals(didChangeCalls[0][2], 1, 'didChange should be called with an added count of 1');
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/models/nested_records/nested_record_array_complex.js"; 
}
(function() {
/**
 * Nested Record Array (SC.ChildRecord) Unit Test
 *
 * @author Evin Grano
 */

// ..........................................................
// Basic Set up needs to move to the setup and teardown
//
var NestedRecord, store, testParent, peopleData1, peopleData2, personData1, addressData1;

var initModels = function(){
  NestedRecord.Group = SC.Record.extend({
    /** Child Record Namespace */
    nestedRecordNamespace: NestedRecord,

    name: SC.Record.attr(String),
    people: SC.Record.toMany('NestedRecord.Person', { nested: true })
  });

  NestedRecord.Person = SC.Record.extend({
    /** Child Record Namespace */
    nestedRecordNamespace: NestedRecord,

    name: SC.Record.attr(String),
    addresses: SC.Record.toMany('NestedRecord.Address', { nested: true })
  });

  NestedRecord.Address = SC.Record.extend({
    street: SC.Record.attr(String),
    city: SC.Record.attr(String),
    state: SC.Record.attr(String, {defaultValue: "VA"})
  });
};

// ..........................................................
// Basic SC.ParentRecord with an Array of Children
//
module("Complex SC.Record: Parent > Array of Children > Array of Children", {

  setup: function() {
    NestedRecord = SC.Object.create({
      store: SC.Store.create()
    });
    window.NestedRecord = NestedRecord;
    store = NestedRecord.store;
    initModels();
    SC.RunLoop.begin();
    testParent = store.createRecord(NestedRecord.Group, {
      name: 'Test Group',
      people: [
        {
          type: 'Person',
          name: 'Barack Obama',
          addresses: [
            { type: 'Address', street: '123 Some Street', city: 'Chicago', state: 'IL'},
            { type: 'Address', street: '222 Socialist Way ', city: 'Washington', state: 'DC'}
          ]
        },
        {
          type: 'Person',
          name: 'John Doe',
          addresses: [
            { type: 'Address', street: '1111 Cross Street', city: 'Anywhere', state: 'CA'},
            { type: 'Address', street: '555 18th Street ', city: 'Boulder', state: 'CO'},
            { type: 'Address', street: '444 Goofy Street ', city: 'Redneck', state: 'AR'}
          ]
        },
        {
          type: 'Person',
          name: 'Jane Doe',
          addresses: [
            { type: 'Address', street: '987 Crispy Kreme Lane', city: 'Lard', state: 'TX'}
          ]
        }
      ]
    });
    SC.RunLoop.end();
    // Second Array for testings
    peopleData2 = [
      {
        type: 'Person',
        name: 'Tom Jones',
        addresses: [
          { type: 'Address', street: '1 Freezing Circle', city: 'Nome', state: 'AK'},
          { type: 'Address', street: '444 Not Unusual Love Place', city: 'Las Vegas', state: 'NV'},
          { type: 'Address', street: '66 On The Road', city: 'Touring', state: 'Anywhere'}
        ]
      },
      {
        type: 'Person',
        name: 'Dick Smothers',
        addresses: [
          { type: 'Address', street: '1 Mom Likes Best Place', city: 'Tujunga', state: 'CA'}
        ]
      }
    ];

    personData1 = {
      type: 'Person',
      name: 'Testikles, God Of Fertility',
      addresses: [
        { type: 'Address', street: '45 Gods and Goddess Place', city: 'Mount', state: 'Olympus'},
        { type: 'Address', street: '1 Special Circle', city: 'Your Mom', state: 'Your State'}
      ]
    };

    // Address Test Data
    addressData1 = [
      { type: 'Address', street: '1 Main Street', city: 'Greenbow', state: 'AL'},
      { type: 'Address', street: '666 Wall Street', city: 'New York', state: 'NY'},
      { type: 'Address', street: '4 Dirt Road', city: 'Pleasent', state: 'CO'},
      { type: 'Address', street: '1 Yellow Brick Road', city: 'Dorothy', state: 'KA'}
    ];
  },

  teardown: function() {
    delete NestedRecord.Group;
    delete NestedRecord.Person;
    delete NestedRecord.Address;
    //delete window.NestedRecord;
    NestedRecord = null;
    testParent = null;
    peopleData1 = null;
    peopleData2 = null;
    personData1 = null;
    addressData1 = null;
    store = null;
  }
});

test("Function: readAttribute()", function() {
  var ppl;
  ppl = testParent.readAttribute('people');
  ok(ppl, "check to see that the child records array exists");
  equals(ppl.length, 3, "checking to see that the length of the elements array is 3");

  // Check the first person
  equals(ppl[0].name, 'Barack Obama', "first person, check to see name is Barack Obama");
  equals(ppl[0].addresses.length, 2, "first person, check to see length of the addresses is 2");
  same(ppl[0].addresses[0], { type: 'Address', street: '123 Some Street', city: 'Chicago', state: 'IL'},
    "check to see if the first person's first address is as expected");
  same(ppl[0].addresses[1], { type: 'Address', street: '222 Socialist Way ', city: 'Washington', state: 'DC'},
    "check to see if the first person's last address is as expected");

  // Check Last person
  equals(ppl[2].name, 'Jane Doe', "last person, check to see name is Jane Doe");
  equals(ppl[2].addresses.length, 1, "last person, check to see length of the addresses is 2");
  same(ppl[2].addresses[0], { type: 'Address', street: '987 Crispy Kreme Lane', city: 'Lard', state: 'TX'},
    "check to see if the last person's first address is as expected");
});

test("Function: writeAttribute()", function() {
  var ppl;
  testParent.writeAttribute('people', peopleData2);
  ppl = testParent.readAttribute('people');
  ok(ppl, "after writeAttribute(), check to see that the child records array exists");
  equals(ppl.length, 2, "after writeAttribute(), checking to see that the length of the elements array is 2");

  // Check the first person
  equals(ppl[0].name, 'Tom Jones', "first person, check to see name is Tom Jones");
  equals(ppl[0].addresses.length, 3, "first person, check to see length of the addresses is 3");
  same(ppl[0].addresses[0], { type: 'Address', street: '1 Freezing Circle', city: 'Nome', state: 'AK'},
    "check to see if the first person's first address is as expected");
  same(ppl[0].addresses[2], { type: 'Address', street: '66 On The Road', city: 'Touring', state: 'Anywhere'},
    "check to see if the first person's last address is as expected");

  // Check Last person
  equals(ppl[1].name, 'Dick Smothers', "last person, check to see name is Dick Smothers");
  equals(ppl[1].addresses.length, 1, "last person, check to see length of the addresses is 2");
  same(ppl[1].addresses[0], { type: 'Address', street: '1 Mom Likes Best Place', city: 'Tujunga', state: 'CA'},
    "check to see if the last person's first address is as expected");

});

test("Basic Read, Testing the First Child Array", function() {
  var ppl, pplAttr, pplDup, p, pDup, pStore, key, oldKey;
  // Test general gets
  equals(testParent.get('name'), 'Test Group', "get should be correct for name attribute: Test Group");
  equals(testParent.get('nothing'), null, "get should be correct for invalid key");

  // Test Person (Child Record) creation
  ppl = testParent.get('people');
  // Check Model Class information

  ok(SC.instanceOf(ppl, SC.ChildArray), "check that get() creates an actual instance of a SC.ChildArray");
  equals(ppl.get('length'), 3, "check that the length of the array of child records is 3");
  p = ppl.objectAt(0);
  ok(SC.kindOf(p, SC.Record), "check that first ChildRecord from the get() creates an actual instance that is a kind of a SC.Record Object");
  ok(SC.instanceOf(p, NestedRecord.Person), "check that first ChildRecord from the get() creates an actual instance of a Person Object");

  // Check reference information
  key = p.get('id');
  pStore = store.find(NestedRecord.Person, key);
  ok(pStore, 'check that first ChildRecord that the store has the instance of the child record with proper primary key');
  equals(p, pStore, "check the parent reference to the first child is the same as the direct store reference");

  // Check to see if the attributes of a Child Record match the reference of the parent
  pplAttr = testParent.readAttribute('people');
  ok(!SC.instanceOf(pplAttr, SC.ChildArray), "check that readAttribute() does not create an actual instance of a SC.ChildArray");
  same(pplAttr[0], pStore.get('attributes'), "check that the ChildRecord's attributes are the same as the ParentRecord's readAttribute for the reference");

  // Duplication check
  pplDup = testParent.get('people');
  ok(pplDup, 'check to see that we get an array on the second call to the parent for the child records');
  equals(pplDup.get('length'), 3, "check that the length of the array of child records is still 3");
  pDup = pplDup.objectAt(0);
  ok(pDup, "check to see if we have an instance of a child record again");
  oldKey = p.get('id');
  key = pDup.get('id');
  equals(key, oldKey, "check to see if the primary keys are the same");
  equals(SC.guidFor(pDup), SC.guidFor(p), "check to see if the guid are the same");
  same(pDup, p, "check to see that it is the same child record as before");
});

test("Basic Read, Testing the Second Child Array", function() {
  var pDup, pStore;
  var ppl, pplAttr, p, addrs, addrsDup, addrsAttr, a, aDup, aStore, key, oldKey;

  // Test Addresses (Child Record) creation
  ppl = testParent.get('people');
  p = ppl.objectAt(0);
  addrs = p.get('addresses');
  // Check Model Class information

  ok(SC.instanceOf(addrs, SC.ChildArray), "check that get() creates an actual instance of a SC.ChildArray");
  equals(addrs.get('length'), 2, "check that the length of the array of child records is 2");
  a = addrs.objectAt(0);
  ok(SC.kindOf(a, SC.Record), "check that first ChildRecord from the get() creates an actual instance that is a kind of a SC.Record Object");
  ok(SC.instanceOf(a, NestedRecord.Address), "check that first ChildRecord from the get() creates an actual instance of a Address Object");

  // Check reference information
  key = a.get('id');
  aStore = store.find(NestedRecord.Address, key);
  ok(aStore, 'check that first ChildRecord that the store has the instance of the child record with proper primary key');
  equals(a, aStore, "check the parent reference to the first child is the same as the direct store reference");

  // Check to see if the attributes of a Child Record match the reference of the parent
  addrsAttr = p.readAttribute('addresses');
  ok(!SC.instanceOf(addrsAttr, SC.ChildArray), "check that readAttribute() does not create an actual instance of a SC.ChildArray");
  same(addrsAttr[0], aStore.get('attributes'), "check that the ChildRecord's attributes are the same as the ParentRecord's readAttribute for the reference");
  pplAttr = testParent.readAttribute('people');
  ok(!SC.instanceOf(pplAttr[0].addresses, SC.ChildArray), "check from the Group (parent Record) that readAttribute() does not create an actual instance of a SC.ChildArray");
  same(pplAttr[0].addresses[0], aStore.get('attributes'), "check from the Group (parent Record) that the ChildRecord's attributes are the same as the ParentRecord's readAttribute for the reference");

  // Duplication check
  addrsDup = p.get('addresses');
  ok(addrsDup, 'check to see that we get an array on the second call to the parent for the child records');
  equals(addrsDup.get('length'), 2, "check that the length of the array of child records is still 2");
  aDup = addrsDup.objectAt(0);
  ok(aDup, "check to see if we have an instance of a child record again");
  oldKey = a.get('id');
  key = aDup.get('id');
  equals(key, oldKey, "check to see if the primary key are the same");
  equals(SC.guidFor(aDup), SC.guidFor(a), "check to see if the guid are the same");
  same(aDup, a, "check to see that it is the same child record as before");
});

test("Basic Write: Testing the First Child Array", function() {
  var ppl, p, pAddrs, pAddrsAttr, pStore, key, oldKey, aFirst, aLast;
  // Test general gets
  testParent.set('name', 'New Group');
  equals(testParent.get('name'), 'New Group', "set() should change name attribute");
  testParent.set('nothing', 'nothing');
  equals(testParent.get('nothing'), 'nothing', "set should change non-existent property to a new property");

   testParent.set('people', peopleData2);
   ppl = testParent.get('people');
   ok(SC.instanceOf(ppl, SC.ChildArray), "check that get() creates an actual instance of a SC.ChildArray");
   equals(ppl.get('length'), 2, "after set() on parent, check that the length of the array of child records is 2");
   p = ppl.objectAt(0);
   ok(SC.kindOf(p, SC.Record), "check that first ChildRecord from the get() creates an actual instance that is a kind of a SC.Record Object");
   ok(SC.instanceOf(p, NestedRecord.Person), "check that first ChildRecord from the get() creates an actual instance of a Person Object");

   // TODO: [EG] Add test to make sure the number of ChildRecords in store is correct when we add store record clearing

   // Check reference information
   key = p.get('id');
   pStore = store.find(NestedRecord.Person, key);
   ok(pStore, 'after a set() with an object, checking that the store has the instance of the child record with proper primary key');
   equals(pStore, p, "after a set with an object, checking the parent reference is the same as the direct store reference");

   // Check for changes on the child bubble to the parent.
   p.set('addresses', addressData1);
   pAddrs = p.get('addresses');
   ok(SC.kindOf(pAddrs, SC.ChildArray), "check to see that the set('addresses') has returned a SC.ChildArray");
   equals(pAddrs.get('length'), 4, "check with a get() that the new address length is 4");
   pAddrsAttr = p.readAttribute('addresses');
   equals(pAddrsAttr.length, 4, "check with a readAttribute() that the new address length is 4");
   aFirst = pAddrs.objectAt(0);
   aLast = pAddrs.objectAt(3);
   same(pAddrsAttr[0], aFirst.get('attributes'), "check from the Person (parent Record) that the first Address's attributes are the same as the Person's readAttribute for the reference");
   same(pAddrsAttr[3], aLast.get('attributes'), "check from the Person (parent Record) that the last Address's attributes are the same as the Person's readAttribute for the reference");
   ok(p.get('status') & SC.Record.DIRTY, 'check that the person (child record) is dirty');
   ok(testParent.get('status') & SC.Record.DIRTY, 'check that the group (parent record) is dirty');
});

test("Basic Write: Testing the Second Child Array", function() {
  var ppl, pplAttr, p, addrsAttr, addrs, a;

  ppl = testParent.get('people');
  p = ppl.objectAt(0);
  addrs = p.get('addresses');
  a = addrs.objectAt('0');

  // New do the test on the address
  a.set('street', '123 New Street');
  ok(a.get('status') & SC.Record.DIRTY, 'check that the address (child record) is dirty');
  ok(p.get('status') & SC.Record.DIRTY, 'check that the person (child record) is dirty');
  ok(testParent.get('status') & SC.Record.DIRTY, 'check that the group (parent record) is dirty');

  // Check for changes on the child bubble to the parent.
  addrsAttr = p.readAttribute('addresses');
  equals(addrsAttr.length, 2, "check the length of the address attribute is still 2");
  equals(addrsAttr[0], a.get('attributes'), "check to see if the person's address attribute is the same as the address's attributes");

  // Check the group people stuff
  pplAttr = testParent.readAttribute('people');
  equals(pplAttr[0].addresses[0], a.get('attributes'), "check to see if the groups reference's address attribute is the same as the address's attributes");
});

test("Basic Array Functionality: pushObject", function() {
  var ppl, pplAttr, p, pFirst, pLast;
  // Add something to the array
  ppl = testParent.get('people');
  // PushObject Tests
  ppl.pushObject(personData1);
  ppl = testParent.get('people');
  equals(ppl.get('length'), 4, "after pushObject() on parent, check that the length of the array of child records is 4");
  p = ppl.objectAt(3);
  ok(SC.kindOf(p, SC.Record), "check that newly added ChildRecord creates an actual instance that is a kind of a SC.Record Object");
  ok(SC.instanceOf(p, NestedRecord.Person), "check that newly added ChildRecord creates an actual instance of a Person Object");
  equals(p.get('name'), 'Testikles, God Of Fertility', "after a pushObject on parent, check to see if it has all the right values for the attributes");
  ok(p.get('status') & SC.Record.DIRTY, 'check that the child record is dirty');
  ok(testParent.get('status') & SC.Record.DIRTY, 'check that the parent record is dirty');

  // Verify the Attrs
  pplAttr = testParent.readAttribute('people');
  equals(pplAttr.length, 4, "after pushObject() on parent, check that the length of the attribute array of child records is 4");
  pFirst = ppl.objectAt(0);
  pLast = ppl.objectAt(3);
  same(pplAttr[0], pFirst.get('attributes'), "verify that parent attributes are the same as the first individual child attributes");
  same(pplAttr[3], pLast.get('attributes'), "verify that parent attributes are the same as the last individual child attributes");
});

test("Advanced Array Functionality: pushObject", function() {
  var ppl, that = this;
  that.willChange = 0;
  that.didChange = 0;
  that.removedCount = 0;
  that.addedCount = 0;

  this.arrayContentWillChange = function(start, removedCount, addedCount) {
    that.willChange += 1;
  };
  this.arrayContentDidChange = function(start, removedCount, addedCount) {
    that.didChange += 1;
    that.removedCount += removedCount;
    that.addedCount += addedCount;
  };

  // Create thea rray and add observers
  ppl = testParent.get('people');
  ppl.addArrayObservers({
    target: this,
    willChange: this.arrayContentWillChange,
    didChange: this.arrayContentDidChange
  });

  // This should fire willChange and didChange once each
  ppl.pushObject(peopleData2[0]);
  equals(that.willChange, 1, "arrayContentWillChange should have been executed once");
  equals(that.didChange, 1, "arrayContentDidChange should have been executed once");
  equals(that.removedCount, 0, "Zero records were removed");
  equals(that.addedCount, 1, "1 Record was added");

  // Reset
  that.willChange = 0;
  that.didChange = 0;
  that.removedCount = 0;
  that.addedCount = 0;

  // This should fire willChange and didChange once each
  ppl.pushObject(peopleData2[1]);
  equals(that.willChange, 1, "arrayContentWillChange should have been executed once");
  equals(that.didChange, 1, "arrayContentDidChange should have been executed once");
  equals(that.removedCount, 0, "Zero records were removed");
  equals(that.addedCount, 1, "A second record was added");
});

test("Basic Array Functionality: popObject", function() {
  var ppl, pplAttr, p, pFirst, pLast;
  // Add something to the array
  ppl = testParent.get('people');
  // popObject Tests
  ppl.popObject();
  ppl = testParent.get('people');
  equals(ppl.get('length'), 2, "after popObject() on parent, check that the length of the array of child records is 2");
  p = ppl.objectAt(0);
  ok(SC.kindOf(p, SC.Record), "check that newly added ChildRecord creates an actual instance that is a kind of a SC.Record Object");
  ok(SC.instanceOf(p, NestedRecord.Person), "check that newly added ChildRecord creates an actual instance of a Person Object");
  equals(p.get('name'), 'Barack Obama', "after a pushObject on parent, check to see if it has all the right values for the attributes");
  ok(p.get('status') & SC.Record.DIRTY, 'check that the child record is dirty');
  ok(testParent.get('status') & SC.Record.DIRTY, 'check that the parent record is dirty');

  // Verify the Attrs
  pplAttr = testParent.readAttribute('people');
  equals(pplAttr.length, 2, "after pushObject() on parent, check that the length of the attribute array of child records is 2");
  pFirst = ppl.objectAt(0);
  pLast = ppl.objectAt(1);
  same(pplAttr[0], pFirst.get('attributes'), "verify that parent attributes are the same as the first individual child attributes");
  same(pplAttr[1], pLast.get('attributes'), "verify that parent attributes are the same as the last individual child attributes");
});

test("Basic Array Functionality: shiftObject", function() {
  var ppl, p;
  // Add something to the array
  ppl = testParent.get('people');
  // PushObject Tests
  ppl.shiftObject();
  ppl = testParent.get('people');
  equals(ppl.get('length'), 2, "after shiftObject() on parent, check that the length of the array of child records is 2");
  p = ppl.objectAt('0');
  equals(p.get('name'), 'John Doe', "after a shiftObject on parent, check to see if it has all the right values for the attributes");
  ok(testParent.get('status') & SC.Record.DIRTY, 'check that the parent record is dirty');
});

test("Basic Array Functionality: unshiftObject", function() {
  var ppl, pplAttr, p, pFirst, pLast;
  // Add something to the array
  ppl = testParent.get('people');
  // PushObject Tests
  ppl.unshiftObject(personData1);
  ppl = testParent.get('people');
  equals(ppl.get('length'), 4, "after unshiftObject() on parent, check that the length of the array of child records is 4");
  p = ppl.objectAt(0);
  ok(SC.kindOf(p, SC.Record), "check that newly added ChildRecord creates an actual instance that is a kind of a SC.Record Object");
  ok(SC.instanceOf(p, NestedRecord.Person), "check that newly added ChildRecord creates an actual instance of a Person Object");
  equals(p.get('name'), 'Testikles, God Of Fertility', "after a pushObject on parent, check to see if it has all the right values for the attributes");
  ok(p.get('status') & SC.Record.DIRTY, 'check that the child record is dirty');
  ok(testParent.get('status') & SC.Record.DIRTY, 'check that the parent record is dirty');

  // Verify the Attrs
  pplAttr = testParent.readAttribute('people');
  equals(pplAttr.length, 4, "after unshiftObject() on parent, check that the length of the attribute array of child records is 4");
  pFirst = ppl.objectAt(0);
  pLast = ppl.objectAt(3);
  same(pplAttr[0], pFirst.get('attributes'), "verify that parent attributes are the same as the first individual child attributes");
  same(pplAttr[3], pLast.get('attributes'), "verify that parent attributes are the same as the last individual child attributes");
});

test("Test: normalization on complex nested records", function() {
  var ppl, addresses, pAttrs;
  // Add something to the array
  ppl = testParent.get('people');
  addresses = ppl.objectAt(0).get('addresses');

  // PushObject Tests
  addresses.pushObject({ type: 'Address', street: '2 Main Street', city: 'Awesome'});
  testParent.normalize();
  pAttrs = testParent.get('attributes');
  equals(pAttrs.people[0].addresses[2].state, 'VA', "test normalization is the default value of VA");
});



})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/models/nested_records/nested_record_complex.js"; 
}
(function() {
/**
 * Complex Nested Records (SC.Record) Unit Test
 *
 * @author Evin Grano
 */

// ..........................................................
// Basic Set up needs to move to the setup and teardown
//
var NestedRecord, store, testParent;

var initModels = function(){
  NestedRecord.Address = SC.Record.extend({
    street: SC.Record.attr(String),
    city: SC.Record.attr(String),
    state: SC.Record.attr(String, {defaultValue: 'VA'})
  });

  NestedRecord.Person = SC.Record.extend({
    /** Child Record Namespace */
    nestedRecordNamespace: NestedRecord,

    name: SC.Record.attr(String),
    address: SC.Record.toOne('NestedRecord.Address', { nested: true })
  });

  NestedRecord.ParentRecordTest = SC.Record.extend({
    /** Child Record Namespace */
    nestedRecordNamespace: NestedRecord,

    name: SC.Record.attr(String),
    person: SC.Record.toOne('NestedRecord.Person', { nested: true })
  });
};

// ..........................................................
// Basic SC.Record Stuff
//
module("Basic SC.Record Functions w/ a Parent > Child > Child", {

  setup: function() {
    NestedRecord = SC.Object.create({
      store: SC.Store.create()
    });
    window.NestedRecord = NestedRecord;
    store = NestedRecord.store;
    initModels();
    SC.RunLoop.begin();
    testParent = store.createRecord(NestedRecord.ParentRecordTest, {
      name: 'Parent Name',
      person: {
        type: 'Person',
        name: 'Albert',
        address: {
          type: 'Address',
          street: '123 Sesame St',
          city: 'New York',
          state: 'NY'
        }
      }
    });
    SC.RunLoop.end();
  },

  teardown: function() {
    delete NestedRecord.ParentRecordTest;
    delete NestedRecord.Person;
    delete NestedRecord.Address;
    //delete window.NestedRecord;
    NestedRecord = null;
    testParent = null;
    store = null;
  }
});

test("Function: readAttribute() in the Parent Record",
function() {

  equals(testParent.readAttribute('name'), 'Parent Name', "readAttribute should be correct for name attribute");
  equals(testParent.readAttribute('nothing'), null, "readAttribute should be correct for invalid key");
  same(testParent.readAttribute('person'),
    {
      type: 'Person',
      name: 'Albert',
      address: {
        type: 'Address',
        street: '123 Sesame St',
        city: 'New York',
        state: 'NY'
      }
    },
    "readAttribute should be correct for 'person' child attribute");
});

test("Function: readAttribute() in the Parent > Child",
function() {
  var person = testParent.get('person');
  ok(person, "check to see if the first child in the chain exists");
  equals(person.readAttribute('name'), 'Albert', "child readAttribute should be correct for name attribute");
  equals(person.readAttribute('nothing'), null, "child readAttribute should be correct for invalid key");
  same(person.readAttribute('address'),
    {
      type: 'Address',
      street: '123 Sesame St',
      city: 'New York',
      state: 'NY'
    },
    "readAttribute should be correct for address on the child");
});

test("Function: readAttribute() in the Parent > Child > Child",
function() {
  var address = testParent.getPath('person.address');
  ok(address, "check to see if the child of the child in the chain exists with a getPath()");
  equals(address.readAttribute('street'), '123 Sesame St', "child readAttribute should be correct for street attribute w/ getPath()");
  equals(address.readAttribute('nothing'), null, "child readAttribute should be correct for invalid key w/ getPath()");

  // Test the individual gets
  var person = testParent.get('person');
  var address2 = person.get('address');
  ok(address2, "check to see if the child of the child in the chain exists with a get");
  equals(address2.readAttribute('street'), '123 Sesame St', "child readAttribute should be correct for street attribute w/ get()");
  equals(address2.readAttribute('nothing'), null, "child readAttribute should be correct for invalid key w/ get()");
});

test("Function: writeAttribute() in the Parent Record",
function() {

  testParent.writeAttribute('name', 'New Parent Name');
  equals(testParent.get('name'), 'New Parent Name', "writeAttribute should be the new name attribute");

  testParent.writeAttribute('nothing', 'nothing');
  equals(testParent.get('nothing'), 'nothing', "writeAttribute should be correct for new key");

  testParent.writeAttribute('person',
  {
    type: 'Person',
    name: 'Al Gore',
    address: {
      type: 'Address',
      street: '123 Crazy St',
      city: 'Khacki Pants',
      state: 'Insanity'
    }
  });
  same(testParent.readAttribute('person'),
    {
      type: 'Person',
      name: 'Al Gore',
      address: {
        type: 'Address',
        street: '123 Crazy St',
        city: 'Khacki Pants',
        state: 'Insanity'
      }
    },
    "writeAttribute with readAttribute should be correct for person child attribute");
});

test("Function: writeAttribute() in the Parent > Child",
function() {
  var person = testParent.get('person');
  person.writeAttribute('name', 'Luke Skywalker');
  equals(person.readAttribute('name'), 'Luke Skywalker', "writeAttribute should be the new name attribute on the child");
  var p = testParent.readAttribute('person');
  equals(p.name, 'Luke Skywalker', "check to see if a writeAttribute single change on the child will reflect on the parent");

  // check for a change on the child of the child
  var newAddress = {
    type: 'Address',
    street: '1 Way Street',
    city: 'Springfield',
    state: 'IL'
  };
  person.writeAttribute('address', newAddress);
  same(person.readAttribute('address'), {
    type: 'Address',
    street: '1 Way Street',
    city: 'Springfield',
    state: 'IL'
  }, "writeAttribute should be the new address attribute on the child");
  p = testParent.readAttribute('person');
  same(p.address, {
    type: 'Address',
    street: '1 Way Street',
    city: 'Springfield',
    state: 'IL'
  }, "check to see if a writeAttribute address change on the child will reflect on the parent");
});

test("Function: writeAttribute() in the Parent > Child > Child",
function() {
  var address = testParent.getPath('person.address');
  address.writeAttribute('street', '1 Death Star Lane');
  equals(address.readAttribute('street'), '1 Death Star Lane', "writeAttribute should be the new name attribute on the child.street");
  // Now, test the person
  var p = testParent.readAttribute('person');
  equals(p.address.street, '1 Death Star Lane', "check to see if a writeAttribute change on the child will reflect on the child > child.address.street");
  // now test the Parent record
  var parentAttrs = testParent.get('attributes');
  equals(parentAttrs.person.address.street, '1 Death Star Lane', "check to see if a writeAttribute change on the child will reflect on the child > child > parent.attributes.person.address.street");
});

test("Basic Read",
function() {

  // Test general gets
  equals(testParent.get('name'), 'Parent Name', "Parent.get() should be correct for name attribute");
  equals(testParent.get('nothing'), null, "Parent.get() should be correct for invalid key");

  // Test Child Record creation
  var p = testParent.get('person');
  // Check Model Class information
  ok(SC.kindOf(p, SC.Record), "(parent > child).get() creates an actual instance that is a kind of a SC.Record Object");
  ok(SC.instanceOf(p, NestedRecord.Person), "(parent > child).get() creates an actual instance of a Person Object");

  // Check reference information
  var pKey = p.get('id');
  var storeRef = store.find(NestedRecord.Person, pKey);
  ok(storeRef, 'checking that the store has the instance of the child record with proper primary key');
  equals(p, storeRef, "checking the parent reference is the same as the direct store reference");
  same(storeRef.get('attributes'), testParent.readAttribute('person'), "check that the ChildRecord's attributes are the same as the parent.person's readAttribute for the reference");

  var a = testParent.getPath('person.address');
  // Check Model Class information
  ok(SC.kindOf(a, SC.Record), "(parent > child > child) w/ getPath() creates an actual instance that is a kind of a SC.Record Object");
  ok(SC.instanceOf(a, NestedRecord.Address), "(parent > child > child) w/ getPath() creates an actual instance of an Address Object");

  // Check reference information
  var aKey = a.get('id');
  storeRef = store.find(NestedRecord.Address, aKey);
  ok(storeRef, 'checking that the store has the instance of the (parent > child > child) record with proper primary key');
  equals(a, storeRef, "checking the (parent > child > child) reference is the same as the direct store reference");
  same(storeRef.get('attributes'), p.readAttribute('address'), "check that the ChildRecord's attributes are the same as the (parent > child.address)'s readAttribute for the reference");
});

test("Basic Write",
function() {
  var oldP, p, key, oldKey, storeRef;
  var a, parentAttrs;
  // Test general gets
  testParent.set('name', 'New Parent Name');
  equals(testParent.get('name'), 'New Parent Name', "set() should change name attribute");
  testParent.set('nothing', 'nothing');
  equals(testParent.get('nothing'), 'nothing', "set should change non-existent property to a new property");

  // Test Child Record creation
  oldP = testParent.get('person');
  testParent.set('person', {
    type: 'Person',
    name: 'Al Gore',
    address: {
      type: 'Address',
      street: '123 Crazy St',
      city: 'Khacki Pants',
      state: 'Insanity'
    }
  });
  p = testParent.get('person');
  // Check Model Class information
  ok(SC.kindOf(p, SC.Record), "set() with an object creates an actual instance that is a kind of a SC.Record Object");
  ok(SC.instanceOf(p, NestedRecord.Person), "set() with an object creates an actual instance of a ChildRecordTest Object");

  // Check reference information
  key = p.get('id');
  storeRef = store.find(NestedRecord.Person, key);
  ok(storeRef, 'after a set() with an object, checking that the store has the instance of the child record with proper primary key');
  equals(p, storeRef, "after a set with an object, checking the parent reference is the same as the direct store reference");
  oldKey = oldP.get('id');
  ok((oldKey === key), 'check to see that the old child record has the same key as the new child record');

  // Check for changes on the child bubble to the parent.
  p.set('name', 'Child Name Change');
  equals(p.get('name'), 'Child Name Change', "after a set('name', <new>) on child, checking that the value is updated");
  ok(p.get('status') & SC.Record.DIRTY, 'check that the child record is dirty');
  ok(testParent.get('status') & SC.Record.DIRTY, 'check that the parent record is dirty');
  oldP = p;
  p = testParent.get('person');
  same(p, oldP, "after a set('name', <new>) on child, checking to see that the parent has received the changes from the child record");
  same(testParent.readAttribute('person'), p.get('attributes'), "after a set('name', <new>) on child, readAttribute on the parent should be correct for info child attributes");

  // Check changes on the address
  a = testParent.getPath('person.address');
  a.set('street', '321 Nutty Professor Lane');
  parentAttrs = testParent.readAttribute('person');
  same(a.get('attributes'), parentAttrs.address, "after a set('street', <new>) on address child, checking to see that the parent has received the changes from the child record");
});

test("Basic normalize()", function() {
  var pAttrs;
  testParent.set('person', {
    type: 'Person',
    name: 'Al Gore',
    address: {
      type: 'Address',
      street: '123 Crazy St',
      city: 'Khacki Pants'
    }
  });
  testParent.normalize();
  pAttrs = testParent.get('attributes');
  equals(pAttrs.person.address.state, 'VA', "test normalization is the default value of VA");
});


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/models/record/core_methods.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

var MyApp, dataSource;
module("SC.Record core methods", {
  setup: function() {
    dataSource = SC.DataSource.create({

      gotParams: NO,
      wasCommitted: NO,

      createRecord: function(store, storeKey, params) {
        this.wasCommitted = YES;
        this.gotParams = params && params['param1'] ? YES: NO;
      }});

    MyApp = SC.Object.create({
      store: SC.Store.create().from(dataSource)
    })  ;

    MyApp.Foo = SC.Record.extend({});
    MyApp.json = {
      foo: "bar",
      number: 123,
      bool: YES,
      array: [1,2,3],
      guid: 1
    };

    SC.RunLoop.begin();
    MyApp.foo = MyApp.store.createRecord(MyApp.Foo, MyApp.json);
    SC.RunLoop.end();

  }
});

test("statusString", function() {
  equals(MyApp.foo.statusString(), 'READY_NEW', 'status string should be READY_NEW');
});

test("Can commitRecord() specific SC.Record instance", function() {

  MyApp.foo.set('foo', 'foobar');

  // commit the new record
  MyApp.foo.commitRecord({ param1: 'value1' });

  equals(dataSource.wasCommitted, YES, 'Record was committed');
  equals(dataSource.gotParams, YES, 'Params were properly passed through commitRecord');

});

test("JSON encoding an SC.Record should encode the attributes", function(){
  var str = SC.json.encode(MyApp.foo);
  var result = SC.json.decode(str);

  same(MyApp.json, result, "original = encoded record");
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/models/record/destroy.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

var MyFoo = null, callInfo ;
module("SC.Record#destroy", {
  setup: function() {
    SC.RunLoop.begin();
    MyApp = SC.Object.create({
      store: SC.Store.create()
    })  ;
  
    MyApp.Foo = SC.Record.extend();
    MyApp.json = { 
      foo: "bar", 
      number: 123,
      bool: YES,
      array: [1,2,3] 
    };
    
    MyApp.foo = MyApp.store.createRecord(MyApp.Foo, MyApp.json);
    
    // modify store so that every time refreshRecords() is called it updates 
    // callInfo
    callInfo = null ;
    MyApp.store.__orig = MyApp.store.destroyRecord;
    MyApp.store.destroyRecord = function(records) {
      callInfo = SC.A(arguments) ; // save method call
      MyApp.store.__orig.apply(MyApp.store, arguments); 
    };
    SC.RunLoop.end();
  }
});

test("calling destroy on a newRecord will mark the record as destroyed and calls destroyRecords on the store", function() {
  equals(MyApp.foo.get('status'), SC.Record.READY_NEW, 'precond - status is READY_NEW');
  SC.RunLoop.begin();
  MyApp.foo.destroy();
  SC.RunLoop.end();
  same(callInfo, [null, null, MyApp.foo.storeKey], 'destroyRecords() should not be called');
  
  equals(MyApp.foo.get('status'), SC.Record.DESTROYED_CLEAN, 'status should be SC.Record.DESTROYED_CLEAN');
});

test("calling destroy on existing record should call destroyRecord() on store", function() {

  // Fake it till you make it...
  MyApp.store.writeStatus(MyApp.foo.storeKey, SC.Record.READY_CLEAN)
    .dataHashDidChange(MyApp.foo.storeKey, null, YES);
    
  equals(MyApp.foo.get('status'), SC.Record.READY_CLEAN, 'precond - status is READY CLEAN');
  
  SC.RunLoop.begin();
  MyApp.foo.destroy();
  SC.RunLoop.end();
  
  same(callInfo, [null, null, MyApp.foo.storeKey], 'destroyRecord() should not be called');
  equals(MyApp.foo.get('status'), SC.Record.DESTROYED_DIRTY, 'status should be SC.Record.DESTROYED_DIRTY');
});

test("calling destroy on a record that is already destroyed should do nothing", function() {

  // destroy once
  SC.RunLoop.begin();
  MyApp.foo.destroy();
  SC.RunLoop.end();
  equals(MyApp.foo.get('status'), SC.Record.DESTROYED_CLEAN, 'status should be DESTROYED_CLEAN');
  
  SC.RunLoop.begin();
  MyApp.foo.destroy();
  SC.RunLoop.end();
  equals(MyApp.foo.get('status'), SC.Record.DESTROYED_CLEAN, 'status should be DESTROYED_CLEAN');
});

test("should return receiver", function() {
  equals(MyApp.foo.destroy(), MyApp.foo, 'should return receiver');
});

test("destroy should update status cache", function() {
  var st = MyApp.foo.get('status');
  ok(st !== SC.Record.DESTROYED_CLEAN, 'precond - foo should not be destroyed');

  SC.RunLoop.begin();
  MyApp.foo.destroy();
  equals(MyApp.foo.get('status'), SC.Record.DESTROYED_CLEAN, 'status should be DESTROYED_CLEAN immediately when destroyed directly by record');
  SC.RunLoop.end();
});



})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/models/record/error_methods.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

var store, Application;
module("SC.Record Error Methods", {
  setup: function() {

    Application = {};
    Application.Thing = SC.Record.extend({
      name: SC.Record.attr(String)
    });

    SC.RunLoop.begin();
    store = SC.Store.create();

    var records = [
      { guid: 1, name: 'Thing One' },
      { guid: 2, name: 'Thing Two' }
    ];

    var types = [ Application.Thing, Application.Thing ];

    store.loadRecords(types, records);
    SC.RunLoop.end();
  },

  teardown: function() {
    store = null;
    Application = null;
  }
});

test("Verify error methods behave correctly", function() {
  var thing1 = store.find(Application.Thing, 1);
  var storeKey = thing1.get('storeKey');

  var thing2 = store.find(Application.Thing, 2);

  SC.RunLoop.begin();
  store.writeStatus(storeKey, SC.Record.BUSY_LOADING);
  store.dataSourceDidError(storeKey, SC.Record.GENERIC_ERROR);
  SC.RunLoop.end();

  ok((thing1.get('isError') === YES), "isError on thing1 should be YES");
  ok((thing2.get('isError') === NO), "isError on thing2 should be NO");

  equals(thing1.get('errorObject'), SC.Record.GENERIC_ERROR,
    "get('errorObject') on thing1 should return the correct error object");

  equals(thing2.get('errorObject'), null,
    "get('errorObject') on thing2 should return null");
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/models/record/normalize.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// test normalize method for SC.Record
var storeKeys, rec, rec2, rec3, rec4;
module("SC.Record normalize method", {
  setup: function() {

    SC.RunLoop.begin();
 
    MyApp = SC.Object.create({
      store: SC.Store.create()
    });
    
    MyApp.Foo = SC.Record.extend({
      
      guid: SC.Record.attr(String, { defaultValue: function() {
        var i, rnum, chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz",
          strLen = 8, ret = '';
    		for (i=0; i<strLen; i++) {
    			rnum = Math.floor(Math.random() * chars.length);
    			ret += chars.substring(rnum,rnum+1);
    		}
    		return ret;
      } }),
      
      // test simple reading of a pass-through prop
      firstName: SC.Record.attr(String),

      // test Array
      anArray: SC.Record.attr(Array),
      
      // used to test default value
      defaultValue: SC.Record.attr(String, {
        defaultValue: "default"
      }),
      
      // test toOne relationships
      relatedTo: SC.Record.toOne('MyApp.Foo', { defaultValue: '1' }),
      
      // test toOne relationship computed default
      relatedToComputed: SC.Record.toOne('MyApp.Foo', { 
        defaultValue: function() {
          var num = Math.floor(Math.random()*2+1);
          return 'foo' + num;
        }
      }),
      
      // test toMany relationships
      relatedToMany: SC.Record.toMany('MyApp.Foo')
 
    });

    // A parent record
    MyApp.FooParent = SC.Record.extend({
      nestedRecordNamespace: MyApp,
      myChild: SC.ChildAttribute.attr('MyApp.FooChild')
    });

    // A child record
    MyApp.FooChild = SC.Record.extend({
    });
    
    MyApp.Bar = SC.Record.extend({
      // test toOne relationships
      relatedTo: SC.Record.toOne('MyApp.Bar', { defaultValue: '1' })
    });
    
    MyApp.OneBar = SC.Record.extend({
      manyFoos: SC.Record.toMany('MyApp.ManyFoo', {
        key: 'many_foos',
        inverse: 'oneBar'
      })
    });
    
    MyApp.ManyFoo = SC.Record.extend({
      oneBar: SC.Record.toOne('MyApp.OneBar', {
        key: 'bar_id',
        inverse: 'manyFoos'
      })
    });
    
    storeKeys = MyApp.store.loadRecords(MyApp.Foo, [
      { 
        guid: 'foo1', 
        firstName: 123, 
        anArray: ['one', 'two', 'three']
      },
      
      { 
        guid: 'foo2', 
        firstName: "Jane",
        relatedTo: 'foo1'
      },
      
      {
        guid: 'foo3'
      }
      
    ]);
    
    rec = MyApp.store.find(MyApp.Foo, 'foo1');
    rec2 = MyApp.store.find(MyApp.Foo, 'foo2');
    rec3 = MyApp.store.find(MyApp.Foo, 'foo3');
    
    equals(rec.storeKey, storeKeys[0], 'should find record');
    
  },
  
  teardown: function() {
    SC.RunLoop.end();
  }
  
});

// ..........................................................
// NORMALIZING
// 

test("normalizing a pre-populated record" ,function() {
  
  equals(rec.attributes()['firstName'], 123, 'hash value of firstName is 123');
  equals(rec.get('firstName'), '123', 'get value of firstName is 123 string');
  
  rec.normalize();
  
  var sameValue = rec.attributes()['firstName'] === '123';
  var relatedTo = rec.attributes()['relatedTo'] === '1';
  var relatedToComputed = rec.attributes()['relatedToComputed'];
  
  var computedValues = ['foo1', 'foo2', 'foo3'];
  
  ok(sameValue, 'hash value of firstName after normalizing is 123 string');
  ok(sameValue, 'hash value of relatedTo should be 1');
  ok(computedValues.indexOf(relatedToComputed)!==-1, 'hash value of relatedToComputed should be either foo1, foo2 or foo3');
  
  equals(rec.get('firstName'), '123', 'get value of firstName after normalizing is 123 string');
  
});

test("normalizing an empty record" ,function() {
  
  equals(rec3.attributes()['defaultValue'], undefined, 'hash value of defaultValue is undefined');
  equals(rec3.get('defaultValue'), 'default', 'get value of defaultValue is default');
  
  rec3.normalize();
  
  equals(rec3.attributes()['defaultValue'], 'default', 'hash value of defaultValue after normalizing is default');
  equals(rec3.get('defaultValue'), 'default', 'get value of defaultValue after normalizing is default');
  
});

test("normalizing with includeNull flag" ,function() {
  
  equals(rec3.attributes()['firstName'], undefined, 'hash value of firstName is undefined');
  equals(rec3.get('firstName'), null, 'get value of firstName is null');
  
  rec3.normalize(YES);
  
  equals(rec3.attributes()['firstName'], null, 'hash value of firstName after normalizing is null');
  equals(rec3.get('firstName'), null, 'get value of firstName after normalizing is null');
  
});

test("normalizing a new record with toOne should reflect id in data hash" ,function() {

  var recHash = { 
    guid: 'foo4', 
    firstName: "Jack",
    relatedTo: 'foo1'
  };

  var newRecord = MyApp.store.createRecord(MyApp.Foo, recHash);
  MyApp.store.commitRecords();
  
  equals(newRecord.attributes()['relatedTo'], 'foo1', 'hash value of relatedTo is foo1');
  equals(newRecord.get('relatedTo'), rec, 'get value of relatedTo is foo1');

  newRecord.normalize();
  
  equals(newRecord.attributes()['relatedTo'], 'foo1', 'hash value of relatedTo after normalizing is still foo1');
  equals(newRecord.get('relatedTo'), rec, 'get value of relatedTo after normalizing remains foo1');
  
});

test("normalizing a new record with toMany should reflect id in data hash" ,function() {

  var recHash = { 
    guid: 'foo5', 
    firstName: "Andrew",
    relatedToMany: ['foo1', 'foo2']
  };

  var newRecord = MyApp.store.createRecord(MyApp.Foo, recHash);
  MyApp.store.commitRecords();
  
  ok(SC.typeOf(newRecord.attributes()['relatedToMany'])===SC.T_ARRAY, 'should be a hash');
  equals(newRecord.get('relatedToMany').get('length'), 2, 'number of relatedToMany is 2');
  
  newRecord.normalize();
  
  ok(SC.typeOf(newRecord.attributes()['relatedToMany'])===SC.T_ARRAY, 'should still be a hash after normalizing');
  equals(newRecord.get('relatedToMany').get('length'), 2, 'number of relatedToMany is still 2');
  
});

test("normalizing a new record with toOne that has broken relationship" ,function() {

  var recHash = { 
    guid: 'foo5', 
    firstName: "Andrew",
    relatedTo: 'foo10' // does not exist
  };

  var newRecord = MyApp.store.createRecord(MyApp.Foo, recHash);
  MyApp.store.commitRecords();
  
  equals(newRecord.attributes()['relatedTo'], 'foo10', 'should be foo10');
  
  newRecord.normalize();
  
  equals(newRecord.attributes()['relatedTo'], 'foo10', 'should remain foo10');
  
});

test("normalizing a new record with toOne with relationship to wrong recordType" ,function() {

  var recHash = { 
    guid: 'bar1', 
    firstName: "Andrew",
    relatedTo: 'foo1' // does exist but wrong recordType
  };

  var newRecord = MyApp.store.createRecord(MyApp.Bar, recHash);
  MyApp.store.commitRecords();
  
  equals(newRecord.attributes()['relatedTo'], 'foo1', 'should be foo1');
  
  newRecord.normalize();
  
  equals(newRecord.attributes()['relatedTo'], 'foo1', 'should remain foo1');
  
});

test("normalizing a new record with no guid should work with defaultValue" ,function() {
  
  var recHash = { 
    firstName: "Andrew",
    relatedTo: 'foo1' // does exist but wrong recordType
  };
  
  var newRecord = MyApp.store.createRecord(MyApp.Foo, recHash);
  MyApp.store.commitRecords();
  
  var firstGuid = newRecord.get('guid');
  
  equals(newRecord.get('firstName'), 'Andrew', 'firstName should be Andrew');
  
  newRecord.normalize();
  
  var findRecord = MyApp.store.find(MyApp.Foo, firstGuid);
  
  equals(findRecord.get('guid'), firstGuid, 'guid should be the same as first');
  
});

test("normalizing a new record with a null child reference", function() {
  var recHash = {
    guid: 'testId1'
  };

  // Create a parent record with an ChildAttribute property referring to no child.
  // Make sure normalize() can handle that.
  var newRecord = MyApp.store.createRecord(MyApp.FooParent, recHash);
  var newRecordId, findRecord;
  
  MyApp.store.commitRecords();
  newRecordId = newRecord.get('id');
  newRecord.normalize();

  findRecord = MyApp.store.find(MyApp.FooParent, newRecordId);
  equals(findRecord.get('id'), newRecordId, 'id should be the same as the first');
});

test("normalizing a new record with toOne without defaultValue" ,function() {
  
  var oneBarHash = {
    guid: 1,
    many_foos: [1]
  }
  
  var oneBarRecord = MyApp.store.createRecord(MyApp.OneBar, oneBarHash);

  var fooHash = {
    guid: 1,
    bar_id: 1
  };

  var fooRecord = MyApp.store.createRecord(MyApp.ManyFoo, fooHash);
  MyApp.store.commitRecords();
    
  equals(fooRecord.attributes()['bar_id'], 1, 'hash value of oneBar is 1');
  equals(fooRecord.get('oneBar'), oneBarRecord, 'get value of oneBar is 1');

  fooRecord.normalize();
  
  equals(fooRecord.attributes()['bar_id'], 1, 'hash value of oneBar after normalizing is still 1');
  equals(fooRecord.get('oneBar'), oneBarRecord, 'get value of oneBar after normalizing remains 1');
  
});


test("normalizing an undefined Date value", function () {
  var Message = SC.Record.extend({
    to: SC.Record.attr(String),
    from: SC.Record.attr(String),
    timestamp: SC.Record.attr(Date),
    text: SC.Record.attr(String)
  });

  var message = MyApp.store.createRecord(Message, {
    guid: 'chocolate-moose',
    to: 'swedish.chef@muppets.com',
    from: 'moose@muppets.com',
    text: 'Bork bork bork!'
  });

  message.normalize();

  equals(message.get('timestamp'), null, "normalizes to null");
});


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/models/record/readAttribute.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

var store, Foo, json, foo ;
module("SC.Record#readAttribute", {
  setup: function() {
    SC.RunLoop.begin();
    store = SC.Store.create();
    Foo = SC.Record.extend();
    json = { 
      foo: "bar", 
      number: 123,
      bool: YES,
      array: [1,2,3] 
    };
    
    foo = store.createRecord(Foo, json);
    store.writeStatus(foo.storeKey, SC.Record.READY_CLEAN); 
  },
  
  teardown: function() {
    SC.RunLoop.end();
  }
});

test("returns unaltered JSON value for existing attributes", function() {
  var key ;
  for(key in json) {
    if (!json.hasOwnProperty(key)) continue;
    equals(foo.get(key), json[key], 'should return value for predefined key %@'.fmt(key));
  }
});

test("returns undefined for unknown JSON attributes", function() {
  equals(foo.get('imaginary'), undefined, 'should return undefined for unknown key "imaginary"');
});

test("returns new value if edited via writeAttribute", function() {
  foo.writeAttribute("bar", "baz");
  equals(foo.readAttribute("bar"), "baz", "should return value for new attribute 'bar'");
});

test("returns undefined when data hash is not present", function() {
  store.removeDataHash(foo.storeKey);
  equals(store.readDataHash(foo.storeKey), null, 'precond - data hash should be removed from store');
  equals(foo.readAttribute("foo"), undefined, "should return undefined if data hash is missing");
});



})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/models/record/refresh.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

var MyFoo = null, callInfo ;
module("SC.Record#refresh", {
  setup: function() {
    SC.RunLoop.begin();
    MyApp = SC.Object.create({
      store: SC.Store.create()
    })  ;
  
    MyApp.Foo = SC.Record.extend();
    MyApp.json = { 
      foo: "bar", 
      number: 123,
      bool: YES,
      array: [1,2,3] 
    };
    
    MyApp.foo = MyApp.store.createRecord(MyApp.Foo, MyApp.json);
    
    // modify store so that every time refreshRecords() is called it updates 
    // callInfo
    callInfo = null ;
    MyApp.store.refreshRecord = function(records) {
      callInfo = SC.A(arguments) ; // save method call
    };
  },
  
  teardown: function() {
    SC.RunLoop.end();
  }
  
});

test("calling refresh should call refreshRecord() on store", function() {
  MyApp.foo.refresh();
  same(callInfo, [null,null,MyApp.foo.storeKey,undefined], 'refreshRecord() should be called on parent');
});

test("should return receiver", function() {
  equals(MyApp.foo.refresh(), MyApp.foo, 'should return receiver');
});


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/models/record/storeDidChangeProperties.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

var store, child, Foo, json, foo ;
module("SC.Record#storeDidChangeProperties", {
  setup: function() {
    SC.RunLoop.begin();
    
    store = SC.Store.create();
    Foo = SC.Record.extend({
      
      // record diagnostic change
      statusCnt: 0,
      statusDidChange: function() {
        this.statusCnt++;
      }.observes('status'),
      
      fooCnt: 0,
      fooDidChange: function() {
        this.fooCnt++;
      }.observes('foo')
      
    });
    
    
    json = { 
      foo: "bar", 
      number: 123,
      bool: YES,
      array: [1,2,3] 
    };
    
    foo = store.createRecord(Foo, json);
    store.writeStatus(foo.storeKey, SC.Record.READY_CLEAN);
    
    SC.RunLoop.end();
  }
});

function checkPreconditions() {
  equals(foo.statusCnt, 0, 'precond - statusCnt');
  equals(foo.fooCnt, 0, 'precond - fooCnt');
}

function expect(fooObject, expectedStatusCnt, expectedFooCnt) {
  equals(fooObject.statusCnt, expectedStatusCnt, 'status should have changed');
  equals(fooObject.fooCnt, expectedFooCnt, 'foo should have changed');
}

// ..........................................................
// BASIC BEHAVIORS
// 

test("should change status only if statusOnly=YES", function() {
  checkPreconditions();
  foo.storeDidChangeProperties(YES);
  expect(foo,1,0);
});


test("should change attrs  & status if statusOnly=NO", function() {
  checkPreconditions();
  foo.storeDidChangeProperties(NO);
  expect(foo,1,1);
});

// ..........................................................
// VERIFY CALL SCENARIOS
// 

test("editing a clean record should change all", function() {
  checkPreconditions();
  
  SC.RunLoop.begin();
  foo.writeAttribute("foo", "baz"); // NB: Must be different from "foo"
  SC.RunLoop.end();
  
  expect(foo,2,1);
});

test("editing an attribute to same value should do nothing", function() {
  checkPreconditions();
  
  SC.RunLoop.begin();
  foo.writeAttribute("foo", "bar"); // NB: Must be "bar"
  SC.RunLoop.end();
  
  expect(foo,0,0);
});

test("destroying a record should change all", function() {
  checkPreconditions();
  SC.RunLoop.begin();
  foo.destroy();
  expect(foo,1,0); // calling destroy() should specifically change status
  SC.RunLoop.end();
  expect(foo,2,1);
});

test("refreshing a record should change status", function() {
  checkPreconditions();
  SC.RunLoop.begin();
  foo.refresh();
  SC.RunLoop.end();
  expect(foo,1,0);
});

test("committing attribute changes from nested store should change attrs", function() {
  checkPreconditions();
  
  SC.RunLoop.begin();
  var child = store.chain();
  var foo2 = child.materializeRecord(foo.storeKey);

  foo2.writeAttribute('foo', 'baz'); // must not be 'bar'
  SC.RunLoop.end();
  // no changes should happen yet on foo.
  expect(foo,0,0);
  
  SC.RunLoop.begin();
  // commit
  child.commitChanges();

  // now changes
  expect(foo,1,1);
});

test("changing attributes on a parent store should notify child store if inherited", function() {
  var child = store.chain();
  var oldfoo = foo;
  var parentfoo = store.materializeRecord(foo.storeKey);
  var childfoo = child.materializeRecord(foo.storeKey);
  equals(child.storeKeyEditState(foo.storeKey), SC.Store.INHERITED, 'precond - foo should be inherited from parent store');
  
  SC.RunLoop.begin();
  parentfoo.writeAttribute('foo', 'baz'); // must not be bar
  SC.RunLoop.end();
  
  expect(childfoo,1,1); // should reflect on child
});

test("changing attributes on a parent store should NOT notify child store if locked", function() {
  
  var child = store.chain();
  var oldfoo = foo;
  var parentfoo = store.materializeRecord(foo.storeKey);
  var childfoo = child.materializeRecord(foo.storeKey);
  childfoo.readAttribute('foo');
  equals(child.storeKeyEditState(foo.storeKey), SC.Store.EDITABLE, 'precond - foo should be locked from parent store');
   
  SC.RunLoop.begin();
  parentfoo.writeAttribute('foo', 'baz'); // must not be bar
  SC.RunLoop.end();
  expect(childfoo,0,0); // should not reflect on child
  expect(parentfoo,2,1);
  // discarding changes should update

  // NOTE: recourds should change immediately on commit/discard changes.
  // test results here BEFORE run loop ends
  SC.RunLoop.begin();
  child.discardChanges(); // make it match parent again
  expect(childfoo,1,1); //the childfoo record is reset to whatever the parentValue is.
  SC.RunLoop.end();

});


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/models/record/unknownProperty.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

var MyFoo = null ;
module("SC.Record#unknownProperty", {
  setup: function() {
    SC.RunLoop.begin();
    MyApp = SC.Object.create({
      store: SC.Store.create()
    })  ;
  
    MyApp.Foo = SC.Record.extend();
    MyApp.json = { 
      foo: "bar", 
      number: 123,
      bool: YES,
      array: [1,2,3] 
    };
    
    MyApp.foo = MyApp.store.createRecord(MyApp.Foo, MyApp.json);
    
    MyApp.FooStrict = SC.Record.extend();
    
    SC.mixin(MyApp.FooStrict, {
      ignoreUnknownProperties: YES
    });
    
    MyApp.fooStrict = MyApp.store.createRecord(MyApp.FooStrict, MyApp.json);
    
  },
  
  teardown: function() {
    SC.RunLoop.end();
  }
});

test("get() returns attributes with no type changes if they exist", function() {
  'foo number bool array'.w().forEach(function(key) {
    equals(MyApp.foo.get(key), MyApp.json[key], "MyApp.foo.get(%@) should === attribute".fmt(key));
  });
});

test("get() unknown attribute returns undefined", function() {
  equals(MyApp.foo.get('imaginary'), undefined, 'imaginary property should be undefined');
});

test("set() unknown property should add to dataHash", function() {
  MyApp.foo.set('blue', '0x00f');
  equals(MyApp.store.dataHashes[MyApp.foo.storeKey].blue, '0x00f', 'should add blue attribute');
});

test("set() should replace existing property", function() {
  MyApp.foo.set('foo', 'baz');
  equals(MyApp.store.dataHashes[MyApp.foo.storeKey].foo, 'baz', 'should update foo attribute');
});

test("set() on unknown property if model ignoreUnknownProperties=YES should not write it to data hash", function() {
  MyApp.fooStrict.set('foo', 'baz');
  equals(MyApp.store.dataHashes[MyApp.fooStrict.storeKey].foo, 'bar', 'should not have written new value to dataHash');
});



})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/models/record/writeAttribute.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

var store, Foo, json, foo ;
module("SC.Record#writeAttribute", {
  setup: function() {
    SC.RunLoop.begin();
    store = SC.Store.create();
    Foo = SC.Record.extend();
    json = { 
      foo: "bar", 
      number: 123,
      bool: YES,
      array: [1,2,3],
      guid: 1
    };
    
    foo = store.createRecord(Foo, json);
    store.writeStatus(foo.storeKey, SC.Record.READY_CLEAN);
    SC.RunLoop.end();
  }
});

test("returns receiver", function() {
  equals(foo.writeAttribute("bar", "baz"), foo, 'should return receiver');
});

test("first time writing should mark record as dirty", function() {
  // precondition
  equals(foo.get('status'), SC.Record.READY_CLEAN, 'precond - start clean');

  SC.RunLoop.begin();
  // action
  foo.writeAttribute("bar", "baz");
  SC.RunLoop.end();
  
  // evaluate
  equals(foo.get('status'), SC.Record.READY_DIRTY, 'should make READY_DIRTY after write');
});

test("state change should be deferred if writing inside of a beginEditing()/endEditing() pair", function() {

  // precondition
  equals(foo.get('status'), SC.Record.READY_CLEAN, 'precond - start clean');

  SC.RunLoop.begin();
  // action
  foo.beginEditing();
  
  foo.writeAttribute("bar", "baz");
  
  equals(foo.get('status'), SC.Record.READY_CLEAN, 'should not change state yet');

  foo.endEditing();
  
  SC.RunLoop.end();
  
  // evaluate
  equals(foo.get('status'), SC.Record.READY_DIRTY, 'should make READY_DIRTY after write');
  
}) ;

test("raises exception if you try to write an attribute before an attribute hash has been set", function() {
  store.removeDataHash(foo.storeKey);
  equals(store.readDataHash(foo.storeKey), null, 'precond - should not have store key');
  
  var cnt=0 ;
  try {
    foo.writeAttribute("foo", "bar");
  } catch(e) {
    equals(e, SC.Record.BAD_STATE_ERROR, 'should throw BAD_STATE_ERROR');
    cnt++;
  }
  equals(cnt, 1, 'should raise exception');
});


test("Writing to an attribute in chained store sets correct status", function() {
  
  var chainedStore = store.chain() ;
  
  var chainedRecord = chainedStore.find(Foo, foo.get('id'));
  equals(chainedRecord.get('status'), SC.Record.READY_CLEAN, 'precon - status should be READY_CLEAN');
  
  SC.RunLoop.begin();
  chainedRecord.writeAttribute('foo', 'newValue');
  SC.RunLoop.end();
  //chainedRecord.set('foo', 'newValue');
  
  equals(chainedRecord.get('status'), SC.Record.READY_DIRTY, 'status should be READY_DIRTY');
  
});


test("Writing a new guid", function(){
  equals(foo.get('id'), 1, 'foo.id should be 1');
  foo.set('guid', 2);
  equals(foo.get('id'), 2, 'foo.id should be 2');
});

test("Writing primaryKey of 'id'", function(){
  PrimaryKeyId = SC.Record.extend({ primaryKey: 'id' });
  var foo2 = store.createRecord(PrimaryKeyId, { id: 1 });

  equals(foo2.get('id'), 1, 'foo2.id should be 1');
  foo2.set('id', 2);
  equals(foo2.get('id'), 2, 'foo2.id should be 2');
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/models/record_attribute.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// test core array-mapping methods for RecordArray with RecordAttribute
var storeKeys, rec, rec2, rec3, bar, MyApp;

module("SC.RecordAttribute core methods", {
  setup: function() {

    MyApp = SC.Object.create({
      store: SC.Store.create()
    });

    // stick it to the window object so that objectForPropertyPath works
    window.MyApp = MyApp;

    MyApp.Foo = SC.Record.extend({

      // test simple reading of a pass-through prop
      firstName: SC.Record.attr(String),

      // test mapping to another internal key
      otherName: SC.Record.attr(String, { key: "firstName" }),

      // test mapping Date
      date: SC.Record.attr(Date),
      nonIsoDate: SC.Record.attr(Date, { useIsoDate: false }),

      // test SC.DateTimes
      dateTime: SC.Record.attr(SC.DateTime),

      // test Array
      anArray: SC.Record.attr(Array),

      // test Object
      anObject: SC.Record.attr(Object),

      // test Number
      aNumber: SC.Record.attr(Number),

      // used to test default value
      defaultValue: SC.Record.attr(String, {
        defaultValue: "default"
      }),

      // used to test default value
      defaultComputedValue: SC.Record.attr(Number, {
        defaultValue: function() {
          return Math.floor(Math.random()*3+1);
        }
      }),

      // test toOne relationships
      relatedTo: SC.Record.toOne('MyApp.Foo'),

      // test toOne relationship with computed type
      relatedToComputed: SC.Record.toOne(function() {
        // not using .get() to avoid another transform which will
        // trigger an infinite loop
        return (this.readAttribute('relatedToComputed').indexOf("foo")===0) ? MyApp.Foo : MyApp.Bar;
      }),

      // test readONly
      readOnly: SC.Record.attr(String, { isEditable: NO })

    });

    MyApp.Bar = SC.Record.extend({
      parent: SC.Record.toOne('MyApp.Foo', { aggregate: YES }),
      relatedMany: SC.Record.toMany('MyApp.Foo', { aggregate: YES })
    });

    SC.RunLoop.begin();
    storeKeys = MyApp.store.loadRecords(MyApp.Foo, [
      {
        guid: 'foo1',
        firstName: "John",
        lastName: "Doe",
        date: "2009-03-01T20:30-08:00",
        dateTime: new Date(1235939425000),
        anArray: ['one', 'two', 'three'],
        anObject: { 'key1': 'value1', 'key2': 'value2' },
        aNumber: '123',
        readOnly: 'foo1'
      },

      {
        guid: 'foo2',
        firstName: "Jane",
        lastName: "Doe",
        relatedTo: 'foo1',
        relatedToAggregate: 'bar1',
        dateTime: "2009-03-01T20:30:25Z",
        anArray: 'notAnArray',
        anObject: 'notAnObject',
        aNumber: '123',
        nonIsoDate: "2009/06/10 8:55:50 +0000"
      },

      {
        guid: 'foo3',
        firstName: "Alex",
        lastName: "Doe",
        relatedToComputed: 'bar1',
        dateTime: SC.DateTime.create(1235939425000),
        anArray: ['one', 'two', 'three'],
        anObject: { 'key1': 'value1', 'key2': 'value2' },
        aNumber: '123'
      }

    ]);

    MyApp.store.loadRecords(MyApp.Bar, [
      { guid: 'bar1', city: "Chicago", parent: 'foo2', relatedMany: ['foo1', 'foo2'] }
    ]);

    SC.RunLoop.end();

    rec = MyApp.store.find(MyApp.Foo, 'foo1');
    rec2 = MyApp.store.find(MyApp.Foo, 'foo2');
    rec3 = MyApp.store.find(MyApp.Foo, 'foo3');

    bar = MyApp.store.find(MyApp.Bar, 'bar1');
    equals(rec.storeKey, storeKeys[0], 'should find record');

  }
});

// ..........................................................
// READING
//

test("pass-through should return builtin value" ,function() {
  equals(rec.get('firstName'), 'John', 'reading prop should get attr value');
});

test("returns default value if underlying value is empty", function() {
  equals(rec.get('defaultValue'), 'default', 'reading prop should return default value');
});

test("naming a key should read alternate attribute", function() {
  equals(rec.get('otherName'), 'John', 'reading prop otherName should get attr from firstName');
});

test("getting a number", function() {
  equals((typeof rec.get('aNumber')), 'number', 'reading prop aNumber should get attr as number');
});

test("getting an array and object", function() {
  equals(rec.get('anArray').length, 3, 'reading prop anArray should get attr as array');
  equals((typeof rec.get('anObject')), 'object', 'reading prop anObject should get attr as object');
});

test("getting an array and object attributes where underlying value is not", function() {
  equals(rec2.get('anArray').length, 0, 'reading prop anArray should return empty array');
  equals((typeof rec2.get('anObject')), 'object', 'reading prop anObject should return empty object');
});

test("reading date should parse ISO date", function() {
  var d = new Date(1235968200000); // should be proper date
  equals(rec.get('date').toString(), d.toString(), 'should have matched date');
});

test("reading dateTime should parse ISO date", function() {
  var ms = 1235939425000;
  equals(rec.getPath('dateTime.milliseconds'), ms, 'should have parsed Date properly');
  equals(rec2.getPath('dateTime.milliseconds'), ms, 'should have parsed String properly');
  equals(rec3.getPath('dateTime.milliseconds'), ms, 'should have parsed SC.DateTime properly');
});

test("reading date should parse non-ISO date", function() {
  var d = new Date(1244624150000);
  equals(rec2.get('nonIsoDate').toString(), d.toString(), 'should have matched date');
});

test("reading no date should produce null", function() {
  var d = new Date(1235968200000); // should be proper date
  equals(rec2.get('date'), null, 'should have yielded null');
});

test("reading computed default value", function() {
  var value = rec.get('defaultComputedValue');
  var validValues = [1,2,3,4];
  ok(validValues.indexOf(value)!==-1, 'should have a value from 1 through 4');
});

// ..........................................................
// WRITING
//

test("writing pass-through should simply set value", function() {
  rec.set("firstName", "Foo");
  equals(rec.readAttribute("firstName"), "Foo", "should write string");

  rec.set("firstName", 23);
  equals(rec.readAttribute("firstName"), 23, "should write number");

  rec.set("firstName", YES);
  equals(rec.readAttribute("firstName"), YES, "should write bool");

});

test("writing when isEditable is NO should ignore", function() {
  var v = rec.get('readOnly');
  rec.set('readOnly', 'NEW VALUE');
  equals(rec.get('readOnly'), v, 'read only value should not change');
});

test("writing a value should override default value", function() {
  equals(rec.get('defaultValue'), 'default', 'precond - returns default');
  rec.set('defaultValue', 'not-default');
  equals(rec.get('defaultValue'), 'not-default', 'newly written value should replace default value');
});

test("writing a string to a number attribute should store a number" ,function() {
     equals(rec.set('aNumber', "456"), rec, 'returns receiver');
     equals(rec.get('aNumber'), 456, 'should have new value');
     equals(typeof rec.get('aNumber'), 'number', 'new value should be a number');
});

test("writing a date should generate an ISO date" ,function() {
  var date = new Date(1238650083966);

  // Work with timezones
  var utcDate = new Date(Number(date) + (date.getTimezoneOffset() * 60000)); // Adjust for timezone offset
  utcDate.getTimezoneOffset = function(){ return 0; }; // Hack the offset to respond 0

  equals(rec.set('date', utcDate), rec, 'returns receiver');
  equals(rec.readAttribute('date'), '2009-04-02T05:28:03Z', 'should have time in ISO format');
});

test("writing an attribute should make relationship aggregate dirty" ,function() {
  equals(bar.get('status'), SC.Record.READY_CLEAN, "precond - bar should be READY_CLEAN");
  equals(rec2.get('status'), SC.Record.READY_CLEAN, "precond - rec2 should be READY_CLEAN");

  bar.set('city', 'Oslo');
  bar.get('store').flush();

  equals(rec2.get('status'), SC.Record.READY_DIRTY, "foo2 should be READY_DIRTY");
});

test("writing an attribute should make many relationship aggregate dirty" ,function() {
  equals(bar.get('status'), SC.Record.READY_CLEAN, "precond - bar should be READY_CLEAN");
  equals(rec2.get('status'), SC.Record.READY_CLEAN, "precond - rec2 should be READY_CLEAN");

  bar.set('city', 'Oslo');
  bar.get('store').flush();

  equals(rec.get('status'), SC.Record.READY_DIRTY, "foo1 should be READY_DIRTY");
  equals(rec2.get('status'), SC.Record.READY_DIRTY, "foo2 should be READY_DIRTY");
});

test("writing an attribute should make many relationship aggregate dirty and add the aggregate to the store" ,function() {
  equals(bar.get('status'), SC.Record.READY_CLEAN, "precond - bar should be READY_CLEAN");
  equals(rec2.get('status'), SC.Record.READY_CLEAN, "precond - rec2 should be READY_CLEAN");

  bar.set('city', 'Oslo');

  var store = bar.get('store');
  ok(store.changelog.contains(rec.get('storeKey')), "foo1 should be in the store's changelog");
  ok(store.changelog.contains(rec2.get('storeKey')), "foo2 should be in the store's changelog");
});

test("adding attribute with non existing class should throw error", function() {
  MyApp.InvalidModel = SC.Record.extend({
    foo: SC.Record.attr("SomethingSomethingSomething")
  });

  var message;
  try {
    MyApp.InvalidModel.prototype.foo.typeClass();
  } catch (x) {
    message = x;
  }

  same(message, 'SomethingSomethingSomething could not be found');
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/models/single_attribute.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// test core array-mapping methods for RecordArray with RecordAttribute
var storeKeys, rec, rec2, bar, bar2 ;

module("SC.RecordAttribute core methods", {
  setup: function() {

    MyApp = SC.Object.create({
      store: SC.Store.create()
    });

    MyApp.Foo = SC.Record.extend({

      // test toOne relationships
      relatedTo: SC.Record.toOne('MyApp.Foo'),

      // test non-isEditable toOne relationships
      readOnlyRelatedTo: SC.Record.toOne('MyApp.Bar', {
        isEditable: NO
      }),

      // test toOne relationship with computed type
      relatedToComputed: SC.Record.toOne(function() {
        // not using .get() to avoid another transform which will
        // trigger an infinite loop
        return (this.readAttribute('relatedToComputed').indexOf("foo")===0) ? MyApp.Foo : MyApp.Bar;
      }),

      bar: SC.Record.toOne('MyApp.Bar', { inverse: 'foo' }),

      barKeyed: SC.Record.toOne('MyApp.Bar', { key: 'barId' })

    });

    MyApp.Bar = SC.Record.extend({
      foo: SC.Record.toOne('MyApp.Foo', { inverse: 'bar', isMaster: NO })
    });

    SC.RunLoop.begin();
    storeKeys = MyApp.store.loadRecords(MyApp.Foo, [
      {
        guid: 'foo1',
        firstName: "John",
        lastName: "Doe",
        date: "2009-03-01T20:30-08:00",
        anArray: ['one', 'two', 'three'],
        anObject: { 'key1': 'value1', 'key2': 'value2' },
        bar: "bar1"
      },

      {
        guid: 'foo2',
        firstName: "Jane",
        lastName: "Doe",
        relatedTo: 'foo1',
        anArray: 'notAnArray',
        anObject: 'notAnObject',
        nonIsoDate: "2009/06/10 8:55:50 +0000"
      },

      {
        guid: 'foo3',
        firstName: "Alex",
        lastName: "Doe",
        relatedToComputed: 'bar1',
        anArray: ['one', 'two', 'three'],
        anObject: { 'key1': 'value1', 'key2': 'value2' },
        bar: "bar2"
      },

      {
        guid: 'foo4',
        firstName: 'Joe',
        lastName:  'Schmo',
        barId: 'bar1'
      },

      {
        guid: 'foo5',
        firstName: "Jane",
        lastName: "Doe",
        readOnlyRelatedTo: 'bar1'
      }

    ]);

    MyApp.store.loadRecords(MyApp.Bar, [
      { guid: 'bar1', city: "Chicago", foo: "foo1" },
      { guid: "bar2", city: "New York", foo: 'foo3' }
    ]);

    SC.RunLoop.end();

    rec = MyApp.store.find(MyApp.Foo, 'foo1');
    rec2 = MyApp.store.find(MyApp.Foo, 'foo2');

    bar = MyApp.store.find(MyApp.Bar, 'bar1');
    bar2 = MyApp.store.find(MyApp.Bar, 'bar2');

    equals(rec.storeKey, storeKeys[0], 'should find record');

  }
});

// ..........................................................
// READING
//

test("getting toOne relationship should map guid to a real record", function() {
  var rec2 = MyApp.store.find(MyApp.Foo, 'foo2');
  equals(rec2.get('id'), 'foo2', 'precond - should find record 2');
  equals(rec2.get('relatedTo'), rec, 'should get rec1 instance for rec2.relatedTo');
});

test("getting toOne relationship from computed attribute should map guid to a real record", function() {
  var rec3 = MyApp.store.find(MyApp.Foo, 'foo3');
  equals(rec3.get('id'), 'foo3', 'precond - should find record 3');
  equals(rec3.get('relatedToComputed'), bar, 'should get bar1 instance for rec3.relatedToComputed');
});

test("reading an inverse relationship", function() {
  equals(rec.get('bar'), bar, 'foo1.bar should == bar');
  equals(bar.get('foo'), rec, 'bar.foo should == foo1');
});

test("reading a keyed relationship", function(){
  var rec4 = MyApp.store.find(MyApp.Foo, 'foo4');
  equals(rec4.get('barKeyed'), bar, 'foo4.barKeyed should == bar');
});

// ..........................................................
// WRITING
//

test("writing to a to-one relationship should update set guid", function() {
  var rec2 = MyApp.store.find(MyApp.Foo, 'foo2');
  equals(rec2.get('id'), 'foo2', 'precond - should find record 2');

  equals(rec2.get('relatedTo'), rec, 'precond - should get rec1 instance for rec2.relatedTo');

  rec2.set('relatedTo', rec2);

  equals(rec2.readAttribute('relatedTo'), 'foo2', 'should write ID for set record to relatedTo attribute');

  equals(rec2.get('relatedTo'), rec2, 'should get foo record that was just set');

});

test("writing to a to-one computed relationship should update set guid", function() {
  var rec3 = MyApp.store.find(MyApp.Foo, 'foo3');
  equals(rec3.get('id'), 'foo3', 'precond - should find record 2');
  equals(rec3.get('relatedToComputed'), bar, 'precond - should get bar1 instance for rec3.relatedToComputed');

  rec3.set('relatedToComputed', rec);
  equals(rec3.readAttribute('relatedToComputed'), 'foo1', 'should write ID for set record to relatedTo attribute');
  equals(rec2.get('relatedTo'), rec, 'should get foo record that was just set');
});

test("clearing a toOne relationship", function() {
  ok(rec2.get('relatedTo') !== null, 'precond - rec.relatedTo should have a value');

  rec2.set('relatedTo', null);
  equals(rec2.get('relatedTo'), null, 'rec.relatedTo should be null');
  equals(rec2.readAttribute('relatedTo'), null, 'rec.relatedTo attribute should be null');
});

test("clearing a toOne relationship with an inverse - foo isMaster", function() {
  equals(rec.get('bar'), bar, 'precond - foo1.bar should eq bar');
  equals(bar.get('foo'), rec, 'precond - bar.foo should eq foo1');

  equals(rec.get('status'), SC.Record.READY_CLEAN, 'precond - foo1.status should be READY_CLEAN');
  equals(bar.get('status'), SC.Record.READY_CLEAN, 'precond - bar1.status should be READY_CLEAN');

  rec.set('bar', null);

  equals(rec.get('bar'), null, 'foo1.bar should be null after change');
  equals(bar.get('foo'), null, 'bar.foo should also be null after change');

  equals(rec.get('status'), SC.Record.READY_DIRTY, 'foo1.status should be READY_DIRTY');
  equals(bar.get('status'), SC.Record.READY_CLEAN, 'bar1.status should be READY_CLEAN');

});

test("modifying a toOne relationship with an inverse from null", function() {
  equals(rec.get('bar'), bar, 'precond - foo1.bar should eq bar');
  equals(bar.get('foo'), rec, 'precond - bar.foo should eq foo1');
  equals(rec2.get('bar'), null, 'precond - foo2.bar should eq null');

  [rec, rec2, bar].forEach(function(r) {
    equals(r.get('status'), SC.Record.READY_CLEAN, 'precond - %@.status should be READY_CLEAN'.fmt(r.get('id')));
  }, this);

  bar.set('foo', rec2);

  equals(rec.get('bar'), null, 'foo1.bar should be null after change');
  equals(bar.get('foo'), rec2, 'bar.foo should eq foo2 after change');
  equals(rec2.get('bar'), bar, 'foo2.bar should eq bar after change');

  equals(rec.get('status'), SC.Record.READY_DIRTY, 'foo1.status should be READY_DIRTY');
  equals(rec2.get('status'), SC.Record.READY_DIRTY, 'foo1.status should be READY_DIRTY');
  equals(bar.get('status'), SC.Record.READY_CLEAN, 'bar1.status should be READY_CLEAN');

});

test("modifying a toOne relationship with an inverse from other", function() {

  var foo1 = rec,
      foo3 = MyApp.store.find(MyApp.Foo, 'foo3'),
      bar1 = bar;

  equals(foo1.get('bar'), bar1, 'precond - foo1.bar should eq bar1');
  equals(bar1.get('foo'), foo1, 'precond - bar.foo should eq foo1');

  equals(foo3.get('bar'), bar2, 'precond - foo3.bar should eq bar2');
  equals(bar2.get('foo'), foo3, 'precond - bar2.foo should eq foo3');


  [foo1, foo3, bar1, bar2].forEach(function(r) {
    equals(r.get('status'), SC.Record.READY_CLEAN, 'precond - %@.status should be READY_CLEAN'.fmt(r.get('id')));
  }, this);

  bar1.set('foo', foo3);

  equals(foo1.get('bar'), null, 'foo1.bar should be null after change');
  equals(bar1.get('foo'), foo3, 'bar.foo should eq foo3 after change');

  equals(foo3.get('bar'), bar1, 'foo3.bar should be bar after change');
  equals(bar2.get('foo'), null, 'bar2.foo should eq null after change');

  equals(foo1.get('status'), SC.Record.READY_DIRTY, 'foo1.status should be READY_DIRTY');
  equals(foo3.get('status'), SC.Record.READY_DIRTY, 'foo3.status should be READY_DIRTY');

  equals(bar1.get('status'), SC.Record.READY_CLEAN, 'bar1.status should be READY_CLEAN');
  equals(bar2.get('status'), SC.Record.READY_CLEAN, 'bar2.status should be READY_CLEAN');

});

test("modifying a keyed toOne relationship", function(){
  var rec4 = MyApp.store.find(MyApp.Foo, 'foo4');

  rec4.set('barKeyed', bar2);

  equals(rec4.get('barKeyed'), bar2, 'foo4.barKeyed should == bar2');
  equals(rec4.readAttribute('barId'), 'bar2', 'should write ID for set record to barId attribute');
});

test("isEditable NO should not allow editing", function() {
  var bar1 = MyApp.store.find(MyApp.Bar, 'bar1');
  var bar2 = MyApp.store.find(MyApp.Bar, 'bar2');
  var rec5 = MyApp.store.find(MyApp.Foo, 'foo5');

  equals(rec5.get('readOnlyRelatedTo'), bar1, 'precond - should find bar1');
  equals(rec5.get('status'), SC.Record.READY_CLEAN, 'precond - foo5 should be READY_CLEAN');

  rec5.set('readOnlyRelatedTo', bar2);

  equals(rec5.get('readOnlyRelatedTo'), bar1, 'should still find bar1 after setting');
  equals(rec5.get('status'), SC.Record.READY_CLEAN, 'foo5 status is still READY_CLEAN');
});

test("isEditable NO should not fire property change observer", function() {
  var bar1 = MyApp.store.find(MyApp.Bar, 'bar1');
  var bar2 = MyApp.store.find(MyApp.Bar, 'bar2');
  var rec5 = MyApp.store.find(MyApp.Foo, 'foo5');

  equals(rec5.get('readOnlyRelatedTo'), bar1, 'precond - should find bar1');

  var readOnlyWasModified = NO;
  var modifierListener = function() {
    readOnlyWasModified = YES;
  };
  rec5.addObserver('readOnlyRelatedTo', modifierListener);

  rec5.set('readOnlyRelatedTo', bar2);

  equals(readOnlyWasModified, NO, 'property change observer should not have fired');

  rec5.removeObserver('readOnlyRelatedTo', modifierListener);
});

test("adding toOne pointing to non existing class should throw error", function() {
  var message;
  try {
    MyApp.InvalidModel = SC.Record.extend({
      foo: SC.Record.toOne(MyApp.DoesNotExist)
    });
  } catch (x) {
    message = x;
  }

  same(message, 'Attempted to create toOne attribute with undefined recordType. Did you forget to sc_require a dependency?');
});

test("adding toMany pointing to non existing class should throw error", function() {
  var message;
  try {
    MyApp.InvalidModel = SC.Record.extend({
      foo: SC.Record.toMany(MyApp.DoesNotExist)
    });
  } catch (x) {
    message = x;
  }

  same(message, 'Attempted to create toMany attribute with undefined recordType. Did you forget to sc_require a dependency?');
});

module("modifying a keyed toOne relationship via the inverse", {
  setup: function() {
    MyApp = SC.Object.create({ store: SC.Store.create() });

    MyApp.Foo = SC.Record.extend({
      bar: SC.Record.toOne('MyApp.Bar', {
        isMaster: YES, inverse: 'foo'
      })
    });

    MyApp.Bar = SC.Record.extend({
      foo: SC.Record.toOne('MyApp.Foo', {
        isMaster: NO, key: 'foo_id', inverse: 'bar'
      })
    });
  }
});

test("creating an association", function() {
  var foo1, bar1;

  MyApp.store.loadRecords(MyApp.Foo, [{guid: 'foo1', bar: null}]);

  foo1 = MyApp.store.find(MyApp.Foo, 'foo1');
  bar1 = MyApp.store.createRecord(MyApp.Bar, {guid: 'bar1'});

  foo1.set('bar', bar1);

  equals(bar1.get('foo'), foo1, 'bar1.foo relationship should be established');
  equals(bar1.get('attributes').foo_id, 'foo1', 'correct key should be set in attributes');
});

test("destroying an association", function() {
  var foo1, bar1;

  MyApp.store.loadRecords(MyApp.Foo, [{guid: 'foo1', bar: 'bar1'}]);
  MyApp.store.loadRecords(MyApp.Bar, [{guid: 'bar1', foo_id: 'foo1'}]);

  foo1 = MyApp.store.find(MyApp.Foo, 'foo1');
  bar1 = MyApp.store.find(MyApp.Bar, 'bar1');

  equals(foo1.get('bar'), bar1, 'foo1.bar relationship should be established');
  foo1.set('bar', null);
  equals(bar1.get('foo'), null, 'bar.foo relationship should be destroyed');
  equals(bar1.get('attributes').foo_id, null, 'correct key should be set in attributes');
});


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/many_array/core_methods.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// test core array-mapping methods for ManyArray
var store, storeKey, storeId, rec, storeIds, recs, arrayRec;
module("SC.ManyArray core methods", {
  setup: function() {

    // setup dummy app and store
    MyApp = SC.Object.create({
      store: SC.Store.create()
    });

    // setup a dummy model
    MyApp.Foo = SC.Record.extend({});

    SC.RunLoop.begin();

    // load some data
    storeIds = [1,2,3,4];
    MyApp.store.loadRecords(MyApp.Foo, [
      { guid: 1, firstName: "John", lastName: "Doe", age: 32 },
      { guid: 2, firstName: "Jane", lastName: "Doe", age: 30 },
      { guid: 3, firstName: "Emily", lastName: "Parker", age: 7 },
      { guid: 4, firstName: "Johnny", lastName: "Cash", age: 17 },
      { guid: 50, firstName: "Holder", fooMany: storeIds }
    ]);

    storeKey = MyApp.store.storeKeyFor(MyApp.Foo, 1);

    // get record
    rec = MyApp.store.materializeRecord(storeKey);
    storeId = rec.get('id');

    // get many array.
    arrayRec = MyApp.store.materializeRecord(MyApp.store.storeKeyFor(MyApp.Foo, 50));

    recs = SC.ManyArray.create({
      record: arrayRec,
      propertyName: "fooMany",
      recordType: MyApp.Foo,
      isEditable: YES
    });
    arrayRec.relationships = [recs];
  },

  teardown: function() {
    SC.RunLoop.end();
  }
});

// ..........................................................
// LENGTH
//

test("should pass through length", function() {
  equals(recs.get('length'), storeIds.length, 'rec should pass through length');
});

test("changing storeIds length should change length of rec array also", function() {

  var oldlen = recs.get('length');

  storeIds.pushObject(SC.Store.generateStoreKey()); // change length

  ok(storeIds.length > oldlen, 'precond - storeKeys.length should have changed');
  equals(recs.get('length'), storeIds.length, 'rec should pass through length');
});

// ..........................................................
// objectAt
//

test("should materialize record for object", function() {
  equals(storeIds[0], storeId, 'precond - storeIds[0] should be storeId');
  equals(recs.objectAt(0), rec, 'recs.objectAt(0) should materialize record');
});

test("reading past end of array length should return undefined", function() {
  equals(recs.objectAt(2000), undefined, 'recs.objectAt(2000) should be undefined');
});

test("modifying the underlying storeId should change the returned materialized record", function() {
  // read record once to make it materialized
  equals(recs.objectAt(0), rec, 'recs.objectAt(0) should materialize record');

  // create a new record.
  var rec2 = MyApp.store.createRecord(MyApp.Foo, { guid: 5, firstName: "Fred" });
  var storeId2 = rec2.get('id');

  // add to beginning of storeKey array
  storeIds.unshiftObject(storeId2);
  equals(recs.get('length'), 5, 'should now have length of 5');
  equals(recs.objectAt(0), rec2, 'objectAt(0) should return new record');
  equals(recs.objectAt(1), rec, 'objectAt(1) should return old record');
});

test("reading a record not loaded in store should trigger retrieveRecord", function() {
  var callCount = 0;

  // patch up store to record a call and to make it look like data is not
  // loaded.

  MyApp.store.removeDataHash(storeKey, SC.Record.EMPTY);
  MyApp.store.retrieveRecord = function() { callCount++; };

  var rec = recs.objectAt(0);
  equals(MyApp.store.readStatus(rec), SC.Record.EMPTY, 'precond - storeKey must not be loaded');

  equals(callCount, 1, 'store.retrieveRecord() should have been called');
});

// ..........................................................
// replace()
//

test("adding a record to the ManyArray should pass through storeIds", function() {

  // read record once to make it materialized
  equals(recs.objectAt(0), rec, 'recs.objectAt(0) should materialize record');

  // create a new record.
  var rec2 = MyApp.store.createRecord(MyApp.Foo, { guid: 5, firstName: "rec2" });
  var storeId2 = rec2.get('id');

  // add record to beginning of record array
  recs.unshiftObject(rec2);

  // verify record array
  equals(recs.get('length'), 5, 'should now have length of 2');
  equals(recs.objectAt(0), rec2, 'recs.objectAt(0) should return new record');
  equals(recs.objectAt(1), rec, 'recs.objectAt(1) should return old record');

  // verify storeKeys
  storeIds = arrayRec.readAttribute('fooMany'); // array might have changed
  equals(storeIds.objectAt(0), storeId2, 'storeKeys[0] should return new storeKey');
  equals(storeIds.objectAt(1), storeId, 'storeKeys[1] should return old storeKey');
});

// ..........................................................
// Property Observing
//

test("changing the underlying storeIds should notify observers of records", function() {

  // setup observer
  var obj = SC.Object.create({
    cnt: 0,
    observer: function() { this.cnt++; }
  });
  recs.addObserver('[]', obj, obj.observer);

  // now modify storeKeys
  storeIds.pushObject(5);
  equals(obj.cnt, 1, 'observer should have fired after changing storeKeys');
});

test("swapping storeIds array should change ManyArray and observers", function() {

  // setup alternate storeKeys
  var rec2 = MyApp.store.createRecord(MyApp.Foo, { guid: 5, firstName: "rec2" });
  var storeId2 = rec2.get('id');
  var storeIds2 = [storeId2];

  // setup observer
  var obj = SC.Object.create({
    cnt: 0,
    observer: function() { this.cnt++; }
  });
  recs.addObserver('[]', obj, obj.observer);

  // read record once to make it materialized
  equals(recs.objectAt(0), rec, 'recs.objectAt(0) should materialize record');

  // now swap storeKeys
  obj.cnt = 0 ;
  arrayRec.writeAttribute('fooMany', storeIds2);

  SC.RunLoop.end();
  SC.RunLoop.begin();

  // verify observer fired and record changed
  equals(obj.cnt, 1, 'observer should have fired after swap');
  equals(recs.objectAt(0), rec2, 'recs.objectAt(0) should return new rec');

  // modify storeKey2, make sure observer fires and content changes
  obj.cnt = 0;
  storeIds2.unshiftObject(storeId);
  equals(obj.cnt, 1, 'observer should have fired after edit');
  equals(recs.get('length'), 2, 'should reflect new length');
  equals(recs.objectAt(0), rec, 'recs.objectAt(0) should return pushed rec');

});

test("reduced properties", function() {
  equals(recs.get('@sum(age)'), 32+30+7+17, 'sum reducer should return the correct value');
  equals(recs.get('@max(age)'), 32, 'max reducer should return the correct value');
  equals(recs.get('@min(age)'), 7, 'min reducer should return the correct value');
  equals(recs.get('@average(age)'), (32+30+7+17)/4.0, 'average reducer should return the correct value');
});

test("Test that _findInsertionLocation returns the correct location.", function () {
  var location,
    newRec,
    sortByFirstName = function (a, b) {
      if (a.get('firstName') == b.get('firstName')) return 0;
      else if (a.get('firstName') < b.get('firstName')) return -1;
      else return 1;
    };

  // Order the many array manually by firstName.
  arrayRec.set('fooMany', [3,2,1,4]);
  recs._storeIdsContentDidChange(0, 4, 4);

  // Check the insertion location of a record that should appear first.
  newRec = SC.Object.create({ guid: 5, firstName: "Adam", lastName: "Doe", age: 15 });
  location = recs._findInsertionLocation(newRec, 0, recs.get('length') - 1, sortByFirstName);

  equals(location, 0, "The insertion location should be");

  // Check the insertion location of a record that should appear in the middle.
  newRec = SC.Object.create({ guid: 5, firstName: "Farmer", lastName: "Doe", age: 95 });
  location = recs._findInsertionLocation(newRec, 0, recs.get('length') - 1, sortByFirstName);

  equals(location, 1, "The insertion location should be");

  newRec = SC.Object.create({ guid: 5, firstName: "Jen", lastName: "Doe", age: 95 });
  location = recs._findInsertionLocation(newRec, 0, recs.get('length') - 1, sortByFirstName);

  equals(location, 2, "The insertion location should be");

  newRec = SC.Object.create({ guid: 5, firstName: "Johnny", lastName: "Doe", age: 95 });
  location = recs._findInsertionLocation(newRec, 0, recs.get('length') - 1, sortByFirstName);

  equals(location, 3, "The insertion location should be");

  // Check the insertion location of a record that should appear last.
  newRec = SC.Object.create({ guid: 5, firstName: "Zues", lastName: "Doe", age: 95 });
  location = recs._findInsertionLocation(newRec, 0, recs.get('length') - 1, sortByFirstName);

  equals(location, 4, "The insertion location should be");
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/nested_store/chain.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// This file tests the initial state of the store when it is first created
// either independently or as a chained store.

var Rec = SC.Record.extend({
  
  title: SC.Record.attr(String),
  
  fired: NO,
  
  reset: function() { 
    this.fired = NO;
  },
  
  titleDidChange: function() {
    this.fired = YES;
  }.observes('title')
    
});

// ..........................................................
// SC.Store#chain - init
// 
module("SC.Store#chain - init");

test("initial setup for chained store", function() {
  var parent = SC.Store.create();
  var store  = parent.chain();
  
  ok(store !== parent, 'chain should return new child store');
  
  equals(store.get('parentStore'), parent, 'should have parentStore');
  
  equals(SC.typeOf(store.dataHashes), SC.T_HASH, 'should have dataHashes');
  parent.dataHashes.foo = 'bar';
  equals(store.dataHashes.foo, 'bar', 'dataHashes should inherit from parent');
    
  equals(SC.typeOf(store.revisions), SC.T_HASH, 'should have revisions');
  parent.revisions.foo = 'bar';
  equals(store.revisions.foo, 'bar', 'revisions should inherit from parent');

  equals(SC.typeOf(store.statuses), SC.T_HASH, 'should have statuses');
  parent.statuses.foo = 'bar';
  equals(store.statuses.foo, 'bar', 'statuses should inherit from parent');
  
  ok(!store.locks, 'should not have locks');
  ok(!store.chainedChanges, 'should not have chainedChanges');
  ok(!store.editables, 'should not have editables');
});

test("allow for custom subclasses of SC.NestedStore", function() {
  var parent = SC.Store.create();
  
  // We should get an exception if we specify a "subclass" that's not a class
  var ex = null;
  try {
    var bogus = parent.chain({}, "I am not a class");
  }
  catch(e) {
    ex = e;
  }
  ok(ex  &&  ex.message  &&  ex.message.indexOf('not a valid class') !== -1, 'chain should report that our bogus "class" it is not a valid class');
  
  // We should get an exception if we specify a class that's not a subclass of
  // SC.NestedStore
  ex = null;
  try {
    var bogus = parent.chain({}, SC.Store);
  }
  catch(e) {
    ex = e;
  }
  ok(ex  &&  ex.message  &&  ex.message.indexOf('is not a type of SC.NestedStore') !== -1, 'chain should report that our class needs to be a subclass of SC.NestedStore');
  
  
  // Our specified (proper!) subclass should be respected.
  var MyNestedStoreSubclass = SC.NestedStore.extend();
  var nested = parent.chain({}, MyNestedStoreSubclass);
  ok(nested.kindOf(MyNestedStoreSubclass), 'our nested store should be the SC.NestedStore subclass we specified');
}); 


// ..........................................................
// SPECIAL CASES
// 

test("chained store changes should propagate reliably", function() {
  var parent = SC.Store.create(), rec, store, rec2;

  SC.run(function() {
    parent.loadRecords(Rec, [{ title: "foo", guid: 1 }]);
  });
  
  rec = parent.find(Rec, 1);
  ok(rec && rec.get('title')==='foo', 'precond - base store should have record');

  // run several times to make sure this works reliably when used several 
  // times in the same app
  
  // trial 1
  SC.RunLoop.begin();
  store = parent.chain();
  rec2  = store.find(Rec, 1);
  ok(rec2 && rec2.get('title')==='foo', 'chain store should have record');
  
  rec.reset();
  rec2.set('title', 'bar');
  SC.RunLoop.end();
  
  equals(rec2.get('title'), 'bar', 'chained rec.title should changed');
  equals(rec.get('title'), 'foo', 'original rec.title should NOT change');
  equals(store.get('hasChanges'), YES, 'chained store.hasChanges');
  equals(rec.fired, NO, 'original rec.title should not have notified');
  
  SC.RunLoop.begin();
  rec.reset();
  store.commitChanges();
  store.destroy();
  SC.RunLoop.end();

  equals(rec.get('title'), 'bar', 'original rec.title should change');
  equals(rec.fired, YES, 'original rec.title should have notified');  


  // trial 2
  SC.RunLoop.begin();
  store = parent.chain();
  rec2  = store.find(Rec, 1);
  ok(rec2 && rec2.get('title')==='bar', 'chain store should have record');
  
  rec.reset();
  rec2.set('title', 'baz');
  SC.RunLoop.end();
  
  equals(rec2.get('title'), 'baz', 'chained rec.title should changed');
  equals(rec.get('title'), 'bar', 'original rec.title should NOT change');
  equals(store.get('hasChanges'), YES, 'chained store.hasChanges');
  equals(rec.fired, NO, 'original rec.title should not have notified');
  
  SC.RunLoop.begin();
  rec.reset();
  store.commitChanges();
  store.destroy();
  SC.RunLoop.end();

  equals(rec.get('title'), 'baz', 'original rec.title should change');
  equals(rec.fired, YES, 'original rec.title should have notified');  
  

  // trial 1
  SC.RunLoop.begin();
  store = parent.chain();
  rec2  = store.find(Rec, 1);
  ok(rec2 && rec2.get('title')==='baz', 'chain store should have record');
  
  rec.reset();
  rec2.set('title', 'FOO2');
  SC.RunLoop.end();
  
  equals(rec2.get('title'), 'FOO2', 'chained rec.title should changed');
  equals(rec.get('title'), 'baz', 'original rec.title should NOT change');
  equals(store.get('hasChanges'), YES, 'chained store.hasChanges');
  equals(rec.fired, NO, 'original rec.title should not have notified');
  
  SC.RunLoop.begin();
  rec.reset();
  store.commitChanges();
  store.destroy();
  SC.RunLoop.end();

  equals(rec.get('title'), 'FOO2', 'original rec.title should change');
  equals(rec.fired, YES, 'original rec.title should have notified');  
  
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/nested_store/commitChanges.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module, ok, equals, same, test */

// NOTE: The test below are based on the Data Hashes state chart.  This models
// the "commit" event in the NestedStore portion of the diagram.

var parent, store, child, storeKey, json, args;
module("SC.NestedStore#commitChanges", {
  setup: function() {
    SC.RunLoop.begin();

    parent = SC.Store.create();

    json = {
      string: "string",
      number: 23,
      bool:   YES
    };
    args = [];

    storeKey = SC.Store.generateStoreKey();

    store = parent.chain(); // create nested store
    child = store.chain();  // test multiple levels deep

    // override commitChangesFromNestedStore() so we can ensure it is called
    // save call history for later evaluation
    parent.commitChangesFromNestedStore =
    child.commitChangesFromNestedStore =
    store.commitChangesFromNestedStore = function(store, changes, force) {
      args.push({
        target: this,
        store: store,
        changes: changes,
        force: force
      });
    };

    SC.RunLoop.end();
  }
});

// ..........................................................
// BASIC STATE TRANSITIONS
//

function testStateTransition(shouldIncludeStoreKey, shouldCallParent) {

  // attempt to commit
  equals(store.commitChanges(), store, 'should return receiver');

  // verify result
  equals(store.storeKeyEditState(storeKey), SC.Store.INHERITED, 'data edit state');

  if (shouldCallParent === NO) {
    ok(!args || args.length===0, 'should not call commitChangesFromNestedStore');
  } else {
    equals(args.length, 1, 'should have called commitChangesFromNestedStore');

    var opts = args[0] || {}; // avoid exceptions
    equals(opts.target, parent, 'should have called on parent store');

    // verify if changes passed to callback included storeKey
    var changes = opts.changes;
    var didInclude = changes && changes.contains(storeKey);
    if (shouldIncludeStoreKey) {
      ok(didInclude, 'passed set of changes should include storeKey');
    } else {
      ok(!didInclude, 'passed set of changes should NOT include storeKey');
    }
  }

  equals(store.get('hasChanges'), NO, 'hasChanges should be cleared');
  ok(!store.chainedChanges || store.chainedChanges.length===0, 'should have empty chainedChanges set');
}

test("state = INHERITED", function() {

  // write in some data to parent
  parent.writeDataHash(storeKey, json);

  // check preconditions
  equals(store.storeKeyEditState(storeKey), SC.Store.INHERITED, 'precond - data edit state');

  testStateTransition(NO, NO);
});


test("state = LOCKED", function() {

  // write in some data to parent
  parent.writeDataHash(storeKey, json);
  parent.editables = null ; // manually force to lock state
  store.readDataHash(storeKey);

  // check preconditions
  equals(store.storeKeyEditState(storeKey), SC.Store.LOCKED, 'precond - data edit state');
  ok(!store.chainedChanges || !store.chainedChanges.contains(storeKey), 'locked record should not be in chainedChanges set');

  testStateTransition(NO, NO);
});

test("state = EDITABLE", function() {

  // write in some data to parent
  store.writeDataHash(storeKey, json);
  store.dataHashDidChange(storeKey);

  // check preconditions
  equals(store.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'precond - data edit state');
  ok(store.chainedChanges  && store.chainedChanges.contains(storeKey), 'editable record should be in chainedChanges set');

  testStateTransition(YES, YES);
});


// ..........................................................
// SPECIAL CASES
// 

test("commiting a changed record should immediately notify outstanding records in parent store", function() {

  var Rec = SC.Record.extend({

    fooCnt: 0,
    fooDidChange: function() { this.fooCnt++; }.observes('foo'),

    statusCnt: 0,
    statusDidChange: function() { this.statusCnt++; }.observes('status'),

    reset: function() { this.fooCnt = this.statusCnt = 0; },

    equals: function(fooCnt, statusCnt, str) {
      if (!str) str = '' ;
      equals(this.get('fooCnt'), fooCnt, str + ':fooCnt');
      equals(this.get('statusCnt'), statusCnt, str + ':statusCnt');
    }

  });

  SC.RunLoop.begin();

  var store = SC.Store.create();
  var prec  = store.createRecord(Rec, { foo: "bar", guid: 1 });

  var child = store.chain();
  var crec  = child.find(Rec, prec.get('id'));

  // check assumptions
  ok(!!crec, 'prerec - should find child record');
  equals(crec.get('foo'), 'bar', 'prerec - child record should have foo');

  // modify child record - should not modify parent
  prec.reset();
  crec.set('foo', 'baz');
  equals(prec.get('foo'), 'bar', 'should not modify parent before commit');
  prec.equals(0,0, 'before commitChanges');

  // commit changes - note: still inside runloop
  child.commitChanges();
  equals(prec.get('foo'), 'baz', 'should push data to parent');
  prec.equals(1,1, 'after commitChanges'); // should notify immediately

  SC.RunLoop.end();

  // should not notify again after runloop - nothing to do
  prec.equals(1,1,'after runloop ends - should not notify again');

});


test("Changes to relationships should propagate to the parent store.", function() {

  var MyApp = window.MyApp = SC.Object.create({
    store: SC.Store.create()
  });

  MyApp.Rec = SC.Record.extend({
    relatedChild: SC.Record.toOne('MyApp.RelatedRec', {
      inverse: 'relatedParent'
    }),

    relatedChildren: SC.Record.toMany('MyApp.RelatedRecs', {
      inverse: 'relatedParent'
    })
  });

  MyApp.RelatedRec = SC.Record.extend({
    relatedParent: SC.Record.toOne('MyApp.Rec', {
      inverse: 'relatedChild',
      isMaster: NO
    })
  });

  MyApp.RelatedRecs = SC.Record.extend({
    relatedParent: SC.Record.toOne('MyApp.Rec', {
      inverse: 'relatedChildren',
      isMaster: NO
    })
  });

  SC.RunLoop.begin();

  MyApp.store.loadRecord(MyApp.RelatedRec, { guid: 2, relatedParent: 1});
  MyApp.store.loadRecord(MyApp.RelatedRecs, { guid: 3, relatedParent: 1 });
  MyApp.store.loadRecord(MyApp.RelatedRecs, { guid: 4, relatedParent: 1 });
  MyApp.store.loadRecord(MyApp.Rec, { guid: 1, relatedChild: 2, relatedChildren: [3,4] });

  var primaryRec = MyApp.store.find(MyApp.Rec, 1);
  var primaryRelatedRec  = MyApp.store.find(MyApp.RelatedRec, 2);
  var primaryRelatedRecs1  = MyApp.store.find(MyApp.RelatedRecs, 3);
  var primaryRelatedRecs2  = MyApp.store.find(MyApp.RelatedRecs, 4);

  var nestedStore = MyApp.store.chain();
  var nestedRec = nestedStore.find(MyApp.Rec, primaryRec.get('id'));
  var nestedRelatedRec = nestedStore.find(MyApp.RelatedRec, primaryRelatedRec.get('id'));
  var nestedRelatedRecs1 = nestedStore.find(MyApp.RelatedRecs, primaryRelatedRecs1.get('id'));
  var nestedRelatedRecs2 = nestedStore.find(MyApp.RelatedRecs, primaryRelatedRecs2.get('id'));

  // check assumptions
  ok(!!nestedRec, 'Prior to nested changes should find primaryRec in nested store');
  ok(!!nestedRelatedRec, 'Prior to nested changes should find nestedRelatedRec in nested store');
  ok(!!nestedRelatedRecs1, 'Prior to nested changes should find nestedRelatedRecs1 in nested store');
  ok(!!nestedRelatedRecs2, 'Prior to nested changes should find nestedRelatedRecs2 in nested store');
  equals(primaryRec.get('relatedChild'), primaryRelatedRec, 'Prior to changes primaryRec relatedChild should be');
  equals(primaryRelatedRec.get('relatedParent'), primaryRec, 'Prior to changes primaryRelatedRec relatedParent should be');
  equals(primaryRelatedRecs1.get('relatedParent'), primaryRec, 'Prior to changes primaryRelatedRecs1 relatedParent should be');
  equals(primaryRelatedRecs2.get('relatedParent'), primaryRec, 'Prior to changes primaryRelatedRecs2 relatedParent should be');
  equals(primaryRec.get('status'), SC.Record.READY_CLEAN, 'Prior to changes primaryRec status should be READY_CLEAN');
  equals(primaryRelatedRec.get('status'), SC.Record.READY_CLEAN, 'Prior to changes primaryRelatedRec status should be READY_CLEAN');
  equals(primaryRelatedRecs1.get('status'), SC.Record.READY_CLEAN, 'Prior to changes primaryRelatedRecs1 status should be READY_CLEAN');
  equals(primaryRelatedRecs2.get('status'), SC.Record.READY_CLEAN, 'Prior to changes primaryRelatedRecs2 status should be READY_CLEAN');

  nestedRec.set('relatedChild', null);
  nestedRelatedRecs2.set('relatedParent', null);
  nestedRec.get('relatedChildren').popObject();

  // Modifying nested store record relationships should not modify primary store record relationships
  equals(primaryRec.get('relatedChild'), primaryRelatedRec, 'After nested changes primaryRec relatedChild should be');
  equals(primaryRelatedRec.get('relatedParent'), primaryRec, 'After nested changes primaryRelatedRec relatedParent should be');
  equals(primaryRelatedRecs1.get('relatedParent'), primaryRec, 'After nested changes primaryRelatedRecs1 relatedParent should be');
  equals(primaryRelatedRecs2.get('relatedParent'), primaryRec, 'After nested changes primaryRelatedRecs2 relatedParent should be');
  equals(primaryRec.get('status'), SC.Record.READY_CLEAN, 'After nested changes primaryRec status should be READY_CLEAN');
  equals(primaryRelatedRec.get('status'), SC.Record.READY_CLEAN, 'After nested changes primaryRelatedRec status should be READY_CLEAN');
  equals(primaryRelatedRecs1.get('status'), SC.Record.READY_CLEAN, 'After nested changes primaryRelatedRecs1 status should be READY_CLEAN');
  equals(primaryRelatedRecs2.get('status'), SC.Record.READY_CLEAN, 'After nested changes primaryRelatedRecs2 status should be READY_CLEAN');
  equals(nestedRec.get('relatedChild'), null, 'After nested changes nestedRec relatedChild should be');
  equals(nestedRelatedRec.get('relatedParent'), null, 'After nested changes nestedRelatedRec relatedParent should be');
  equals(nestedRelatedRecs1.get('relatedParent'), null, 'After nested changes nestedRelatedRecs1 relatedParent should be');
  equals(nestedRelatedRecs2.get('relatedParent'), null, 'After nested changes nestedRelatedRecs2 relatedParent should be');
  equals(nestedRec.get('status'), SC.Record.READY_DIRTY, 'After nested changes relatedChild status should be READY_DIRTY');
  equals(nestedRelatedRec.get('status'), SC.Record.READY_CLEAN, 'After nested changes nestedRelatedRec status should be READY_CLEAN');
  equals(nestedRelatedRecs1.get('status'), SC.Record.READY_CLEAN, 'After nested changes nestedRelatedRecs1 status should be READY_CLEAN');
  equals(nestedRelatedRecs2.get('status'), SC.Record.READY_CLEAN, 'After nested changes nestedRelatedRecs2 status should be READY_CLEAN');

  // commit changes - note: still inside runloop
  nestedStore.commitChanges();
  equals(primaryRec.get('relatedChild'), null, 'After commit changes primaryRec relatedChild should be');
  equals(primaryRelatedRec.get('relatedParent'), null, 'After commit changes primaryRelatedRec relatedParent should be');
  equals(primaryRelatedRecs1.get('relatedParent'), null, 'After commit changes primaryRelatedRecs1 relatedParent should be');
  equals(primaryRelatedRecs2.get('relatedParent'), null, 'After commit changes primaryRelatedRecs2 relatedParent should be');
  equals(primaryRec.get('status'), SC.Record.READY_DIRTY, 'After commit changes primaryRec status should be READY_DIRTY');
  equals(primaryRelatedRec.get('status'), SC.Record.READY_CLEAN, 'After commit changes primaryRelatedRec status should be READY_CLEAN');
  equals(primaryRelatedRecs1.get('status'), SC.Record.READY_CLEAN, 'After commit changes primaryRelatedRecs1 status should be READY_CLEAN');
  equals(primaryRelatedRecs2.get('status'), SC.Record.READY_CLEAN, 'After commit changes primaryRelatedRecs2 status should be READY_CLEAN');

  SC.RunLoop.end();

  delete window.MyApp;
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/nested_store/commitChangesFromNestedStore.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

var parent, store, child, storeKey, json;
module("SC.NestedStore#commitChangesFromNestedStore", {
  setup: function() {
    SC.RunLoop.begin();

    parent = SC.Store.create();

    json = {
      string: "string",
      number: 23,
      bool:   YES
    };

    storeKey = SC.Store.generateStoreKey();

    store = parent.chain();
    child = store.chain();  // test multiple levels deep

    // write basic status
    child.writeDataHash(storeKey, json, SC.Record.READY_DIRTY);
    child.dataHashDidChange(storeKey);
    child.changelog = SC.Set.create();
    child.changelog.add(storeKey);

    SC.RunLoop.end();
  }
});

test("copies changed data hashes, statuses, and revisions", function() {

  SC.RunLoop.begin();

  // verify preconditions
  equals(store.readDataHash(storeKey), null, 'precond - should not have data yet');
  ok(child.chainedChanges.contains(storeKey), 'precond - child changes should include storeKey');

  // perform action
  equals(store.commitChangesFromNestedStore(child, child.chainedChanges, NO), store, 'should return receiver');
  SC.RunLoop.end();

  // verify new status
  equals(store.readDataHash(storeKey), json, 'now should have json');
  equals(store.readStatus(storeKey), SC.Record.READY_DIRTY, 'now should have status');
  equals(store.revisions[storeKey], child.revisions[storeKey], 'now shoulave have revision from child');

});

test("adds lock on any items not already locked", function() {

  SC.RunLoop.begin();

  var storeKey2 = SC.Store.generateStoreKey();
  var json2 = { kind: "json2" };

  // verify preconditions
  store.readDataHash(storeKey);
  ok(store.locks[storeKey], 'precond - storeKey should have lock');
  ok(!store.locks[storeKey2], 'precond - storeKey2 should not have lock');

  // write another record into child store to commit changes.
  child.writeDataHash(storeKey2, json2, SC.Record.READY_DIRTY);
  child.dataHashDidChange(storeKey2);

  var changes = child.chainedChanges ;
  ok(changes.contains(storeKey), 'precond - child.chainedChanges should contain storeKey');
  ok(changes.contains(storeKey2), 'precond - child.chainedChanges should contain storeKey2');

  // now commit back to parent
  equals(store.commitChangesFromNestedStore(child, changes, NO), store, 'should return receiver');
  SC.RunLoop.end();

  // and verify that both have locks
  ok(store.locks[storeKey], 'storeKey should have lock after commit (actual: %@)'.fmt(store.locks[storeKey]));
  ok(store.locks[storeKey2], 'storeKey2 should have lock after commit (actual: %@)'.fmt(store.locks[storeKey2]));

});

test("adds items in chainedChanges to receiver chainedChanges", function() {

  SC.RunLoop.begin();

  var key1 = SC.Store.generateStoreKey();

  store.dataHashDidChange(key1);

  ok(child.chainedChanges.contains(storeKey), 'precond - child.chainedChanges should contain store key');

  equals(store.commitChangesFromNestedStore(child, child.chainedChanges, NO), store, 'should return receiver');
  SC.RunLoop.end();

  // changelog should merge nested store & existing
  ok(store.chainedChanges.contains(key1), 'chainedChanges should still contain key1');
  ok(store.chainedChanges.contains(storeKey), 'chainedChanges should also contain storeKey');
});

test("should set hasChanges to YES if has changes", function() {

  SC.RunLoop.begin();

  var changes = child.chainedChanges;
  ok(changes.length>0, 'precond - should have some changes in child');
  equals(store.get('hasChanges'), NO, 'precond - store should not have changes');

  store.commitChangesFromNestedStore(child, changes, NO);
  equals(store.get('hasChanges'), YES, 'store should now have changes');
});

test("should set hasChanges to NO if no changes", function() {

  SC.RunLoop.begin();

  child = store.chain() ; // get a new child store

  var changes = child.chainedChanges || SC.Set.create();
  ok(!changes || !changes.length, 'precond - should have not have changes in child');
  equals(store.get('hasChanges'), NO, 'precond - store should not have changes');

  store.commitChangesFromNestedStore(child, changes, NO);
  SC.RunLoop.end();

  equals(store.get('hasChanges'), NO, 'store should NOT now have changes');
});

// ..........................................................
// SPECIAL CASES
//

test("committing changes should chain back each step", function() {

  SC.RunLoop.begin();

  // preconditions
  equals(child.readDataHash(storeKey), json, 'precond - child should have data');
  equals(store.readDataHash(storeKey), null, 'precond - store should not have data');
  equals(parent.readDataHash(storeKey), null, 'precond - parent should not have data');

  // do commits
  child.commitChanges();

  equals(store.get('hasChanges'), YES, 'store should now have changes');
  equals(store.readDataHash(storeKey), json, 'store should now have json');

  store.commitChanges();
  equals(store.get('hasChanges'), NO, 'store should no longer have changes');
  equals(parent.readDataHash(storeKey), json, 'parent should now have json');
  SC.RunLoop.end();

});




})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/nested_store/core_methods.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp Sample */

var store, nestedStore, Application, dataSource;

module("SC.NestedStore Core Methods", {
  setup: function() {
    dataSource = SC.DataSource.create();
    
    Application = {};
    Application._nameDidChange = 0;
    
    Application.File = SC.Record.extend({ 
      
      nameDidChange: function(object, key) {
        Application._nameDidChange++;
      }.observes('name', 'url', 'isDirectory')
      
    });
    Application.FileDisk = SC.Record.extend({ });
    
    Application.Data = {
      
      "FileDisk": [
        { guid: '14', name: 'Main Drive', parent: null, children: null }
      ],
    
      "File": [
        { guid: '10', name: 'Home', url: '/emily_parker', isDirectory: true, parent: null, children: 'Collection'},
        { guid: '11', name: 'Documents', fileType: 'documents', url: '/emily_parker/Documents', isDirectory: true, parent: '10', children: 'Collection', createdAt: 'June 15, 2007', modifiedAt: 'October 21, 2007', filetype: 'directory', isShared: false},
        { guid: '137',name: 'Library', fileType: 'library', url: '/emily_parker/Library', isDirectory: true, parent: '10', children: 'Collection', createdAt: 'June 15, 2007', modifiedAt: 'October 21, 2007', filetype: 'directory', isShared: false},
        { guid: '12', name: 'Movies', fileType: 'movies', url: '/emily_parker/Movies', isDirectory: true, parent: '10', children: 'Collection', createdAt: 'June 15, 2007', modifiedAt: 'June 15, 2007', filetype: 'directory', isShared: true, sharedAt: 'October 15, 2007', sharedUntil: 'March 31, 2008', sharedUrl: '2fhty', isPasswordRequired: true},
        { guid: '134',name: 'Music', fileType: 'music', url: '/emily_parker/Music', isDirectory: true, parent: '10', children: 'Collection', createdAt: 'June 15, 2007', modifiedAt: 'June 15, 2007', filetype: 'directory', isShared: true, sharedAt: 'October 15, 2007', sharedUntil: 'March 31, 2008', sharedUrl: '2fhty', isPasswordRequired: true},
        { guid: '135',name: 'Pictures', fileType: 'pictures', url: '/emily_parker/Pictures', isDirectory: true, parent: '10', children: 'Collection', createdAt: 'June 15, 2007', modifiedAt: 'June 15, 2007', filetype: 'directory', isShared: true, sharedAt: 'October 15, 2007', sharedUntil: 'March 31, 2008', sharedUrl: '2fhty', isPasswordRequired: true},
        { guid: '13', name: 'Auto Insurance', fileType: 'folder', url: '/emily_parker/Documents/Auto%20Insurance', isDirectory: true, parent: '11', children: 'Collection', createdAt: 'June 15, 2007', modifiedAt: 'October 21, 2007', filetype: 'directory', isShared: false},
        { guid: '14', name: 'Birthday Invitation.pdf', fileType: 'file', url: '/emily_parker/Documents/Birthday%20Invitation', isDirectory: false, parent: '11', createdAt: 'October 17, 2007', modifiedAt: 'October 21, 2007', filetype: 'pdf', isShared: false},
        { guid: '136', name: 'Software', fileType: 'software', url: '/emily_parker/Software', isDirectory: true, parent: '10', children: 'Collection', createdAt: 'June 15, 2007', modifiedAt: 'June 15, 2007', filetype: 'directory', isShared: true, sharedAt: 'October 15, 2007', sharedUntil: 'March 31, 2008', sharedUrl: '2fhty', isPasswordRequired: true}
      ]
    };
    
    SC.RunLoop.begin();
    store = SC.Store.create({ name: 'Test nested store'} ).from(dataSource);
    for(var i in Application.Data) {
      store.loadRecords(Application[i], Application.Data[i]);
    }
    SC.RunLoop.end();
    
    // make sure RecordType by String can map
    window.Application = Application;
    
    nestedStore = store.chain();
  }    
});

test("Make sure that setting an attribute on a record will only notify respective observers once", function() {
  
  var file = nestedStore.find(Application.File, '14');
  Application._nameDidChange = 0 ;
  
  SC.RunLoop.begin();
  file.writeAttribute('name', 'My Great New Name');
  SC.RunLoop.end();
  
  equals(Application._nameDidChange, 1, 'observer was only fired once');

});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/nested_store/dataHashDidChange.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// NOTE: The test below are based on the Data Hashes state chart.  This models
// the "did_change" event in the NestedStore portion of the diagram.

var parent, store, child, storeKey, json;
module("SC.NestedStore#dataHashDidChange", {
  setup: function() {
    parent = SC.Store.create();
    
    json = {
      string: "string",
      number: 23,
      bool:   YES
    };
    
    storeKey = SC.Store.generateStoreKey();
    
    SC.RunLoop.begin();
    parent.writeDataHash(storeKey, json, SC.Record.READY_CLEAN);
    SC.RunLoop.end();
    
    parent.editables = null; // manually patch to setup test state
    
    store = parent.chain(); // create nested store
    child = store.chain();  // test multiple levels deep
  }
});

// ..........................................................
// BASIC STATE TRANSITIONS
// 


function testStateTransition(fromState, toState) {

  // verify preconditions
  equals(store.get('hasChanges'), NO, 'should not have changes');
  equals(store.storeKeyEditState(storeKey), fromState, 'precond - storeKey edit state');
  if (store.chainedChanges) {
    ok(!store.chainedChanges.contains(storeKey), 'changedChanges should NOT include storeKey');
  }

  var oldrev = store.revisions[storeKey];
  
  // perform action
  equals(store.dataHashDidChange(storeKey), store, 'should return receiver');

  // verify results
  equals(store.storeKeyEditState(storeKey), toState, 'store key edit state is in same state');

  // verify revision
  ok(oldrev !== store.revisions[storeKey], 'revisions should change. was: %@ - now: %@'.fmt(oldrev, store.revisions[storeKey]));
  ok(store.chainedChanges.contains(storeKey), 'changedChanges should now include storeKey');
  
  equals(store.get('hasChanges'), YES, 'should have changes');
} 

test("edit state = INHERITED, parent editable = NO", function() {

  // verify preconditions
  equals(parent.storeKeyEditState(storeKey), SC.Store.LOCKED, 'precond - parent store edit state is not EDITABLE');
  
  testStateTransition(SC.Store.INHERITED, SC.Store.LOCKED);
}) ;

test("edit state = INHERITED, parent editable = YES", function() {

  // verify preconditions
  parent.readEditableDataHash(storeKey);
  equals(parent.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'precond - parent store edit state is EDITABLE');

  testStateTransition(SC.Store.INHERITED, SC.Store.EDITABLE);
}) ;

test("edit state = LOCKED", function() {
  store.readDataHash(storeKey); // lock
  testStateTransition(SC.Store.LOCKED, SC.Store.LOCKED);
}) ;

test("edit state = EDITABLE", function() {
  store.readEditableDataHash(storeKey); // make editable
  testStateTransition(SC.Store.EDITABLE, SC.Store.EDITABLE);
}) ;

// ..........................................................
// SPECIAL CASES
// 

test("calling with array of storeKeys will edit all store keys", function() {
  
  var storeKeys = [storeKey, SC.Store.generateStoreKey()], idx ;
  store.dataHashDidChange(storeKeys, 2000) ;
  for(idx=0;idx<storeKeys.length;idx++) {
    equals(store.revisions[storeKeys[idx]], 2000, 'storeKey at index %@ should have new revision'.fmt(idx));
    ok(store.chainedChanges.contains(storeKeys[idx]), 'chainedChanges should include storeKey at index %@'.fmt(idx));
  }
});

test("marking change should update revision but leave lock alone", function() {
  parent.dataHashDidChange(storeKey); // make sure parent has a revision
  store.readDataHash(storeKey); // cause a lock
  store.dataHashDidChange(storeKey); // update revision
  
  equals(store.locks[storeKey], parent.revisions[storeKey], 'lock should have parent revision');
  ok(store.revisions[storeKey] !== parent.revisions[storeKey], 'revision should not match parent rev');  
});


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/nested_store/discardChanges.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// NOTE: The test below are based on the Data Hashes state chart.  This models
// the "discard" event in the NestedStore portion of the diagram.

var parent, store, child, storeKey, json, args;
module("SC.NestedStore#discardChanges", {
  setup: function() {
    SC.RunLoop.begin();

    parent = SC.Store.create();
    
    json = {
      string: "string",
      number: 23,
      bool:   YES
    };
    args = null;
    
    storeKey = SC.Store.generateStoreKey();

    parent.writeDataHash(storeKey, json, SC.Record.READY_CLEAN);
    parent.editables = null;
    
    store = parent.chain(); // create nested store
    child = store.chain();  // test multiple levels deep

    // commitChangesFromNestedStore() should never be called.  Capture info
    // about call.
    parent.commitChangesFromNestedStore =
    child.commitChangesFromNestedStore =
    store.commitChangesFromNestedStore = function(store, changes, force) {
      if (!args) args = [];
      args.push({ 
        target: this, 
        store: store, 
        changes: changes, 
        force: force 
      });
    };

    SC.RunLoop.end();
  }
});

// ..........................................................
// BASIC STATE TRANSITIONS
//

function testStateTransition() {

  // attempt to commit
  equals(store.discardChanges(), store, 'should return receiver');
  
  // verify result
  equals(store.storeKeyEditState(storeKey), SC.Store.INHERITED, 'data edit state');
  equals(store.get('hasChanges'), NO, 'hasChanges should be NO');
  equals(store.readDataHash(storeKey), json, 'data hash should return parent hash again');
  equals(store.readStatus(storeKey), parent.readStatus(storeKey), 'should return record status from parent');
  ok(!store.chainedChanges || !store.chainedChanges.length, 'should have no chainedChanges queued');
  
  // should NOT invoke commitChangesFromNestedStore
  equals(args, null, 'should not call commitChangesFromNestedStore');
}

test("state = INHERITED", function() {
  equals(store.storeKeyEditState(storeKey), SC.Store.INHERITED, 'precond - data edit state');
  testStateTransition();
});


test("state = LOCKED", function() {
  
  store.readDataHash(storeKey); // force to locked mode
  equals(store.storeKeyEditState(storeKey), SC.Store.LOCKED, 'precond - data edit state');
  testStateTransition();
});

test("state = EDITABLE", function() {
  
  // write in some data to store
  store.writeDataHash(storeKey, json);
  store.dataHashDidChange(storeKey);
  
  // check preconditions
  equals(store.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'precond - data edit state');
  ok(store.chainedChanges  && store.chainedChanges.contains(storeKey), 'editable record should be in chainedChanges set');

  testStateTransition();
});


// ..........................................................
// SPECIAL CASES
// 

// TODO: Add more special cases for SC.NestedStore#discardChanges

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/nested_store/readDataHash.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// NOTE: The test below are based on the Data Hashes state chart.  This models
// the "read" event in the NestedStore portion of the diagram.

var parent, store, child, storeKey, json;
module("SC.NestedStore#readDataHash", {
  setup: function() {
    parent = SC.Store.create();
    
    json = {
      string: "string",
      number: 23,
      bool:   YES
    };
    
    storeKey = SC.Store.generateStoreKey();

    parent.writeDataHash(storeKey, json, SC.Record.READY_CLEAN);
    parent.editables = null; // manually patch to setup test state
    
    store = parent.chain(); // create nested store
    child = store.chain();  // for deep nested
  }
});

// ..........................................................
// BASIC STATE TRANSITIONS
// 

test("data state=INHERITED, lockOnRead=YES, parent editable=NO", function() {
  // preconditions
  equals(store.get('lockOnRead'), YES, 'precond - lockOnRead should be YES');
  equals(store.storeKeyEditState(storeKey), SC.Store.INHERITED, 'precond - storeKey should be inherited from parent');
  var oldrev = store.revisions[storeKey]; // save old rev for testing later

  // perform read
  equals(store.readDataHash(storeKey), json, 'should return json');

  // verify
  equals(store.storeKeyEditState(storeKey), SC.Store.LOCKED, 'storeKey should be read-locked now');
  ok(store.dataHashes.hasOwnProperty(storeKey), 'should copy reference to json');

  // test revisions...
  equals(store.revisions[storeKey], oldrev, 'should not change revision');
  if (!SC.none(oldrev)) {
    ok(store.revisions.hasOwnProperty(storeKey), 'should copy reference to revision');
  }
});


test("data state=INHERITED, lockOnRead=NO, parent editable=NO", function() {
  // preconditions
  store.set('lockOnRead', NO);
  
  equals(store.get('lockOnRead'), NO, 'precond - lockOnRead should be NO');
  equals(store.storeKeyEditState(storeKey), SC.Store.INHERITED, 'precond - storeKey should be inherited from parent');
  var oldrev = store.revisions[storeKey]; // save old rev for testing later

  // perform read
  equals(store.readDataHash(storeKey), json, 'should return json');

  // verify
  equals(store.storeKeyEditState(storeKey), SC.Store.INHERITED, 'storeKey should still be inherited');
  ok(!store.dataHashes.hasOwnProperty(storeKey), 'should NOT copy reference to json');

  // test revisions...
  equals(store.revisions[storeKey], oldrev, 'should not change revision');
  if (!SC.none(oldrev)) {
    ok(store.revisions.hasOwnProperty(storeKey), 'should copy reference to revision');
  }
});


test("data state=INHERITED, lockOnRead=YES, parent editable=YES", function() {

  // preconditions
  
  // first, make parentStore record editable.  an editable record needs to be
  // cloned into nested stores on lock to avoid un-monitored edits
  parent.readEditableDataHash(storeKey);
  equals(parent.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'precond - parent storeKey should be editable');
  equals(store.get('lockOnRead'), YES, 'precond - lockOnRead should be YES');
  equals(store.storeKeyEditState(storeKey), SC.Store.INHERITED, 'precond - storeKey should be inherited from parent');
  var oldrev = store.revisions[storeKey]; // save old rev for testing later

  // perform read
  var ret = store.readDataHash(storeKey);
  same(ret, json, 'should return equivalent json object');
  ok(!(ret === json), 'should return clone of json instance not exact same instance');

  // verify new state
  equals(store.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'storeKey should be locked');
  ok(store.dataHashes.hasOwnProperty(storeKey), 'should have reference to json');

  // test revisions...
  equals(store.revisions[storeKey], oldrev, 'should not change revision');
  if (!SC.none(oldrev)) {
    ok(store.revisions.hasOwnProperty(storeKey), 'should copy reference to revision');
  }
});

test("data state=LOCKED", function() {
  
  // preconditions
  store.set('lockOnRead', YES); // make sure reading will lock
  var ret1 = store.readDataHash(storeKey);
  equals(store.storeKeyEditState(storeKey), SC.Store.LOCKED, 'precond - data state should be LOCKED');
  var oldrev = store.revisions[storeKey];
  
  // perform read
  var ret2 = store.readDataHash(storeKey);
  
  // verify
  equals(ret1, ret2, 'should read same data hash once locked');
  equals(store.storeKeyEditState(storeKey), SC.Store.LOCKED, 'should remain in locked state');

  // test revisions
  equals(store.revisions[storeKey], oldrev, 'should not change revision');
  if (!SC.none(oldrev)) {
    ok(store.revisions.hasOwnProperty(storeKey), 'should copy reference to revision');
  }
});

test("data state=EDITABLE", function() {
  
  // preconditions
  store.set('lockOnRead', YES); // make sure reading will lock
  var ret1 = store.readEditableDataHash(storeKey);
  equals(store.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'precond - data state should be EDITABLE');
  var oldrev = store.revisions[storeKey];
  
  // perform read
  var ret2 = store.readDataHash(storeKey);
  
  // verify
  equals(ret1, ret2, 'should read same data hash once editable');
  equals(store.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'should remain in editable state');

  // test revisions
  equals(store.revisions[storeKey], oldrev, 'should not change revision');
  if (!SC.none(oldrev)) {
    ok(store.revisions.hasOwnProperty(storeKey), 'should copy reference to revision');
  }
});

test("should return null when accessing an unknown storeKey", function() {
  equals(store.readDataHash(20000000), null, 'should return null for non-existent store key');
  equals(store.storeKeyEditState(20000000), SC.Store.LOCKED, 'should put into locked edit state');
});

// ..........................................................
// SPECIAL CASES
//

test("locking deep nested store when top-level parent is editable and middle store is inherited", function() {

  // first, make the parent store data hash editable
  json = parent.readEditableDataHash(storeKey);
  equals(parent.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'parent edit state should be EDITABLE');
  equals(store.storeKeyEditState(storeKey), SC.Store.INHERITED, 'middle store edit state should be INHERITED');
  equals(child.storeKeyEditState(storeKey), SC.Store.INHERITED, 'child store edit state should be INHERITED');
  
  // now read data hash from child, locking child
  var json2 = child.readDataHash(storeKey);
  equals(child.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'child store edit state should be locked after reading data');
  
  // now edit the root json and make sure it does NOT propogate.
  json.newItem = "bar";
  ok(child.readDataHash(storeKey).newItem !== 'bar', 'child json should not pick up edit from parent store since it is now locked');
});





})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/nested_store/readEditableDataHash.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// NOTE: The test below are based on the Data Hashes state chart.  This models
// the "read_editable" event in the NestedStore portion of the diagram.

var parent, store, storeKey, json;
module("SC.NestedStore#readEditableDataHash", {
  setup: function() {
    parent = SC.Store.create();
    
    json = {
      string: "string",
      number: 23,
      bool:   YES
    };
    
    storeKey = SC.Store.generateStoreKey();

    parent.writeDataHash(storeKey, json, SC.Record.READY_CLEAN);
    parent.editables = null ; // manually reset for testing state
    
    store = parent.chain();
  }
});

test("data state=INHERITED, parent editable = NO", function() {
  
  // test preconditions
  equals(parent.storeKeyEditState(storeKey), SC.Store.LOCKED, 'precond - parent edit state should be LOCKED');
  equals(store.storeKeyEditState(storeKey), SC.Store.INHERITED, 'precond - edit state should be INHERITED');
  var oldrev = store.revisions[storeKey] ;

  // perform read
  var ret = store.readEditableDataHash(storeKey);
  
  // validate
  same(ret, json, 'should return equivalent json object');
  ok(!(ret===json), 'should not return same json instance');
  
  equals(store.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'edit state should be editable');
  
  // should not change revisions, but should copy it...
  equals(store.revisions[storeKey], oldrev, 'should not change revision');
  if (!SC.none(oldrev)) {
    ok(store.revisions.hasOwnProperty(storeKey), 'should clone revision reference');
  }
});

test("data state=INHERITED, parent editable = YES", function() {
  
  // test preconditions
  parent.readEditableDataHash(storeKey);
  equals(parent.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'precond - parent edit state should be EDITABLE');
  equals(store.storeKeyEditState(storeKey), SC.Store.INHERITED, 'precond - edit state should be INHERITED');
  var oldrev = store.revisions[storeKey] ;

  // perform read
  var ret = store.readEditableDataHash(storeKey);
  
  // validate
  same(ret, json, 'should return equivalent json object');
  ok(!(ret===json), 'should not return same json instance');
  
  equals(store.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'edit state should be editable');
  
  // should not change revisions, but should copy it...
  equals(store.revisions[storeKey], oldrev, 'should not change revision');
  if (!SC.none(oldrev)) {
    ok(store.revisions.hasOwnProperty(storeKey), 'should clone revision reference');
  }
  
});

test("data state=LOCKED", function() {
  
  // test preconditions
  store.readDataHash(storeKey);
  equals(store.storeKeyEditState(storeKey), SC.Store.LOCKED, 'precond - edit state should be LOCKED');
  var oldrev = store.revisions[storeKey] ;

  // perform read
  var ret = store.readEditableDataHash(storeKey);
  
  // validate
  same(ret, json, 'should return equivalent json object');
  ok(!(ret===json), 'should not return same json instance');
  
  equals(store.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'edit state should be editable');
  
  // should not change revisions, but should copy it...
  equals(store.revisions[storeKey], oldrev, 'should not change revision');
  if (!SC.none(oldrev)) {
    ok(store.revisions.hasOwnProperty(storeKey), 'should clone revision reference');
  }
  
});

test("data state=EDITABLE", function() {
  
  // test preconditions
  json = store.readEditableDataHash(storeKey); // get editable json
  equals(store.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'precond - edit state should be EDITABLE');
  var oldrev = store.revisions[storeKey] ;

  // perform read
  var ret = store.readEditableDataHash(storeKey);
  
  // validate
  equals(ret, json, 'should return same editable json instance');
  
  equals(store.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'edit state should be editable');
  
  // should not change revisions, but should copy it...
  equals(store.revisions[storeKey], oldrev, 'should not change revision');
  if (!SC.none(oldrev)) {
    ok(store.revisions.hasOwnProperty(storeKey), 'should clone revision reference');
  }
  
});



})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/nested_store/removeDataHash.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// NOTE: The test below are based on the Data Hashes state chart.  This models
// the "remove" event in the NestedStore portion of the diagram.

var parent, store, child, storeKey, json;
module("SC.NestedStore#removeDataHash", {
  setup: function() {
    parent = SC.Store.create();
    
    json = {
      string: "string",
      number: 23,
      bool:   YES
    };
    
    storeKey = SC.Store.generateStoreKey();

    parent.writeDataHash(storeKey, json, SC.Record.READY_CLEAN);
    parent.editables = null; // manually patch to setup test state
    
    store = parent.chain(); // create nested store
    child = store.chain();  // test multiple levels deep
  }
});

// ..........................................................
// BASIC STATE TRANSITIONS
// 

// The transition from each base state performs the same operation, so just
// run the same test on each state.
function testRemoveDataHash() {
  var oldrev = store.revisions[storeKey];
  
  // perform test
  equals(store.removeDataHash(storeKey, SC.Record.DESTROYED_CLEAN), store, 'should return receiver');
  
  // verify
  equals(store.storeKeyEditState(storeKey), SC.Store.LOCKED, 'new edit state should be locked');
  
  equals(store.readDataHash(storeKey), null, 'should have NO json data');
  equals(store.readStatus(storeKey), SC.Record.DESTROYED_CLEAN, 'should have new status');

  equals(store.revisions[storeKey], oldrev, 'should not change revision');
  if (!SC.none(oldrev)) {
    ok(store.revisions.hasOwnProperty(storeKey), 'should clone reference to revision');
  }
}


test("edit state=INHERITED", function() {
  
  // test preconditions
  equals(store.storeKeyEditState(storeKey), SC.Store.INHERITED, 'precond - edit state should be inherited');
  
  testRemoveDataHash();
});

test("edit state=LOCKED", function() {
  
  // test preconditions
  store.readDataHash(storeKey);
  equals(store.storeKeyEditState(storeKey), SC.Store.LOCKED, 'precond - edit state should be locked');
  
  testRemoveDataHash();

});

test("edit state=EDITABLE", function() {
  
  // test preconditions
  store.readEditableDataHash(storeKey);
  equals(store.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'precond - edit state should be editable');
  
  testRemoveDataHash();

});

// ..........................................................
// REMOVE NON-EXISTING 
// 

test("remove a non-existing hash", function() {
  storeKey = SC.Store.generateStoreKey(); // new store key!
  equals(parent.readDataHash(storeKey), null, 'precond - parent should not have a data hash for store key yet');
  equals(store.storeKeyEditState(storeKey), SC.Store.INHERITED, 'precond - edit status should be inherited');
  
  // perform write
  equals(store.removeDataHash(storeKey, SC.Record.DESTROYED_CLEAN), store, 'should return receiver');
  
  // verify change
  equals(store.storeKeyEditState(storeKey), SC.Store.LOCKED, 'new status should be locked');
  equals(store.readDataHash(storeKey), null, 'should still be null');
  equals(store.readStatus(storeKey), SC.Record.DESTROYED_CLEAN, 'should have new record status');
});

// ..........................................................
// PROPOGATING TO NESTED STORES
// 

test("change should propogate to child if child edit state = INHERITED", function() {

  // verify preconditions
  equals(child.storeKeyEditState(storeKey), SC.Store.INHERITED, 'precond - child edit state should be INHERITED');

  // perform change
  store.removeDataHash(storeKey, SC.Record.DESTROYED_CLEAN);
  
  // verify
  same(child.readDataHash(storeKey), null, 'child should pick up change');
  equals(parent.readDataHash(storeKey), json, 'parent should still have old json');
  
  equals(child.readStatus(storeKey), SC.Record.DESTROYED_CLEAN, 'child should pick up new status');
  equals(parent.readStatus(storeKey), SC.Record.READY_CLEAN, 'parent should still have old status');

});


function testLockedOrEditableChild() {
  // perform change
  store.removeDataHash(storeKey, SC.Record.DESTROYED_CLEAN);
  
  // verify
  same(child.readDataHash(storeKey), json, 'child should NOT pick up change');
  equals(parent.readDataHash(storeKey), json, 'parent should still have old json');
  
  equals(child.readStatus(storeKey), SC.Record.READY_CLEAN, 'child should pick up new status');
  equals(parent.readStatus(storeKey), SC.Record.READY_CLEAN, 'parent should still have old status');
}


test("change should not propogate to child if child edit state = LOCKED", function() {

  // verify preconditions
  child.readDataHash(storeKey);
  equals(child.storeKeyEditState(storeKey), SC.Store.LOCKED, 'precond - child edit state should be LOCKED');

  testLockedOrEditableChild();
});

test("change should not propogate to child if child edit state = EDITABLE", function() {

  // verify preconditions
  child.readEditableDataHash(storeKey);
  equals(child.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'precond - child edit state should be EDITABLE');

  testLockedOrEditableChild();
});










})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/nested_store/writeDataHash.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// NOTE: The test below are based on the Data Hashes state chart.  This models
// the "write" event in the NestedStore portion of the diagram.

var parent, store, child, storeKey, json;
module("SC.NestedStore#writeDataHash", {
  setup: function() {
    parent = SC.Store.create();
    
    json = {
      string: "string",
      number: 23,
      bool:   YES
    };
    
    storeKey = SC.Store.generateStoreKey();

    parent.writeDataHash(storeKey, json, SC.Record.READY_CLEAN);
    parent.editables = null; // manually patch to setup test state
    
    store = parent.chain(); // create nested store
    child = store.chain();  // test multiple levels deep
  }
});

// ..........................................................
// BASIC STATE TRANSITIONS
// 

// The transition from each base state performs the same operation, so just
// run the same test on each state.
function testWriteDataHash() {
  var oldrev = store.revisions[storeKey];
  
  // perform test
  var json2 = { foo: "bar" };
  equals(store.writeDataHash(storeKey, json2, SC.Record.READY_NEW), store, 'should return receiver');
  
  // verify
  equals(store.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'new edit state should be editable');
  
  equals(store.readDataHash(storeKey), json2, 'should have new json data hash');
  equals(store.readStatus(storeKey), SC.Record.READY_NEW, 'should have new status');

  equals(store.revisions[storeKey], oldrev, 'should not change revision');
  if (!SC.none(oldrev)) {
    ok(store.revisions.hasOwnProperty(storeKey), 'should clone reference to revision');
  }
}


test("edit state=INHERITED", function() {
  
  // test preconditions
  equals(store.storeKeyEditState(storeKey), SC.Store.INHERITED, 'precond - edit state should be inherited');
  
  testWriteDataHash();
});

test("edit state=LOCKED", function() {
  
  // test preconditions
  store.readDataHash(storeKey);
  equals(store.storeKeyEditState(storeKey), SC.Store.LOCKED, 'precond - edit state should be locked');
  
  testWriteDataHash();

});

test("edit state=EDITABLE", function() {
  
  // test preconditions
  store.readEditableDataHash(storeKey);
  equals(store.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'precond - edit state should be editable');
  
  testWriteDataHash();

});

// ..........................................................
// WRITING NEW VS EXISTING
// 

test("writing a new hash", function() {
  storeKey = SC.Store.generateStoreKey(); // new store key!
  equals(parent.readDataHash(storeKey), null, 'precond - parent should not have a data hash for store key yet');
  equals(store.storeKeyEditState(storeKey), SC.Store.INHERITED, 'precond - edit status should be inherited');
  
  // perform write
  equals(store.writeDataHash(storeKey, json, SC.Record.READY_NEW), store, 'should return receiver');
  
  // verify change
  equals(store.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'new status should be editable');
  equals(store.readDataHash(storeKey), json, 'should match new json');
  equals(store.readStatus(storeKey), SC.Record.READY_NEW, 'should have new record status');
});

// ..........................................................
// PROPOGATING TO NESTED STORES
// 

test("change should propogate to child if child edit state = INHERITED", function() {

  // verify preconditions
  equals(child.storeKeyEditState(storeKey), SC.Store.INHERITED, 'precond - child edit state should be INHERITED');

  // perform change
  var json2 = { version: 2 };
  store.writeDataHash(storeKey, json2, SC.Record.READY_NEW);
  
  // verify
  same(child.readDataHash(storeKey), json2, 'child should pick up change');
  equals(parent.readDataHash(storeKey), json, 'parent should still have old json');
  
  equals(child.readStatus(storeKey), SC.Record.READY_NEW, 'child should pick up new status');
  equals(parent.readStatus(storeKey), SC.Record.READY_CLEAN, 'parent should still have old status');

});


function testLockedOrEditableChild() {
  // perform change
  var json2 = { version: 2 };
  store.writeDataHash(storeKey, json2, SC.Record.READY_NEW);
  
  // verify
  same(child.readDataHash(storeKey), json, 'child should NOT pick up change');
  equals(parent.readDataHash(storeKey), json, 'parent should still have old json');
  
  equals(child.readStatus(storeKey), SC.Record.READY_CLEAN, 'child should pick up new status');
  equals(parent.readStatus(storeKey), SC.Record.READY_CLEAN, 'parent should still have old status');
}


test("change should not propogate to child if child edit state = LOCKED", function() {

  // verify preconditions
  child.readDataHash(storeKey);
  equals(child.storeKeyEditState(storeKey), SC.Store.LOCKED, 'precond - child edit state should be LOCKED');

  testLockedOrEditableChild();
});

test("change should not propogate to child if child edit state = EDITABLE", function() {

  // verify preconditions
  child.readEditableDataHash(storeKey);
  equals(child.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'precond - child edit state should be EDITABLE');

  testLockedOrEditableChild();
});










})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/query/builders.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// This file tests the initial state of the store when it is first created
// either independently or as a chained store.

// ..........................................................
// UTILITIES
//

var TestRecord = SC.Record.extend();
var TestRecord2 = SC.Record.extend();

function queryEquals(q, location, recordType, conditions, extra, desc) {
  if (desc===undefined && typeof extra === 'string') {
    desc = extra;  extra = undefined ;
  }
  if (!desc) desc = '';

  ok(!!q, desc + ': should have a query');
  equals(q.get('isFrozen'), YES, desc + ": should be frozen");

  if (q) {
    if (location) {
      equals(q.get('location'), location, desc + ": should have location");
    }

    if (recordType && recordType.isEnumerable) {
      same(q.get('recordTypes'), recordType, desc + ': should have recordTypes (plural)');
    } else {
      equals(q.get('recordType'), recordType, desc + ': should have recordType (singular)');
    }

    equals(q.get('conditions'), conditions, desc + ': should have conditions');

    if (extra) {
      for (var key in extra) {
        if (!extra.hasOwnProperty(key)) continue;
        equals(q.get(key), extra[key], desc + ': should have extra key ' + key);
      }
    }
  }
}

// ..........................................................
// BASIC TESTS
//

// The local() and remote() builder methods are very similar.  This will
// perform the same basic tests on both of them.  If you add a builder for a
// new type of location, you can just call this function again with your new
// location
function performBasicTests(methodName, loc) {

  module("SC.Query.%@()".fmt(methodName), {
    setup: function() {
      window.TestRecord = TestRecord;
      window.TestRecord2 = TestRecord2;
    },

    teardown: function() {
      window.TestRecord = window.TestRecord2 = null; // cleanup
    }
  });

  function invokeWith() {
    return SC.Query[methodName].apply(SC.Query, arguments);
  }

  test("basic query with just record type", function() {
    var q, q1, q2, q3, q4;

    // local
    q = invokeWith(TestRecord);
    queryEquals(q, loc, TestRecord, null, 'first query');

    q1 = invokeWith(TestRecord);
    equals(q1, q, 'second call should return cached value');

    // using string for record type name should work
    q2 = invokeWith("TestRecord");
    equals(q2, q, 'queryFor with string should return cached value');

    // using an array of a single item should be treated as a single item
    q3 = invokeWith([TestRecord]);
    equals(q3, q, 'queryFor([TestRecord]) should return cached value');

    // ditto w/ strings
    q4 = invokeWith(['TestRecord']);
    equals(q4, q, 'queryFor(["TestRecord"]) with string should return cached value');

  });

  test("query with multiple recordtypes", function() {

    var types = [TestRecord, TestRecord2],
        q1, q2, a3, q4, q5, set;

    // create first query
    q1 = invokeWith(types);
    queryEquals(q1, loc, types, null, 'first query');

    // try again - should get cache
    q2 = invokeWith(types);
    equals(q2, q1, 'second queryFor call should return cached value');

    // try again - different order
    q3 = invokeWith([TestRecord2, TestRecord]);
    equals(q3, q1, 'queryFor with different order of record types should return same cached value');

    // try again - using a set
    set = SC.Set.create().add(TestRecord).add(TestRecord2);
    q4  = invokeWith(set);
    equals(q4, q1, 'should return cached query even if using an enumerable for types');

    // try again using strings
    q5 = invokeWith('TestRecord TestRecord2'.w());
    equals(q5, q1, 'should return cached query even if string record names are used');
  });

  test("query with record type and conditions", function() {

    var q1, q2, q3, q4, q5, q6, q7;

    q1 = invokeWith(TestRecord, 'foobar');
    queryEquals(q1, loc, TestRecord, 'foobar', 'first query');

    q2 = invokeWith(TestRecord, 'foobar');
    equals(q2, q1, 'second call to queryFor(TestRecord, foobar) should return cached instance');

    q3 = invokeWith(TestRecord2, 'foobar');
    queryEquals(q3, loc, TestRecord2, 'foobar', 'query(TestRecord2, foobar)');
    ok(q3 !== q1, 'different recordType same conditions should return new query');

    q4 = invokeWith(TestRecord, 'baz');
    queryEquals(q4, loc, TestRecord, 'baz', 'query(TestRecord2, baz)');
    ok(q4 !== q1, 'different conditions should return new query');

    q5 = invokeWith(TestRecord, 'baz');
    equals(q5, q4, 'second call for different conditions should return cache');
  });

  test("query with record types and conditions hash", function() {

    var q = invokeWith([TestRecord, TestRecord2], {});
    queryEquals(q, loc, [TestRecord, TestRecord2], null, 'first query');

  });

  test("query with no record type and with conditions", function() {
    var q1, q2;

    q1 = invokeWith(null, 'foobar');
    queryEquals(q1, loc, SC.Record, 'foobar', 'first query');

    q2 = invokeWith(null, 'foobar');
    equals(q2, q1, 'should return cached value');
  });

  test("query with recordtype, conditions, and parameters hash", function() {
    var opts  = { opt1: 'bar', opt2: 'baz' },
        q1, q2;

    q1 = invokeWith(TestRecord, 'foo', opts);
    queryEquals(q1, loc, TestRecord, 'foo', { parameters: opts }, 'first query');

    q2 = invokeWith(TestRecord, 'foo', opts);
    ok(q1 !== q2, 'second call to queryFor with opts cannot be cached');
    queryEquals(q1, loc, TestRecord, 'foo', { parameters: opts }, 'second query');
  });

  test("query with recordtype, conditions, and parameters array", function() {
    var opts  = ['foo', 'bar'],
        q1, q2;

    q1 = invokeWith(TestRecord, 'foo', opts);
    queryEquals(q1, loc, TestRecord, 'foo', { parameters: opts }, 'first query should include parameters prop');

    q2 = invokeWith(TestRecord, 'foo', opts);
    ok(q1 !== q2, 'second call to queryFor with opts cannot be cached');
    queryEquals(q1, loc, TestRecord, 'foo', { parameters: opts }, 'second query');
  });

  test("passing query object", function() {

    var local = SC.Query.local(TestRecord),
        remote = SC.Query.remote(TestRecord),
        q;

    q = invokeWith(local);
    if (loc === SC.Query.LOCAL) {
      equals(q, local, 'invoking with local query should return same query');
    } else {
      ok(q !== local, 'invoke with local query should return new instance');
    }
    equals(q.get('location'), loc, 'query should have expected location');

    q = invokeWith(remote);
    if (loc === SC.Query.REMOTE) {
      equals(q, remote, 'invoking with remote query should return same query');
    } else {
      ok(q !== remote, 'invoke with remote query should return new instance');
    }
    equals(q.get('location'), loc, 'query should have expected location');
  });

  test("no options (matches everything)", function() {
    var q1, q2;

    q1 = invokeWith();
    queryEquals(q1, loc, SC.Record, null, 'first query - matches everything');

    q2 = invokeWith();
    equals(q2, q1, 'should return same cached query');

  });


}

performBasicTests('local', SC.Query.LOCAL);
performBasicTests('remote', SC.Query.REMOTE);

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/query/compare.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// test parsing of query string
var store, storeKey, rec1, rec2, rec3, rec4, rec5, MyApp, q;
module("SC.Query comparison of records", {
  setup: function() {

    SC.RunLoop.begin();

    // setup dummy app and store
    MyApp = SC.Object.create({
      store: SC.Store.create()
    });

    MyApp.Address = SC.Record.extend({});

    // setup a dummy model
    MyApp.Foo = SC.Record.extend({
      address: SC.Record.toOne(MyApp.Address, { nested: true })
    });

    // load some data
    MyApp.store.loadRecords(MyApp.Foo, [
      { guid: 1, firstName: "John", lastName: "Doe", year: 1974, address: { guid: 2, street: "2 Street" } },
      { guid: 2, firstName: "Jane", lastName: "Doe", year: 1975, address: { guid: 1, street: "1 Street" } },
      { guid: 3, firstName: "Emily", lastName: "Parker", year: 1975, active: null },
      { guid: 4, firstName: "Johnny", lastName: "Cash", active: false },
      { guid: 5, firstName: "Bert", lastName: "Berthold", active: true }
    ]);

    SC.RunLoop.end();

    rec1 = MyApp.store.find(MyApp.Foo,1);
    rec2 = MyApp.store.find(MyApp.Foo,2);
    rec3 = MyApp.store.find(MyApp.Foo,3);
    rec4 = MyApp.store.find(MyApp.Foo,4);
    rec5 = MyApp.store.find(MyApp.Foo,5);
    rec6 = MyApp.store.createRecord(MyApp.Foo, { firstName: "Clark", lastName: "Douglas", active: true });
    rec7 = MyApp.store.createRecord(MyApp.Foo, { firstName: "Amy", lastName: "Simmons", active: true });
    rec8 = MyApp.store.createRecord(MyApp.Foo, { firstName: "Fred", lastName: "Chambers", active: false });
    rec9 = MyApp.store.createRecord(MyApp.Foo, { firstName: "Mari", lastName: "Chambers", active: false });
    rec10 = MyApp.store.createRecord(MyApp.Foo, { firstName: "Glenn", lastName: "Armour", active: true });
    rec11 = MyApp.store.createRecord(MyApp.Foo, { firstName: "Jake", lastName: "Timmons", active: true });
    rec12 = MyApp.store.createRecord(MyApp.Foo, { firstName: "John", lastName: "Fitzgerald", active: true });
    rec13 = MyApp.store.createRecord(MyApp.Foo, { firstName: "Carly", lastName: "Anderson", active: true });
    rec14 = MyApp.store.createRecord(MyApp.Foo, { firstName: "Clark", lastName: "Thompson", active: true });
    rec15 = MyApp.store.createRecord(MyApp.Foo, { firstName: "Indi", lastName: "Karish", active: true });
    rec16 = MyApp.store.createRecord(MyApp.Foo, { firstName: "Yi Jia", lastName: "Li", active: true });
    rec17 = MyApp.store.createRecord(MyApp.Foo, { firstName: "Marcel", lastName: "Frontenac", active: true });
    rec18 = MyApp.store.createRecord(MyApp.Foo, { firstName: "Amie", lastName: "Frontenac", active: true });
    rec19 = MyApp.store.createRecord(MyApp.Foo, { firstName: "Amelie", lastName: "Auguste", active: true });
    rec20 = MyApp.store.createRecord(MyApp.Foo, { firstName: "Percy", lastName: "Douglas", active: true });

    q = SC.Query.create();
  }
});


// ..........................................................
// TESTS
//

test("parse() should work with conditions = null", function(){
  q.parse();
});

test("building the order", function() {
  // undefined orderBy
  q.orderBy = null;
  q.parse();
  equals(q._order.length, 0, 'order should be empty');

  // empty orderBy
  q.orderBy = "";
  q.parse();
  equals(q._order.length, 0, 'order should be empty');

  // single property
  q.orderBy = "firstName";
  q.parse();
  equals(q._order[0].propertyName,'firstName', 'propertyName should be firstName');

  // more properties
  q.orderBy = "lastName, firstName";
  q.parse();
  equals(q._order[0].propertyName,'lastName', 'propertyName should be lastName');
  equals(q._order[1].propertyName,'firstName', 'propertyName should be firstName');

  // more properties with direction
  q.orderBy = "lastName, firstName, year DESC";
  q.parse();
  equals(q._order[0].propertyName,'lastName', 'propertyName should be lastName');
  ok(!q._order[0].descending, 'descending should be false');
  equals(q._order[1].propertyName,'firstName', 'propertyName should be firstName');
  ok(!q._order[1].descending, 'descending should be false');
  equals(q._order[2].propertyName,'year', 'propertyName should be year');
  ok(q._order[2].descending, 'descending should be true');
});

test("no order should result in comparison by guid", function() {
  q.orderBy = null;
  q.parse();
  equals(q.compare(rec1,rec2), -1, 'guid 1 should be before guid 2');
});

/**
  This test was added to prove new code that switched from ordering by guid
  if there is no orderBy property on the query to ordering by storeKey if
  there is no orderBy property.  The reason is that new records that haven't
  been committed may not have a guid and therefore comparing null to null
  would result in the order changing slightly in Chrome when the array length
  grew over 10 items long.  For some reason if every comparison in the sort
  returns 0, the first item and second item swap places and then the new first
  and the middle item swap places (or vice versa).  If you get objectAt(0) on
  this type of RecordArray, it cycles between three different values.

  See it in action in Chrome 17.0 on Mac:

  > [0,1,2,3,4,5,6,7,8,9].sort(function(a,b) { return 0; })
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  > [0,1,2,3,4,5,6,7,8,9,10].sort(function(a,b) { return 0; })
    [5, 0, 2, 3, 4, 1, 6, 7, 8, 9, 10]
    // WTF?  So the next time the RecordArray flushes its array will be
    // [5, 0, 2, 3, 4, 1, 6, 7, 8, 9, 10] and it keeps changing each flush.
  > [5, 0, 2, 3, 4, 1, 6, 7, 8, 9, 10].sort(function(a,b) { return 0; })
    [1, 5, 2, 3, 4, 0, 6, 7, 8, 9, 10]
*/
test("storeKeys should maintain order between repeat calls to orderStoreKeys even if the array is longer than 10 items and the matching records have no ids", function() {
  var records,
      storeKeysSorted1,
      storeKeysSorted2,
      storeKeys;

  q.orderBy = null;
  q.parse();

  records = MyApp.store.find(MyApp.Foo);
  records.flush();

  storeKeys = records.get('storeKeys');
  storeKeysSorted1 = SC.Query.orderStoreKeys(records.get('storeKeys'), q, MyApp.store).copy();
  storeKeysSorted2 = SC.Query.orderStoreKeys(records.get('storeKeys'), q, MyApp.store).copy();
  ok(storeKeysSorted1.isEqual(storeKeysSorted2), 'Each time you call orderStoreKeys, it should return the same order if the storeKeys haven\'t changed');
});

test("comparing non existent properties", function() {
  q.orderBy = "year";
  q.parse();
  equals(q.compare(rec5,rec1), -1, 'null should be before 1974');
});

test("comparing null and boolean properties", function() {
  q.orderBy = "active";
  q.parse();
  equals(q.compare(rec3,rec4), -1, 'null should be before false');
  equals(q.compare(rec4,rec5), -1, 'false should be before true');
});

test("comparing number properties", function() {
  q.orderBy = "year";
  q.parse();
  equals(q.compare(rec1,rec2), -1, '1974 should be before 1975');

  q.orderBy = "year DESC";
  q.parse();
  equals(q.compare(rec1,rec2), 1, '1974 should be after 1975 with DESC');
});


test("comparing string properties", function() {
  q.orderBy = "firstName";
  q.parse();
  equals(q.compare(rec1,rec2), 1, 'John should be after Jane');

  q.orderBy = "firstName DESC";
  q.parse();
  equals(q.compare(rec1,rec2), -1, 'John should be before Jane with DESC');
});

test("comparing by equal properties should use guid for order", function() {
  q.orderBy = "lastName";
  q.parse();
  equals(q.compare(rec1,rec2), -1, 'guid 1 should be before guid 2');
});

test("specifying a custom orderBy comparison function", function() {
  var usedCustomFunction = NO;
  q.orderBy = function(rec1, rec2) {
    // We'll be explicit about our use of a custom comparison function, in
    // addition to returning later years first.
    usedCustomFunction = YES;
    return SC.compare(rec2.get('year'), rec1.get('year'));
  };
  q.parse();
  equals(q.compare(rec1,rec2), 1, 'guid 2 should be before guid 1');
  equals(usedCustomFunction, YES, 'we should have used our custom comparison function');
});

test("compare by custom query comparison", function(){
  var usedQueryComparison = NO;
  SC.Query.registerComparison('firstName', function (r1, r2) {
    usedQueryComparison = YES;
    return SC.compare(r2, r1);
  });
  q.orderBy = 'firstName';
  q.parse();
  equals(q.compare(rec1,rec2), -1, 'Jane should be after John');
  equals(usedQueryComparison, YES, 'we should have used our query comparison function');
});

test('comparing through association', function(){
  q.orderBy = 'address.street'
  q.parse();
  equals(q.compare(rec1,rec2), 1, 'guid 2 should be before guid 1');
});

test('comparing through association with custom comparison', function(){
  SC.Query.registerComparison('address.street', function (r1, r2) {
    return SC.compare(r1, r2);
  });
  q.orderBy = 'address.street';
  q.parse();
  equals(q.compare(rec1,rec2), 1, 'guid 2 should be before guid 1');
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/query/contains.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */
 
// test parsing of query string
var store, storeKey, foo1, foo2, bar1, bar2, baz, barChild, MyApp, q;
module("SC.Query comparison of records", {
  setup: function() {
    
    SC.RunLoop.begin();
    
    // setup dummy app and store
    MyApp = SC.Object.create({
      store: SC.Store.create()
    });
    
    // setup a dummy model
    MyApp.Foo = SC.Record.extend();
    MyApp.Bar = SC.Record.extend();
    MyApp.BarChild = MyApp.Bar.extend();
    MyApp.Baz = SC.Record.extend();
    
    // load some data
    MyApp.store.loadRecords(MyApp.Foo, [
      { guid: 1, firstName: "John", lastName: "Doe", year: 1974 },
      { guid: 2, firstName: "Jane", lastName: "Doe", year: 1975 }
    ]);
    
    MyApp.store.loadRecords(MyApp.Bar, [
      { guid: 3, firstName: "Emily", lastName: "Parker", year: 1975, active: null },
      { guid: 4, firstName: "Johnny", lastName: "Cash", active: false }
    ]);
    
    MyApp.store.loadRecords(MyApp.Baz, [
      { guid: 5, firstName: "Bert", lastName: "Berthold", active: true }
    ]);

    MyApp.store.loadRecords(MyApp.BarChild, [
      { guid: 6, firstName: "Bert", lastName: "Ernie", active: true }
    ]);
    
    SC.RunLoop.end();
    
    foo1 = MyApp.store.find(MyApp.Foo,1);
    foo2 = MyApp.store.find(MyApp.Foo,2);
    bar1 = MyApp.store.find(MyApp.Bar,3);
    bar2 = MyApp.store.find(MyApp.Bar,4);
    barChild = MyApp.store.find(MyApp.BarChild, 6);
    baz  = MyApp.store.find(MyApp.Baz,5);
    
  },
  
  teardown: function() {
    MyApp = foo1 = foo2 = bar1 = bar2 = baz = barChild = q = null;
  }
});

// ..........................................................
// BASIC TESTS
// 

test("should only contain records matching recordType or recordTypes", function() {
  
  q = SC.Query.create({ recordType: MyApp.Foo });
  equals(q.contains(foo1), YES, 'q with recordType=Foo should contain record of type Foo');
  equals(q.contains(bar1), NO, 'q with recordType=Foo should NOT contain record of type Bar');
  equals(q.contains(barChild), NO, 'q with recordType=Foo should NOT contain record of type BarChild');
  
  equals(q.contains(baz),  NO, 'q with recordType=Foo should NOT contain record of type Baz');
  
  q = SC.Query.create({ recordTypes: [MyApp.Foo, MyApp.Bar] });
  equals(q.contains(foo1), YES, 'q with recordTypes=Foo,Bar should contain record of type Foo');
  equals(q.contains(bar1), YES, 'q with recordTypes=Foo,Bar should contain record of type Bar');
  equals(SC.kindOf(barChild, MyApp.Bar), YES, 'SC.kindOf(barChild, MyApp.Bar)');
  
  equals(q.contains(barChild), YES, 'q with recordTypes=Foo,Bar should contain record of type BarChild');

  equals(q.contains(baz),  NO, 'q with recordTypes=Foo,Bar should NOT contain record of type Baz');

  q = SC.Query.create();
  equals(q.contains(foo1), YES, 'no recordType should contain record of type Foo');
  equals(q.contains(bar1), YES, 'no recordType should contain record of type Foo');
  equals(q.contains(barChild), YES, 'no recordType should contain record of type BarChild');
  equals(q.contains(baz), YES, 'no recordType should contain record of type Foo');
  
});

test("should only contain records within parent scope, if one is defined", function() {
  
  q = SC.Query.create({ scope: SC.Set.create().add(foo1).add(bar1) });
  equals(q.contains(foo1), YES, 'scope=[foo1,bar1] should return YES for foo1');
  equals(q.contains(foo2), NO, 'scope=[foo1,bar1] should return NO for foo2');
  equals(q.contains(bar1), YES, 'scope=[bar1] should return YES for bar1');
  equals(q.contains(bar2), NO, 'scope=[foo1,bar1] should return NO for bar2');
});

test("should evaluate query against record", function() {
  q = SC.Query.create({ 
    conditions: "firstName = {firstName}", 
    parameters: { firstName: 'Bert' }
  });
  
  equals(q.contains(bar2), NO, 'q(firstName=Bert) should return NO for bar[firstName=Johnny]');
  equals(q.contains(baz), YES, 'q(firstName=Bert) should return YES for baz[firstName=Bert]');
  equals(q.contains(barChild), YES, 'q(firstName=Bert) should return YES for barChild[firstName=Bert]');

  var p  = { firstName: "Johnny" };
  equals(q.contains(bar2, p), YES, 'q(firstName=Johnny) should return YES for bar[firstName=Johnny]');
  equals(q.contains(baz, p), NO, 'q(firstName=Johnny) should return NO for baz[firstName=Bert]');
  equals(q.contains(barChild, p), NO, 'q(firstName=Johnny) should return NO for barChild[firstName=Bert]');
  
});

test("should consider recordType + query conditions", function() {
  q = SC.Query.create({
    conditions: "firstName = {firstName}",
    recordType: MyApp.Bar,
    parameters: { firstName: "Bert" }
  });
  
  equals(q.contains(bar1), NO, 'should not contain bar1 (wrong firstName)');
  equals(q.contains(bar2), NO, 'should not contain bar2 (wrong firstName)');
  equals(q.contains(barChild), YES, 'should contain barChild');
  equals(q.contains(baz), NO, 'should contain baz (wrong type)');
  
});



})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/query/containsRecordTypes.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */
 
// test parsing of query string
var store, storeKey, rec1, rec2, rec3, rec4, rec5, MyApp, q;

module("SC.Query#containsRecordTypes", {
  setup: function() {
    MyApp = SC.Object.create();
    
    MyApp.Contact  = SC.Record.extend();
    MyApp.Person   = MyApp.Contact.extend(); // person is a type of contact
    MyApp.Group    = SC.Record.extend() ; // NOT a subclass
    MyApp.Foo      = SC.Record.extend();
    
  },
  
  teardown: function() { MyApp = null ; }
});

test("comparing a single record type", function() {
  var set, q;
  
  q = SC.Query.create({ recordType: MyApp.Contact });
  set = SC.Set.create().add(MyApp.Contact);
  equals(q.containsRecordTypes(set), YES, 'should return YES when set includes recordType');
  
  set = SC.Set.create().add(MyApp.Person);
  equals(q.containsRecordTypes(set), YES, 'should return YES when set include subclass of recordType');
  
  set = SC.Set.create().add(MyApp.Group);
  equals(q.containsRecordTypes(set), NO, 'should return NO when set include unrelated of recordType');

  set = SC.Set.create().add(MyApp.Group).add(MyApp.Contact);
  equals(q.containsRecordTypes(set), YES, 'should return YES when set includes  recordType along with others');
  
});

test("comparing a multiple record type", function() {
  var set, q;
  
  q = SC.Query.create({ recordTypes: [MyApp.Contact, MyApp.Group] });

  set = SC.Set.create().add(MyApp.Contact);
  equals(q.containsRecordTypes(set), YES, 'should return YES when set includes one of recordTypes');

  set = SC.Set.create().add(MyApp.Group);
  equals(q.containsRecordTypes(set), YES, 'should return YES when set includes one of recordTypes');
  
  set = SC.Set.create().add(MyApp.Person);
  equals(q.containsRecordTypes(set), YES, 'should return YES when set include subclass of recordTypes'); 
  
  set = SC.Set.create().add(MyApp.Group).add(MyApp.Foo);
  equals(q.containsRecordTypes(set), YES, 'should return YES when set includes  recordType along with others');
  
});


test("comparing with no recordType set", function() {
  var set, q;
  
  // NOTE: no recordType or recordTypes
  q = SC.Query.create({  });

  set = SC.Set.create().add(MyApp.Contact);
  equals(q.containsRecordTypes(set), YES, 'should always return YES');

  set = SC.Set.create().add(MyApp.Group);
  equals(q.containsRecordTypes(set), YES, 'should always return YES');
  
  set = SC.Set.create().add(MyApp.Person);
  equals(q.containsRecordTypes(set), YES, 'should always return YES');
  
  set = SC.Set.create().add(MyApp.Group).add(MyApp.Foo);
  equals(q.containsRecordTypes(set), YES, 'should always return YES');
  
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/query/copy.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */
 
// test parsing of query string
module("SC.Query#copy");

test("basic copy", function() {
  var q=  SC.Query.create({
    conditions: "foo = bar",
    parameters: { foo: "bar" },
    orderBy: "foo",
    recordType: SC.Record,
    recordTypes: [SC.Record],
    location: SC.Query.REMOTE,
    scope: SC.CoreSet.create()
  }).freeze();
  
  var keys = 'conditions orderBy recordType recordTypes parameters location scope'.w();
  var copy = q.copy();
  
  equals(copy.isFrozen, NO, 'copy should not be frozen');
  keys.forEach(function(key) {
    equals(copy.get(key), q.get(key), 'copy.%@ should = original.%@'.fmt(key, key));
  }, this);
  
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/query/evaluation.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// test parsing of query string
var q;
module("SC.Query evaluation", {
  setup: function() {  
    q = SC.Query.create();
  }
});


// ..........................................................
// PRIMITIVES
// 

test("should evaluate all primitives", function() {
  
  // null
  q.conditions = "null";
  q.parse();
  ok(q._tokenTree.evaluate() === null, 'null should be null');
  
  // undefined
  q.conditions = "undefined";
  q.parse();
  ok(q._tokenTree.evaluate() === undefined, 'undefined should be undefined');
  
  // true
  q.conditions = "true";
  q.parse();
  ok(q._tokenTree.evaluate() === true, 'true should be true');
  
  // false
  q.conditions = "false";
  q.parse();
  ok(q._tokenTree.evaluate() === false, 'false should be false');
  
  // integer
  q.conditions = "1";
  q.parse();
  ok(q._tokenTree.evaluate() === 1, '1 should be 1');
  
  // float
  q.conditions = "1.5";
  q.parse();
  ok(q._tokenTree.evaluate() === 1.5, '1.5 should be 1.5');
  
  // string
  q.conditions = "'Hyperion'";
  q.parse();
  ok(q._tokenTree.evaluate() === 'Hyperion', "'Hyperion' should be 'Hyperion'");
  
});

// ..........................................................
// COMPARATORS
// 

test("should evaluate all comparators", function() {
  
  q.conditions = "true = true";
  q.parse();
  ok(q._tokenTree.evaluate() === true, 'true = true should be true');
  
  q.conditions = "true = false";
  q.parse();
  ok(q._tokenTree.evaluate() === false, 'true = false should be false');
  
  q.conditions = "false != true";
  q.parse();
  ok(q._tokenTree.evaluate() === true, 'false != true should be true');
  
  q.conditions = "1 < 1.2";
  q.parse();
  ok(q._tokenTree.evaluate() === true, '1 < 1.2 should be true');
  
  q.conditions = "1.1 <= 1.2";
  q.parse();
  ok(q._tokenTree.evaluate() === true, '1.1 <= 1.2 should be true');
  
  q.conditions = "1.2 <= 1.2";
  q.parse();
  ok(q._tokenTree.evaluate() === true, '1.2 <= 1.2 should be true');
  
  q.conditions = "1.1 > 1.2";
  q.parse();
  ok(q._tokenTree.evaluate() === false, '1.1 > 1.2 should be false');
  
  q.conditions = "1.3 >= 1.2";
  q.parse();
  ok(q._tokenTree.evaluate() === true, '1.3 >= 1.2 should be true');
  
  q.conditions = "'Tea pot' BEGINS_WITH 'Tea'";
  q.parse();
  ok(q._tokenTree.evaluate() === true, "'Tea pot' BEGINS_WITH 'Tea' should be true");
  
  q.conditions = "'Tea pot' BEGINS_WITH 'Coffee'";
  q.parse();
  ok(q._tokenTree.evaluate() === false, "'Tea pot' BEGINS_WITH 'Coffee' should be false");
  
  q.conditions = "'Tea pot' ENDS_WITH 'a pot'";
  q.parse();
  ok(q._tokenTree.evaluate() === true, "'Tea pot' ENDS_WITH 'a pot' should be true");
  
  q.conditions = "'Tea pot' ENDS_WITH 'a cup'";
  q.parse();
  ok(q._tokenTree.evaluate() === false, "'Tea pot' ENDS_WITH 'a cup' should be false");

  q.conditions = "'baguette fille bouteille fée' ENDS_WITH 'ille'";
  q.parse();
  ok(q._tokenTree.evaluate() === false, "'baguette fille bouteille fée' ENDS_WITH 'ille' should be false");

  q.conditions = "'baguette fille bouteille' ENDS_WITH 'ille'";
  q.parse();
  ok(q._tokenTree.evaluate() === true, "'baguette fille bouteille' ENDS_WITH 'ille' should be true");

  q.conditions = "'fée' ENDS_WITH 'ille'";
  q.parse();
  ok(q._tokenTree.evaluate() === false, "'fée' ENDS_WITH 'ille' should be false");

  q.conditions = "'fille baguette bouteílle' ENDS_WITH 'ille'";
  q.parse();
  ok(q._tokenTree.evaluate() === false, "'fille baguette bouteílle' ENDS_WITH 'ille' should be false");

  q.conditions = "'fille baguette bouteílle' ENDS_WITH 'ílle'";
  q.parse();
  ok(q._tokenTree.evaluate() === true, "'fille baguette bouteílle' ENDS_WITH 'ílle' should be true");
  
  q.conditions = "'Tea pot' CONTAINS 'Tea pot'";
  q.parse();
  ok(q._tokenTree.evaluate() === true, "'Tea pot' CONTAINS 'Tea pot' should be true");
  
  q.conditions = "'Tea pot' CONTAINS 'Tea'";
  q.parse();
  ok(q._tokenTree.evaluate() === true, "'Tea pot' CONTAINS 'Tea' should be true");
  
  q.conditions = "'Tea pot' CONTAINS 'pot'";
  q.parse();
  ok(q._tokenTree.evaluate() === true, "'Tea pot' CONTAINS 'pot' should be true");
  
  q.conditions = "'Tea pot' CONTAINS 'a po'";
  q.parse();
  ok(q._tokenTree.evaluate() === true, "'Tea pot' CONTAINS 'a po' should be true");
  
  q.conditions = "'Tea pot' CONTAINS 'a cup'";
  q.parse();
  ok(q._tokenTree.evaluate() === false, "'Tea pot' CONTAINS 'a cup' should be false");
  
  q.conditions = "{myTeapot} CONTAINS 'Tea'";
  q.parse();
  ok(q._tokenTree.evaluate(null,{myTeapot: ['Tea','pot']}) === true, "['Tea', 'pot'] CONTAINS 'Tea' should be true");

  q.conditions = "{myTeapot} CONTAINS 'pot'";
  q.parse();
  ok(q._tokenTree.evaluate(null,{myTeapot: ['Tea','pot']}) === true, "['Tea', 'pot'] CONTAINS 'pot' should be true");

  q.conditions = "{myTeapot} CONTAINS 'coffee'";
  q.parse();
  ok(q._tokenTree.evaluate(null,{myTeapot: ['Tea','pot']}) === false, "['Tea', 'pot'] CONTAINS 'coffee' should be false");
  
  q.conditions = "'Tea pot' MATCHES {myCup}";
  q.parse();
  ok(q._tokenTree.evaluate(null,{myCup: /a\sp/}) === true, "'Tea pot' MATCHES /a\\sp/ should be true");
  
  q.conditions = "'Tea pot' MATCHES {myCup}";
  q.parse();
  ok(q._tokenTree.evaluate(null,{myCup: (/ap/)}) === false, "'Tea pot' MATCHES /ap/ should be false");
  
  q.conditions = "'Veterano' ANY {drinks}";
  q.parse();
  ok(q._tokenTree.evaluate(null,{drinks: ['Tempranillo','Bacardi','Veterano']}) === true, "'Veterano' should be in ['Tempranillo','Bacardi','Veterano']");
  
  q.conditions = "'Veterano' ANY {drinks}";
  q.parse();
  ok(q._tokenTree.evaluate(null,{drinks: ['soda','water']}) === false, "'Veterano' should not be in ['soda','water']");
}); 
  

// ..........................................................
// BOOLEAN OPERATORS
// 

test("boolean operators should work", function() {
  
  // here we see a limitation of the tree builder:
  // boolean values like true are considered to be a primitive
  // and boolean operators only accept comparators as arguments,
  // so "true AND true" will not parse into a tree!
  // hence i used a small hack here
  
  q.conditions = "1=1 AND 1=1";
  q.parse();
  ok(q._tokenTree.evaluate() === true, "true AND true should be true");
  
  q.conditions = "1=1 AND 1=2";
  q.parse();
  ok(q._tokenTree.evaluate() === false, "true AND false should be false");
  
  q.conditions = "1=1 OR 1=1";
  q.parse();
  ok(q._tokenTree.evaluate() === true, "true OR true should be true");
  
  q.conditions = "1=2 OR 1=2";
  q.parse();
  ok(q._tokenTree.evaluate() === false, "false OR false should be false");
  
  q.conditions = "NOT 1=1";
  q.parse();
  ok(q._tokenTree.evaluate() === false, "NOT true should be false");
  
});  
  

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/query/evaluation_of_records.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// test parsing of query string
var store, storeKey, rec1, rec2, rec3, rec4, rec5, rec6, rec7, MyApp, q;
module("SC.Query evaluation of records", {
  setup: function() {
    
    SC.RunLoop.begin();
    
    // setup dummy app and store
    MyApp = SC.Object.create({
      store: SC.Store.create()
    });
    
    // setup dummy models
    MyApp.Animal = SC.Record.extend({});
    MyApp.Person = SC.Record.extend({
      pet: SC.Record.toOne(MyApp.Animal, { nested: true })
    });

    // load some data
    MyApp.store.loadRecords(MyApp.Person, [
      { guid: 1, firstName: "John", lastName: "Doe", married: true },
      { guid: 2, firstName: "Jane", lastName: "Doe", married: false },
      { guid: 3, firstName: "Emily", lastName: "Parker", bornIn: 1975, married: true },
      { guid: 4, firstName: "Johnny", lastName: "Cash", married: true },
      { guid: 5, firstName: "Bert", lastName: "Berthold", married: true },
      { guid: 6, firstName: "Ronald", lastName: "Fitzgerald", parents: { father: "Frank", mother: "Nancy" }},
      { guid: 7, firstName: "Jack", lastName: "Dimpleton", pet: { guid: 1, name: "Fido" } }
    ]);
    
    rec1 = MyApp.store.find(MyApp.Person,1);
    rec2 = MyApp.store.find(MyApp.Person,2);
    rec3 = MyApp.store.find(MyApp.Person,3);
    rec4 = MyApp.store.find(MyApp.Person,4);
    rec5 = MyApp.store.find(MyApp.Person,5);
    rec6 = MyApp.store.find(MyApp.Person,6);
    rec7 = MyApp.store.find(MyApp.Person,7);
    
    SC.RunLoop.end();
    
    q = SC.Query.create();
  }
});


// ..........................................................
// RECORD PROPERTIES
// 

test("should get record properties correctly", function() {

  q.conditions = "fakeProp = 'Foo'";
  q.parse();
  equals(q.contains(rec1), false, 'John should not match: fakeProp = "Foo"');
  
  q.conditions = "firstName = 'John'";
  q.parse();
  equals(q.contains(rec1), true, 'John should match: firstName = "John"');
  equals(q.contains(rec2), false, 'Jane should not match: firstName = "John"');

  q.conditions = "parents.father = 'Frank'";
  q.parse();
  equals(q.contains(rec6), true, "Ronald should match: parents.father = 'Frank'");
  equals(q.contains(rec1), false, "John should not match: parents.father = 'Frank'");

  q.conditions = "pet.name = 'Fido'";
  q.parse();
  equals(q.contains(rec7), true, "Jack should match: pet.name = 'Fido'");
  equals(q.contains(rec6), false, "Ronald should not match: pet.name = 'Fido'");

  q.conditions = "pet.parentRecord.firstName = 'Jack'";
  q.parse();
  equals(q.contains(rec7), true, "Jack should match: pet.parentRecord.firstName = 'Jack'");
  equals(q.contains(rec6), false, "Ronald should not match: pet.parentRecord.firstName = 'Jack'");

  q.conditions = "lastName BEGINS_WITH firstName";
  q.parse();
  equals(q.contains(rec5), true, 'Bert Berthold should match: lastName BEGINS_WITH firstName');
  equals(q.contains(rec2), false, 'Jane Doe should not match: lastName BEGINS_WITH firstName');
  
  q.conditions = "lastName CONTAINS firstName";
  q.parse();
  equals(q.contains(rec5), true, 'Bert Berthold should match: lastName CONTAINS firstName');
  equals(q.contains(rec2), false, 'Jane Doe should not match: lastName CONTAINS firstName');

}); 


test("should handle undefined record properties correctly", function() {
  
  q.conditions = "bornIn = 1975";
  q.parse();
  equals(q.contains(rec3), true, 'record with bornIn set should match');
  equals(q.contains(rec2), false, 'record without bornIn set should not match');
  
  q.conditions = "bornIn = undefined";
  q.parse();
  equals(q.contains(rec3), false, 'record with bornIn set different to null should not match');
  equals(q.contains(rec2), true, 'record without bornIn set should match');
  
}); 

test("should handle boolean correctly", function() {
  
  q.conditions = "married = true";
  q.parse();
  equals(q.contains(rec1), true, 'record with married set should match');
  equals(q.contains(rec2), false, 'record without married set should not match');
  
});
  

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/query/expandedRecordTypes.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */
 
// test parsing of query string
var store, storeKey, rec1, rec2, rec3, rec4, rec5, MyApp, q;

module("SC.Query#containsRecordTypes", {
  setup: function() {
    MyApp = SC.Object.create();
    
    MyApp.Contact  = SC.Record.extend();
    MyApp.Person   = MyApp.Contact.extend(); // person is a type of contact
    MyApp.Group    = SC.Record.extend() ; // NOT a subclass
    MyApp.Foo      = SC.Record.extend();
    
  },
  
  teardown: function() { 
    MyApp = null ; 
    SC.Record.subclasses = SC.Set.create(); // reset subclasses
  }
});

test("single recordType with no subclasses", function() {
  var q = SC.Query.local(MyApp.Foo),
      expected = SC.CoreSet.create().add(MyApp.Foo);
      
  same(q.get('expandedRecordTypes'), expected, 'should have only MyApp.Foo');
});

test("multiple recordTypes with no subclasses", function() {
  var q = SC.Query.local([MyApp.Foo, MyApp.Group]),
      expected = SC.CoreSet.create().add(MyApp.Foo).add(MyApp.Group);
      
  same(q.get('expandedRecordTypes'), expected, 'should have MyApp.Foo, MyApp.Group');
});

test("base SC.Record", function() {
  var q = SC.Query.local(),
      expected = SC.CoreSet.create().addEach([SC.Record, MyApp.Foo, MyApp.Group, MyApp.Contact, MyApp.Person]);
      
  same(q.get('expandedRecordTypes'), expected, 'should have all defined types');
});

test("type with subclass", function() {
  var q = SC.Query.local(MyApp.Contact),
      expected = SC.CoreSet.create().addEach([MyApp.Contact, MyApp.Person]);
      
  same(q.get('expandedRecordTypes'), expected, 'should have all Contact and Person');
});

test("adding new type should invalidate property", function() {
  var q = SC.Query.local(MyApp.Contact),
      expected = SC.CoreSet.create().addEach([MyApp.Contact, MyApp.Person]);    
  same(q.get('expandedRecordTypes'), expected, 'precond - should have all Contact and Person');

  var Bar = MyApp.Person.extend(); // add a new record
  expected.add(Bar);
  same(q.get('expandedRecordTypes'), expected, 'should have all Contact, Person, and Bar');
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/query/parse.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// test parsing of query string
var q;
module("SC.Query parsing", {
  setup: function() {
    q = SC.Query.create();
  }
});


// ..........................................................
// TOKENIZER
// 

test("should recognize all primitives", function() {
  // PROPERTY
  q.conditions = "what_to_do_now";
  q.parse();
  ok(q._tokenList.length == 1, 'list should have one token');
  equals(q._tokenList[0].tokenType, 'PROPERTY', 'type should be PROPERTY');
  equals(q._tokenList[0].tokenValue, 'what_to_do_now', 'value should be what_to_do_now');
  
  // PROPERTY - one character
  q.conditions = "a";
  q.parse();
  ok(q._tokenList.length == 1, 'list should have one token');
  equals(q._tokenList[0].tokenType, 'PROPERTY', 'type should be PROPERTY');
  equals(q._tokenList[0].tokenValue, 'a', 'value should be "a"');
  
  // BOOLEAN VALUE - false
  q.conditions = "false";
  q.parse();
  ok(q._tokenList.length == 1, 'list should have one token');
  equals(q._tokenList[0].tokenType, 'false', 'type should be false');
  equals(q._tokenList[0].tokenValue, 'false', 'value should be false');
  
  // BOOLEAN VALUE - true
  q.conditions = "true";
  q.parse();
  ok(q._tokenList.length == 1, 'list should have one token');
  equals(q._tokenList[0].tokenType, 'true', 'type should be true');
  equals(q._tokenList[0].tokenValue, 'true', 'value should be true');
  
  // NULL
  q.conditions = "null";
  q.parse();
  ok(q._tokenList.length == 1, 'list should have 2 tokens');
  equals(q._tokenList[0].tokenType, 'null', 'type should be null');

  // NULL
  q.conditions = "undefined";
  q.parse();
  ok(q._tokenList.length == 1, 'list should have 2 tokens');
  equals(q._tokenList[0].tokenType, 'undefined', 'type should be undefined');
  
  // NUMBER - integer
  q.conditions = "1234";
  q.parse();
  ok(q._tokenList.length == 1, 'list should have one token');
  equals(q._tokenList[0].tokenType, 'NUMBER', 'type should be NUMBER');
  equals(q._tokenList[0].tokenValue, 1234, 'value should be 1234');
  
  // NUMBER - float
  q.conditions = "12.34";
  q.parse();
  ok(q._tokenList.length == 1, 'list should have one token');
  equals(q._tokenList[0].tokenType, 'NUMBER', 'type should be NUMBER');
  equals(q._tokenList[0].tokenValue, 12.34, 'value should be 12.34');

  // NUMBER - negative
  q.conditions = "-1";
  q.parse();
  ok(q._tokenList.length == 1, 'list should have one token');
  equals(q._tokenList[0].tokenType, 'NUMBER', 'type should be NUMBER');
  equals(q._tokenList[0].tokenValue, -1, 'value should be -1');

  // NUMBER - negative float
  q.conditions = "-1.234";
  q.parse();
  ok(q._tokenList.length == 1, 'list should have one token');
  equals(q._tokenList[0].tokenType, 'NUMBER', 'type should be NUMBER');
  equals(q._tokenList[0].tokenValue, -1.234, 'value should be -1.234');
  
  // STRING - single quoted
  q.conditions = "'ultravisitor'";
  q.parse();
  ok(q._tokenList.length == 1, 'list should have one token');
  equals(q._tokenList[0].tokenType, 'STRING', 'type should be STRING');
  equals(q._tokenList[0].tokenValue, 'ultravisitor', 'value should be ultravisitor');
  
  // STRING - double quoted
  q.conditions = '"Feed me weird things"';
  q.parse();
  ok(q._tokenList.length == 1, 'list should have one token');
  equals(q._tokenList[0].tokenType, 'STRING', 'type should be STRING');
  equals(q._tokenList[0].tokenValue, 'Feed me weird things', 'value should be Feed me weird things');

  // STRING - empty
  q.conditions = "''";
  q.parse();
  ok(q._tokenList.length == 1, 'list should have one token');
  equals(q._tokenList[0].tokenType, 'STRING', 'type should be STRING');
  equals(q._tokenList[0].tokenValue, '', 'value should be ""');
  
  // PARAMETER
  q.conditions = "{my_best_friends}";
  q.parse();
  ok(q._tokenList.length == 1, 'list should have one token');
  equals(q._tokenList[0].tokenType, 'PARAMETER', 'type should be PARAMETER');
  equals(q._tokenList[0].tokenValue, 'my_best_friends', 'value should be my_best_friends');
  
  // WILD CARD
  q.conditions = "%@";
  q.parse();
  ok(q._tokenList.length == 1, 'list should have one token');
  equals(q._tokenList[0].tokenType, '%@', 'type should be %@');
  equals(q._tokenList[0].tokenValue, 0, 'value should be 0');
  
  // PARENTHESES
  q.conditions = "()";
  try {
    q.parse();
  } catch (e) {
    // ignore - we don't care that it doesn't parse - just testing tokens
  }
  
  ok(q._tokenList.length == 2, 'list should have two tokens');
  equals(q._tokenList[0].tokenType, 'OPEN_PAREN', 'type should be OPEN_PAREN');
  equals(q._tokenList[1].tokenType, 'CLOSE_PAREN', 'type should be CLOSE_PAREN');
  
  // COMPARATORS
  q.conditions = "= != < <= > >= BEGINS_WITH ENDS_WITH CONTAINS ANY MATCHES TYPE_IS";
  try {
    q.parse();
  } catch(e1) {
    // ignore - we don't care that it doesn't parse - just testing tokens
  }
  equals(q._tokenList.length, 12, 'q._tokenList.length');
  
  equals(q._tokenList[0].tokenType, '=', 'type should be =');
  equals(q._tokenList[0].tokenValue, '=', 'value should be =');
  
  equals(q._tokenList[1].tokenType, '!=', 'type should be !=');
  equals(q._tokenList[1].tokenValue, '!=', 'value should be !=');
  
  equals(q._tokenList[2].tokenType, '<', 'type should be <');
  equals(q._tokenList[2].tokenValue, '<', 'value should be <');
  
  equals(q._tokenList[3].tokenType, '<=', 'type should be <=');
  equals(q._tokenList[3].tokenValue, '<=', 'value should be <=');
  
  equals(q._tokenList[4].tokenType, '>', 'type should be >');
  equals(q._tokenList[4].tokenValue, '>', 'value should be >');
  
  equals(q._tokenList[5].tokenType, '>=', 'type should be >=');
  equals(q._tokenList[5].tokenValue, '>=', 'value should be >=');
  
  equals(q._tokenList[6].tokenType, 'BEGINS_WITH', 'type should be BEGINS_WITH');
  equals(q._tokenList[6].tokenValue, 'BEGINS_WITH', 'value should be BEGINS_WITH');
  
  equals(q._tokenList[7].tokenType, 'ENDS_WITH', 'type should be ENDS_WITH');
  equals(q._tokenList[7].tokenValue, 'ENDS_WITH', 'value should be ENDS_WITH');
  
  equals(q._tokenList[8].tokenType, 'CONTAINS', 'type should be CONTAINS');
  equals(q._tokenList[8].tokenValue, 'CONTAINS', 'value should be CONTAINS');
  
  equals(q._tokenList[9].tokenType, 'ANY', 'type should be ANY');
  equals(q._tokenList[9].tokenValue, 'ANY', 'value should be ANY');
  
  equals(q._tokenList[10].tokenType, 'MATCHES', 'type should be MATCHES');
  equals(q._tokenList[10].tokenValue, 'MATCHES', 'value should be MATCHES');
  
  equals(q._tokenList[11].tokenType, 'TYPE_IS', 'type should be TYPE_IS');
  equals(q._tokenList[11].tokenValue, 'TYPE_IS', 'value should be TYPE_IS');
  
  // BOOLEAN OPERATORS
  q.conditions = "AND OR NOT";
  try {
    q.parse();
  } catch(e2) {
    // ignore - we don't care that it doesn't parse - just testing tokens
  }
  ok(q._tokenList.length == 3, 'list should have 3 tokens');
  equals(q._tokenList[0].tokenType, 'AND', 'type should be AND');
  equals(q._tokenList[0].tokenValue, 'AND', 'value should be AND');
  equals(q._tokenList[1].tokenType, 'OR', 'type should be OR');
  equals(q._tokenList[1].tokenValue, 'OR', 'value should be OR');
  equals(q._tokenList[2].tokenType, 'NOT', 'type should be NOT');
  equals(q._tokenList[2].tokenValue, 'NOT', 'value should be NOT');
  
}); 

// ..........................................................
// COMPOUND
//

test("negative numbers with equals", function(){
  q.conditions = "-1=-1";
  q.parse();
  equals(q._tokenList.length, 3, "should have 3 tokens");
});

// ..........................................................
// TREE-BUILDING
//

test("token tree should build", function() {  
  // Just some examples
  
  q.conditions = "(firstName MATCHES {firstName} OR lastName BEGINS_WITH 'Lone') AND is_a_beauty = true";
  q.parse();
  ok(q._tokenList.length == 13, 'list should have 13 tokens');
  ok(!q._tokenTree.error, 'there should be no errors');
  ok(q._tokenTree.tokenValue == 'AND', 'tree root should be AND');
  
});



})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/query/queryWithScope.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */
 
// test parsing of query string
var q, scope1, scope2;
module("SC.Query#queryWithScope", {
  setup: function() {
    q = SC.Query.create({
      conditions: "foo = bar",
      parameters: { foo: "bar" },
      orderBy: "foo",
      recordType: SC.Record,
      recordTypes: [SC.Record],
      location: SC.Query.REMOTE
    }).freeze();
    
    scope1 = SC.CoreSet.create();
    scope2 = SC.CoreSet.create();
  },
  
  teardown: function() {
    q = scope1 = scope2 = null;
  }
});

function verifyCopy(copy, original) {
  var keys = 'conditions orderBy recordType recordTypes parameters location'.w();
  keys.forEach(function(key) {
    equals(copy.get(key), original.get(key), 'copy.%@ should equal original.%@'.fmt(key, key));
  });
}

test("getting into scope first time", function() {
  
  var q2 = q.queryWithScope(scope1);
  verifyCopy(q2, q);
  equals(q2.get('scope'), scope1, 'new query should have scope1');
  
  var q3 = q.queryWithScope(scope1);
  equals(q3, q2, 'calling again with same scope should return same instance');
});

test("chained scope", function() {
  var q2 = q.queryWithScope(scope1) ;
  var q3 = q2.queryWithScope(scope2);
  
  verifyCopy(q3, q2);
  equals(q3.get('scope'), scope2, 'new query should have scope2');
  
  var q4 = q2.queryWithScope(scope2);
  equals(q4, q3, 'calling again with same scope should return same instance');
});


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/query/record_type_is.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// test parsing of query string
var rec, q;
module("SC.Query comparison of record types", {
  setup: function() {
    SC.RunLoop.begin();

    // setup dummy app and store
    window.MyApp = SC.Object.create({
      store: SC.Store.create()
    });
    
    // setup a dummy model
    window.MyApp.Foo = SC.Record.extend({});
    
    // load some data
    window.MyApp.store.loadRecords(window.MyApp.Foo, [
      { guid: 1, firstName: "John", lastName: "Doe" }
    ]);
    
    rec = window.MyApp.store.find(window.MyApp.Foo,1);
    
    q = SC.Query.create();

    SC.RunLoop.end();
  }
});


  
test("should handle record types", function() {
  
  q.conditions = "TYPE_IS 'MyApp.Foo'";
  q.parse();
  equals(SC.Store.recordTypeFor(rec.storeKey), SC.objectForPropertyPath('MyApp.Foo'), 'record type should be MyApp.Foo');
  ok(q.contains(rec), 'record with proper type should match');
  
  q.conditions = "TYPE_IS 'MyApp.Baz'";
  q.parse();
  ok(!q.contains(rec), 'record with wrong type should not match');
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/query/registered_comparisons.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */
 
// test parsing of query string
var store, storeKey, rec1, rec2, rec3, rec4, rec5, MyApp, q;

module("SC.Query comparison of records", {
  setup: function() {
    SC.RunLoop.begin();

    // setup dummy app and store
    MyApp = SC.Object.create({
      store: SC.Store.create()
    });
    
    // setup a dummy model
    MyApp.Foo = SC.Record.extend({});
    
    // load some data
    MyApp.store.loadRecords(MyApp.Foo, [
      { guid: 1, firstName: "John", lastName: "Doe", year: 1974 },
      { guid: 2, firstName: "Jane", lastName: "Doe", year: 1975 },
      { guid: 3, firstName: "Emily", lastName: "Parker", year: 1975, active: null },
      { guid: 4, firstName: "Johnny", lastName: "Cash", active: false },
      { guid: 5, firstName: "Bert", lastName: "Berthold", active: true }
    ]);
    
    rec1 = MyApp.store.find(MyApp.Foo,1);
    rec2 = MyApp.store.find(MyApp.Foo,2);
    rec3 = MyApp.store.find(MyApp.Foo,3);
    rec4 = MyApp.store.find(MyApp.Foo,4);
    rec5 = MyApp.store.find(MyApp.Foo,5);
    
    
    q = SC.Query.create();

    SC.RunLoop.end();
  },
  
  teardown: function() {
    // IMPORTANT: must delete so we don't screw up other unit tests.
    // cleanup after ourselves
    delete SC.Query.comparisons.firstName;
  }
});
 
 
// ..........................................................
// TESTS
// 

test("SC.Query.comparisons", function(){
  SC.Query.registerComparison('firstName', function(name1,name2){
    if (name1.length < name2.length) return -1;
    if (name1.length > name2.length) return 1;
    return 0;
  });
  ok(SC.Query.comparisons['firstName'], 'comparison for firstName should be set');
  q.orderBy = "firstName";
  q.parse();
  equals(q.compare(rec2,rec3), -1, "firstName should be compared by registered comparison");
  
  q.orderBy = "lastName";
  q.parse();
  equals(q.compare(rec2,rec3), -1, "lastName should be compared by SC.compare()");
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/query/registered_query_extensions.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */
 
var store, storeKey, rec1, rec2, rec3, rec4, rec5, MyApp, q;
module("SC.Query registered query extensions", {
  setup: function() {
    SC.RunLoop.begin();

    // setup dummy app and store
    MyApp = SC.Object.create({
      store: SC.Store.create()
    });
    
    // setup a dummy model
    MyApp.Foo = SC.Record.extend({});
    
    // load some data
    MyApp.store.loadRecords(MyApp.Foo, [
      { guid: 1, firstName: "John", lastName: "Doe", year: 1974 },
      { guid: 2, firstName: "Jane", lastName: "Doe", year: 1975 },
      { guid: 3, firstName: "Emily", lastName: "Parker", year: 1975, active: null },
      { guid: 4, firstName: "Johnny", lastName: "Cash", active: false },
      { guid: 5, firstName: "Bert", lastName: "Jules", active: true }
    ]);
    
    rec1 = MyApp.store.find(MyApp.Foo,1);
    rec2 = MyApp.store.find(MyApp.Foo,2);
    rec3 = MyApp.store.find(MyApp.Foo,3);
    rec4 = MyApp.store.find(MyApp.Foo,4);
    rec5 = MyApp.store.find(MyApp.Foo,5);
    
    
    q = SC.Query.create();

    SC.RunLoop.end();
  }
});
 
 
// ..........................................................
// TESTS
// 

test("SC.Query.queryExtensions", function(){
  SC.Query.registerQueryExtension('STARTS_WITH_J', {
    reservedWord: true,
    leftType: 'PRIMITIVE',
    evalType: 'BOOLEAN',
    evaluate: function (r,w) {
                var word = this.leftSide.evaluate(r,w);
                return ( word.substr(0,1) == 'J' );
              }
  });

  ok(q.queryLanguage['STARTS_WITH_J'], 'extension STARTS_WITH_J should be set');
  
  q.conditions = "firstName STARTS_WITH_J";
  q.parse();
  ok(q.contains(rec2), "Jane should match");
  ok(!q.contains(rec3), "Emily should not match");
  
  q.conditions = "firstName STARTS_WITH_J OR lastName STARTS_WITH_J";
  q.parse();
  ok(q.contains(rec2), "Jane Doe should match");
  ok(q.contains(rec5), "Bert Jules should match");

});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/record_array/array_observers.js"; 
}
(function() {
(function(root) {
  var store;
  var query;
  var recordArray;

  module("SC.RecordArray - implements array content observers", {
    setup: function() {
    },

    teardown: function() {
      root.MyRecord = undefined;
    }
  });

  test("notifies when a record is added to the store that matches a query", function() {
    var callCount = 0,
        lastRemovedCount = 0,
        lastAddedCount = 0;

    SC.run(function() {
      store = SC.Store.create();
      root.MyRecord = SC.Record.extend();
      query = SC.Query.local(MyRecord);

      recordArray = store.find(query);

      recordArray.addArrayObservers({
        didChange: function(start, removedCount, addedCount) {
          lastRemovedCount = removedCount;
          lastAddedCount = addedCount;
        },

        willChange: function() {}
      });

      store.createRecord(MyRecord, {});
    });

    equals(lastAddedCount, 1);
    equals(lastRemovedCount, 0);
    equals(recordArray.get('length'), 1);
  });

  test("notifies when a record is removed from the store that matches a query", function() {
    var lastRemovedCount = 0,
        lastAddedCount = 0;

    var record;

    SC.run(function() {
      store = SC.Store.create();
      root.MyRecord = SC.Record.extend();
      query = SC.Query.local(MyRecord);

      recordArray = store.find(query);

      recordArray.addArrayObservers({
        didChange: function(start, removedCount, addedCount) {
          lastRemovedCount = removedCount;
          lastAddedCount = addedCount;
        },

        willChange: function() {}
      });

      record = store.createRecord(MyRecord, {
        guid: 1
      });
    });

    equals(lastAddedCount, 1);
    equals(lastRemovedCount, 0);

    SC.run(function() {
      record.destroy();
    });

    equals(lastAddedCount, 0);
    equals(lastRemovedCount, 1);
    equals(recordArray.get('length'), 0);
  });
})(this);

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/record_array/core_methods.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// test core array-mapping methods for RecordArray
var store, storeKey, json, rec, storeKey2, json2, rec2, storeKeys, recs;
module("SC.RecordArray core methods", {
  setup: function() {
    // setup dummy store
    store = SC.Store.create();

    storeKey = SC.Record.storeKeyFor('foo');
    json = { guid: "foo", foo: "bar" };
    store.writeDataHash(storeKey, json, SC.Record.READY_CLEAN);

    storeKey2 = SC.Record.storeKeyFor('baz');
    json2 = { guid: "baz", baz: "bash" };
    store.writeDataHash(storeKey2, json2, SC.Record.READY_CLEAN);

    // get records
    rec = store.materializeRecord(storeKey);
    equals(rec.get('foo'), 'bar', 'precond - record should have json');
    rec2 = store.materializeRecord(storeKey2);
    equals(rec2.get('baz'), 'bash', 'precond - record 2 should have json');

    // get record array.
    storeKeys = [storeKey, storeKey2];
    recs = SC.RecordArray.create({ store: store, storeKeys: storeKeys });
  }
});

test("initial status", function() {
  equals(recs.get('status'), SC.Record.EMPTY, 'status should be SC.Record.EMPTY');
});

// ..........................................................
// LENGTH
//

test("should pass through length", function() {
  equals(recs.get('length'), storeKeys.length, 'rec should pass through length');
});

test("changing storeKeys length should change length of rec array also", function() {

  var oldlen = recs.get('length');

  storeKeys.pushObject(SC.Store.generateStoreKey()); // change length

  ok(storeKeys.length > oldlen, 'precond - storeKeys.length should have changed');
  equals(recs.get('length'), storeKeys.length, 'rec should pass through length');
});

// ..........................................................
// objectAt
//

test("should materialize record for object", function() {
  equals(storeKeys[0], storeKey, 'precond - storeKeys[0] should be storeKey');
  equals(recs.objectAt(0), rec, 'recs.objectAt(0) should materialize record');
});

test("reading past end of array length should return undefined", function() {
  equals(recs.objectAt(2000), undefined, 'recs.objectAt(2000) should be undefined');
});

test("modifying the underlying storeKey should change the returned materialized record", function() {
  // read record once to make it materialized
  equals(recs.objectAt(0), rec, 'recs.objectAt(0) should materialize record');

  // create a new record.
  SC.RunLoop.begin();
  var rec3 = store.createRecord(SC.Record, { foo: "rec3" });
  SC.RunLoop.end();

  var storeKey3 = rec3.get('storeKey');

  // add to beginning of storeKey array
  storeKeys.unshiftObject(storeKey3);
  equals(recs.get('length'), 3, 'should now have length of 3');
  equals(recs.objectAt(0), rec3, 'objectAt(0) should return new record');
  equals(recs.objectAt(1), rec, 'objectAt(1) should return old record 1');
  equals(recs.objectAt(2), rec2, 'objectAt(2) should return old record 2');
});

test("reading a record not loaded in store should trigger retrieveRecord", function() {
  var callCount = 0;

  // patch up store to record a call and to make it look like data is not
  // loaded.
  store.removeDataHash(storeKey, SC.Record.EMPTY);
  store.retrieveRecord = function() { callCount++; };

  equals(store.peekStatus(storeKeys.objectAt(0)), SC.Record.EMPTY, 'precond - storeKey must not be loaded');

  var rec = recs.objectAt(0);
  equals(callCount, 1, 'store.retrieveRecord() should have been called');
});

// ..........................................................
// replace()
//

test("adding a record to the record array should pass through storeKeys", function() {
  // read record once to make it materialized
  equals(recs.objectAt(0), rec, 'recs.objectAt(0) should materialize record');

  // create a new record.
  SC.RunLoop.begin();
  var rec3 = store.createRecord(SC.Record, { foo: "rec3" });
  SC.RunLoop.end();

  var storeKey3 = rec3.get('storeKey');

  // add record to beginning of record array
  recs.unshiftObject(rec3);

  // verify record array
  equals(recs.get('length'), 3, 'should now have length of 3');
  equals(recs.objectAt(0), rec3, 'recs.objectAt(0) should return new record');
  equals(recs.objectAt(1), rec, 'recs.objectAt(1) should return old record 1');
  equals(recs.objectAt(2), rec2, 'recs.objectAt(2) should return old record 2');

  // verify storeKeys
  equals(storeKeys.objectAt(0), storeKey3, 'storeKeys[0] should return new storeKey');
  equals(storeKeys.objectAt(1), storeKey, 'storeKeys[1] should return old storeKey 1');
  equals(storeKeys.objectAt(2), storeKey2, 'storeKeys[2] should return old storeKey 2');
});

// ..........................................................
// Property Observing
//

test("changing the underlying storeKeys should notify observers of records", function() {

  // setup observer
  var obj = SC.Object.create({
    cnt: 0,
    observer: function() { this.cnt++; }
  });
  recs.addObserver('[]', obj, obj.observer);

  // now modify storeKeys
  storeKeys.pushObject(SC.Store.generateStoreKey());
  equals(obj.cnt, 1, 'observer should have fired after changing storeKeys');
});

test("swapping storeKey array should change recordArray and observers", function() {

  // setup alternate storeKeys
  SC.RunLoop.begin();
  var rec2 = store.createRecord(SC.Record, { foo: "rec2" });
  SC.RunLoop.end();

  var storeKey2 = rec2.get('storeKey');
  var storeKeys2 = [storeKey2];

  // setup observer
  var obj = SC.Object.create({
    cnt: 0,
    observer: function() { this.cnt++; }
  });
  recs.addObserver('[]', obj, obj.observer);

  // read record once to make it materialized
  equals(recs.objectAt(0), rec, 'recs.objectAt(0) should materialize record');

  // now swap storeKeys
  obj.cnt = 0 ;
  recs.set('storeKeys', storeKeys2);

  // verify observer fired and record changed
  equals(obj.cnt, 1, 'observer should have fired after swap');
  equals(recs.objectAt(0), rec2, 'recs.objectAt(0) should return new rec');

  // modify storeKey2, make sure observer fires and content changes
  obj.cnt = 0;
  storeKeys2.unshiftObject(storeKey);
  equals(obj.cnt, 1, 'observer should have fired after edit');
  equals(recs.get('length'), 2, 'should reflect new length');
  equals(recs.objectAt(0), rec, 'recs.objectAt(0) should return pushed rec');

});

test("find works with query", function(){
  var filtered = recs.find(SC.Query.create({ conditions: "foo = 'bar'" }));

  equals(filtered.get('length'), 1);
  equals(filtered.objectAt(0), rec);
});

test("find works as enumerable", function(){
  var filtered = recs.find(function(r){ return r.get('foo') === 'bar'; });
  equals(filtered, rec);
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/record_array/error_methods.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

var store, Application;
module("SC.RecordArray Error Methods", {
  setup: function() {

    Application = {};
    Application.Thing = SC.Record.extend({
      name: SC.Record.attr(String)
    });

    SC.RunLoop.begin();
    store = SC.Store.create();

    var records = [
      { guid: 1, name: 'Thing One' },
      { guid: 2, name: 'Thing Two' }
    ];

    var types = [ Application.Thing, Application.Thing ];

    store.loadRecords(types, records);
    SC.RunLoop.end();
  },

  teardown: function() {
    store = null;
    Application = null;
  }
});

test("Verify error methods behave correctly", function() {
  var q = SC.Query.local(Application.Thing);
  var things = store.find(q);

  SC.RunLoop.begin();
  things.set('status', SC.Record.BUSY_LOADING);
  store.dataSourceDidErrorQuery(q, SC.Record.GENERIC_ERROR);
  SC.RunLoop.end();

  ok((things.get('isError') === YES), "isError on things array should be YES");

  equals(things.get('errorObject'), SC.Record.GENERIC_ERROR,
    "get('errorObject') on things array should return the correct error object");
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/record_array/flush.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// test core array-mapping methods for RecordArray
var store, storeKey, json, rec, storeKeys, recs, query, recsController, fooQuery, fooRecs, fooRecsController;
module("SC.RecordArray core methods", {
  setup: function() {
    // setup dummy store
    store = SC.Store.create();

    storeKey = SC.Record.storeKeyFor('foo');
    json = {  guid: "foo", foo: "foo" };

    store.writeDataHash(storeKey, json, SC.Record.READY_CLEAN);


    // get record
    rec = store.materializeRecord(storeKey);
    equals(rec.get('foo'), 'foo', 'record should have json');

    // get record array.
    query = SC.Query.create({ recordType: SC.Record });
    recs = SC.RecordArray.create({ store: store, query: query });

    recsController = SC.Object.create({
      content: recs,
      bigCost: NO,
      veryExpensiveObserver: function() {
        this.set('bigCost', YES);
      }.observes('.content.[]')
    });

    fooQuery = SC.Query.create({ recordType: SC.Record, conditions: "foo='foo'" });
    fooRecs = SC.RecordArray.create({ store: store, query: fooQuery });

    fooRecsController = SC.Object.create({
      content: fooRecs,
      bigCost: NO,
      veryExpensiveObserver: function() {
        this.set('bigCost', YES);
      }.observes('.content.[]')
    });
  }
});

// ..........................................................
// BASIC TESTS
//

test("should not initially populate storeKeys array until we flush()", function() {

  equals(recs.get('storeKeys'), null, 'should not have storeKeys yet');

  recs.flush();

  var storeKeys = recs.get('storeKeys');
  same(storeKeys, [storeKey], 'after flush should have initial set of storeKeys');

});

test("length property should flush", function() {
  equals(recs.get('storeKeys'), null,' should not have storeKeys yet');
  equals(recs.get('length'), 1, 'should have length 1 when called');
  same(recs.get('storeKeys'), [storeKey], 'after flush should have initial set of storeKeys');
});

test("objectAt() should flush", function() {
  equals(recs.get('storeKeys'), null,' should not have storeKeys yet');
  equals(recs.objectAt(0), rec, 'objectAt(0) should return record');
  same(recs.get('storeKeys'), [storeKey], 'after flush should have initial set of storeKeys');
});


// ..........................................................
// storeDidChangeStoreKeys()
//

test("calling storeDidChangeStoreKeys() with a matching recordType", function() {
  recs.flush(); // do initial setup
  var orig = recs.get('storeKeys').copy();

  // do it this way instead of using store.createRecord() to isolate the
  // method call.
  storeKey = SC.Record.storeKeyFor("bar");
  json     = {  guid: "bar", foo: "bar" };
  store.writeDataHash(storeKey, json, SC.Record.READY_CLEAN);

  equals(recs.get('needsFlush'), NO, 'PRECOND - should not need flush');
  same(recs.get('storeKeys'), orig, 'PRECOND - storeKeys should not have changed yet');

  recs.storeDidChangeStoreKeys([storeKey], SC.Set.create().add(SC.Record));

  orig.push(storeKey); // update - must be last b/c id.bar.storeKey < id.foo.storeKey
  equals(recs.get('needsFlush'), NO, 'should not need flush anymore');
  same(recs.get('storeKeys'), orig, 'storeKeys should now be updated - rec1[%@]{%@} = %@, rec2[%@]{%@} = %@'.fmt(
    rec.get('id'), rec.get('storeKey'), rec,

    store.materializeRecord(storeKey).get('id'),
    storeKey,
    store.materializeRecord(storeKey)));

});

test("calling storeDidChangeStoreKeys() with a non-matching recordType", function() {

  var Foo = SC.Record.extend(),
      Bar = SC.Record.extend();

  storeKey = Foo.storeKeyFor('foo2');
  json = { guid: "foo2" };

  store.writeDataHash(storeKey, json, SC.Record.READY_CLEAN);

  query = SC.Query.create({ recordType: Foo });
  recs = SC.RecordArray.create({ store: store, query: query });

  equals(recs.get('length'), 1, 'should have a Foo record');

  // now simulate adding a Bar record
  storeKey = Bar.storeKeyFor('bar');
  json = { guid: "bar" };
  store.writeDataHash(storeKey, json, SC.Record.READY_CLEAN);

  recs.storeDidChangeStoreKeys([storeKey], SC.Set.create().add(Bar));
  equals(recs.get('needsFlush'), NO, 'should not have indicated it needed a flush');

});

test("calling storeDidChangeStoreKeys() to remove a record", function() {

  equals(recs.get('length'), 1, 'PRECOND - should have storeKey');

  store.writeStatus(storeKey, SC.Record.DESTROYED_CLEAN);
  equals(recs.get('storeKeys').length, 1, 'should still have storeKey');
  recs.storeDidChangeStoreKeys([storeKey], SC.Set.create().add(SC.Record));

  equals(recs.get('length'), 0, 'should remove storeKey on flush()');
});

test("calling storeDidChangeStoreKeys() with a matching recordType should not unnecessarily call enumerableContentDidChange", function() {
  // do initial setup
  recs.flush();
  fooRecs.flush();

  recsController.set('bigCost', NO);
  fooRecsController.set('bigCost', NO);

  // do it this way instead of using store.createRecord() to isolate the
  // method call.
  storeKey = SC.Record.storeKeyFor("bar");
  json     = {  guid: "bar", foo: "bar" };
  store.writeDataHash(storeKey, json, SC.Record.READY_CLEAN);

  equals(recsController.get('bigCost'), NO, 'PRECOND - recsController should not have spent big cost');
  equals(fooRecsController.get('bigCost'), NO, 'PRECOND - fooRecsController should not have spent big cost');

  recs.storeDidChangeStoreKeys([storeKey], SC.Set.create().add(SC.Record));
  fooRecs.storeDidChangeStoreKeys([storeKey], SC.Set.create().add(SC.Record));

  equals(recsController.get('bigCost'), YES, 'recsController should have spent big cost');
  equals(fooRecsController.get('bigCost'), NO, 'fooRecsController should not have spent big cost');
});

test("adding an array observer to a SC.RecordArray should cause the array to flush", function() {
  var callCount = 0;

  recs.addArrayObservers({
    didChange: function() {
      callCount++;
    },

    willChange: function() { }
  });

  recs.get('length');

  equals(callCount, 0, "does not cause array observers to be fired when getting length");
});


// ..........................................................
// SPECIAL CASES
//

var json2, foo, bar ;

module("SC.RecordArray core methods", {
  setup: function() {
    // setup dummy store
    store = SC.Store.create();

    storeKey = SC.Record.storeKeyFor('foo');
    json = {  guid: "foo", name: "foo" };
    store.writeDataHash(storeKey, json, SC.Record.READY_CLEAN);
    foo = store.materializeRecord(storeKey);
    equals(foo.get('name'), 'foo', 'record should have json');

    storeKey = SC.Record.storeKeyFor('bar');
    json2 = { guid: "bar", name: "bar" };
    store.writeDataHash(storeKey, json2, SC.Record.READY_CLEAN);
    bar = store.materializeRecord(storeKey);
    equals(bar.get('name'), 'bar', 'record should have json');

    // get record array.
    query = SC.Query.create({ recordType: SC.Record, orderBy: 'name' });
    recs = store.find(query);
  }
});

test("local query should notify changes", function() {
  // note: important to retrieve records from RecordArray first to prime
  // any cache
  same(recs.mapProperty('id'), ['bar', 'foo'], 'PRECOND - bar should appear before foo');

  SC.stopIt = YES;

  SC.RunLoop.begin();
  bar.set('name', 'zzbar');
  SC.RunLoop.end(); // should resort record array

  same(recs.mapProperty('id'), ['foo', 'bar'], 'order of records should change');
});




})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/store/cancelRecord.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

var store, storeKey1,storeKey2;
var json1, json2;
var storeKey6, storeKey7;

module("SC.Store#cancelRecord", {
  setup: function() {
    
    store = SC.Store.create();
    
    json1 = {
      guid: "cancelGUID1",
      string: "string",
      number: 23,
      bool:   YES
    };
    json2 = {
      guid: "cancelGUID2",
      string: "string",
      number: 23,
      bool:   YES
    };
    
    storeKey1 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey1, json1, SC.Record.EMPTY);
    storeKey2 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey2, json2, SC.Record.READY_NEW);
    }
});

test("Check for error state handling and make sure that the method executes.", function() {
  var throwError=false;
  try{
    store.cancelRecord(undefined, undefined, storeKey1);
    throwError=false;
  }catch (error){
    throwError=true;
  }
  ok(throwError, "cancelRecord should throw and error if the record status is EMPTY or ERROR");
  try{
    store.cancelRecord(undefined, undefined, storeKey2);
    throwError=true;    
  }catch (error){
    throwError=false;
  }
  ok(throwError, " cancelRecord was successfully executed.");
  
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/store/commitChangesFromNestedStore.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

var store, child, storeKey, json;
module("SC.Store#commitChangesFromNestedStore", {
  setup: function() {
    SC.RunLoop.begin();

    store = SC.Store.create();

    json = {
      string: "string",
      number: 23,
      bool:   YES
    };

    storeKey = SC.Store.generateStoreKey();

    child = store.chain();  // test multiple levels deep

    // write basic status
    child.writeDataHash(storeKey, json, SC.Record.READY_DIRTY);
    child.dataHashDidChange(storeKey);
    child.changelog = SC.Set.create();
    child.changelog.add(storeKey);

    SC.RunLoop.end();
  }
});

test("copies changed data hashes, statuses, and revisions", function() {

  SC.RunLoop.begin();

  // verify preconditions
  equals(store.readDataHash(storeKey), null, 'precond - should not have data yet');
  ok(child.chainedChanges.contains(storeKey), 'precond - child changes should include storeKey');

  // perform action
  equals(store.commitChangesFromNestedStore(child, child.chainedChanges, NO), store, 'should return receiver');

  // verify new status
  equals(store.readDataHash(storeKey), json, 'now should have json');
  equals(store.readStatus(storeKey), SC.Record.READY_DIRTY, 'now should have status');
  equals(store.revisions[storeKey], child.revisions[storeKey], 'now shoulave have revision from child');

  SC.RunLoop.end();
});

test("adds items in changelog to receiver changelog", function() {

  var key1 = SC.Store.generateStoreKey();

  SC.RunLoop.begin();

  store.changelog = SC.Set.create();
  store.changelog.add(key1);

  ok(child.changelog.contains(storeKey), 'precond - child.changelog should contain store key');

  equals(store.commitChangesFromNestedStore(child, child.chainedChanges, NO), store, 'should return receiver');

  // changelog should merge nested store & existing
  ok(store.changelog.contains(key1), 'changelog should still contain key1');
  ok(store.changelog.contains(storeKey), 'changelog should also contain storeKey');

  SC.RunLoop.end();
});

test("ignores changed data hashes not passed in changes set", function() {

  // preconditions
  equals(store.readDataHash(storeKey), null, 'precond - should not have data yet');

  // perform action
  equals(store.commitChangesFromNestedStore(child, SC.Set.create(), NO), store, 'should return receiver');

  // verify results
  equals(store.readDataHash(storeKey), null, 'should not copy data hash for storeKey');

});

function createConflict(force) {
  var json2 = { kind: "json2" };
  var json3 = { kind: "json3" };

  // create a lock conflict.  use a new storeKey since the old one has been
  // setup in a way that won't work for this.
  storeKey = SC.Store.generateStoreKey();

  // step 1: add data to root store
  store.writeDataHash(storeKey, json, SC.Record.READY_CLEAN);
  store.dataHashDidChange(storeKey);

  // step 2: read data in chained store.  this will create lock
  child.readDataHash(storeKey);
  ok(child.locks[storeKey], 'child store should now have lock');

  // step 3: modify root store again
  store.writeDataHash(storeKey, json2, SC.Record.READY_CLEAN);
  store.dataHashDidChange(storeKey);

  // step 4: modify data in chained store so we have something to commit.
  child.writeDataHash(storeKey, json3, SC.Record.READY_DIRTY);
  child.dataHashDidChange(storeKey);

  // just to make sure verify that the lock and revision in parent do not
  // match
  ok(child.locks[storeKey] !== store.revisions[storeKey], 'child.lock (%@) should !== store.revision (%@)'.fmt(child.locks[storeKey], store.revisions[storeKey]));

  // step 5: now try to commit changes from child store.  This should throw
  // an exception.
  var errorCount = 0;
  try {
    child.commitChanges(force);
  } catch(e) {
    equals(e, SC.Store.CHAIN_CONFLICT_ERROR, 'should throw CHAIN_CONFLICT_ERROR');
    errorCount++;
  }

  return errorCount ;
}

test("throws exception if any record fails optimistic locking test", function() {
  var errorCount = createConflict(NO);
  equals(errorCount, 1, 'should have raised error');
});

test("does not throw exception if optimistic locking fails but force option is passed", function() {
  var errorCount = createConflict(YES);
  equals(errorCount, 0, 'should not raise error');
});


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/store/commitRecord.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

var store, storeKey1, storeKey2, storeKey3, storeKey4, storeKey5, storeKey6;
var storeKey7, json, json1, json2, json3, json4, json5, json6, json7;
var ds ;

module("SC.Store#commitRecord", {
  setup: function() {

    ds = SC.DataSource.create({

      callCount: 0,

      commitRecords: function(store, toCreate, toUpdate, toDestroy, params) {
        this.toCreate = toCreate;
        this.toUpdate = toUpdate;
        this.toDestroy = toDestroy;
        this.params = params;
        this.callCount++;
      },

      reset: function() {
        this.toCreate = this.toUpdate = this.toDestroy = this.params = null;
        this.callCount = 0 ;
      },

      expect: function(callCount, toCreate, toUpdate, toDestroy, params) {
        if (callCount !== undefined) {
          equals(this.callCount, callCount, 'expect datasource.commitRecords to be called X times');
        }

        if (toCreate !== undefined) {
          same(this.toCreate, toCreate, 'expect toCreate to have items');
        }

        if (toUpdate !== undefined) {
          same(this.toUpdate, toUpdate, 'expect toUpdate to have items');
        }

        if (toDestroy !== undefined) {
          same(this.toDestroy, toDestroy, 'expect toDestroy to have items');
        }

        if (params !== undefined) {
          same(this.params, params, 'expect params to have items');
        }
      }

    });

    store = SC.Store.create().from(ds);

    json1 = {
      guid: "commitGUID1",
      string: "string",
      number: 23,
      bool:   YES
    };
    json2 = {
      guid: "commitGUID2",
      string: "string",
      number: 23,
      bool:   YES
    };
    json3 = {
      guid: "commitGUID3",
      string: "string",
      number: 23,
      bool:   YES
    };
    json4 = {
      guid: "commitGUID4",
      string: "string",
      number: 23,
      bool:   YES
    };
    json5 = {
      guid: "commitGUID5",
      string: "string",
      number: 23,
      bool:   YES
    };
    json6 = {
      guid: "commitGUID6",
      string: "string",
      number: 23,
      bool:   YES
    };
    json7 = {
      guid: "commitGUID7",
      string: "string",
      number: 23,
      bool:   YES
    };

    SC.RunLoop.begin();
    storeKey1 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey1, json1, SC.Record.READY_CLEAN);
    storeKey2 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey2, json2, SC.Record.READY_NEW);
    storeKey3 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey3, json3, SC.Record.READY_DIRTY);
    storeKey4 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey4, json4, SC.Record.DESTROYED_DIRTY);
    storeKey5 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey5, json5, SC.Record.EMPTY);
    storeKey6 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey6, json6, SC.Record.ERROR);
    storeKey7 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey7, json7, SC.Record.DESTROYED_CLEAN);
    SC.RunLoop.end();
  }
});

test("Confirm that all the states are switched as expected after running commitRecord", function() {
  var throwError=false, msg, status;

  store.commitRecord(undefined, undefined, storeKey1);
  status = store.readStatus( storeKey1);
  equals(status, SC.Record.READY_CLEAN, "the status shouldn't have changed. It should be READY_CLEAN ");

  store.commitRecord(undefined, undefined, storeKey2);
  status = store.readStatus( storeKey2);
  equals(status, SC.Record.BUSY_CREATING, "the status should be SC.Record.BUSY_CREATING");

  store.commitRecord(undefined, undefined, storeKey3);
  status = store.readStatus( storeKey3);
  equals(status, SC.Record.BUSY_COMMITTING, "the status should be SC.Record.BUSY_COMMITTING");

  store.dataSourceDidComplete(storeKey3);
  status = store.readStatus( storeKey3);
  equals(status, SC.Record.READY_CLEAN, "the status should be SC.Record.READY_CLEAN");

  store.commitRecord(undefined, undefined, storeKey4);
  status = store.readStatus( storeKey4);
  equals(status, SC.Record.BUSY_DESTROYING, "the status should be SC.Record.BUSY_DESTROYING");

  store.dataSourceDidDestroy(storeKey4);
  status = store.readStatus(storeKey4);
  equals(status, SC.Record.DESTROYED_CLEAN, "the status should be SC.Record.DESTROYED_CLEAN");

  store.commitRecord(undefined, undefined, storeKey5);
  status = store.readStatus( storeKey5);
  equals(status, SC.Record.EMPTY, "the status should be SC.Record.EMPTY");

  try{
    store.commitRecord(undefined, undefined, storeKey6);
    throwError=false;
    msg='';
  }catch(error){
    throwError=true;
    msg=error.message;
  }
  equals(msg, SC.Record.NOT_FOUND_ERROR.message, "commitRecord should throw the following error");

  store.commitRecord(undefined, undefined, storeKey7);
  status = store.readStatus( storeKey7);
  equals(status, SC.Record.DESTROYED_CLEAN, "the status should be SC.Record.DESTROYED_CLEAN");

});

test("calling commitRecords() without explicit storeKeys", function() {
  var st;
  store.changelog = [storeKey1, storeKey2, storeKey3, storeKey4];
  store.commitRecords();

  st = store.readStatus( storeKey1);
  equals(st, SC.Record.READY_CLEAN, "storeKey1 - the status shouldn't have changed. It should be READY_CLEAN ");

  st = store.readStatus( storeKey2);
  equals(st, SC.Record.BUSY_CREATING, "storeKey2 - the status should be SC.Record.BUSY_CREATING");

  st = store.readStatus( storeKey3);
  equals(st, SC.Record.BUSY_COMMITTING, "storeKey3 - the status should be SC.Record.BUSY_COMMITTING");

  st = store.readStatus( storeKey4);
  equals(st, SC.Record.BUSY_DESTROYING, "storeKey4 - the status should be SC.Record.BUSY_DESTROYING");

  ds.expect(1, [storeKey2], [storeKey3], [storeKey4]);
});

test("calling commitRecords() with params", function() {
  var p = { foo: "bar" };
  store.commitRecord(null, null, storeKey2, p);
  ds.expect(1, [storeKey2], [], [], p);
  ds.reset();

  // calling commit records with no storeKeys should still invoke if params
  store.commitRecords(null,null,null,p);
  ds.expect(1, [], [], [], p);
  ds.reset();

  // call commit records with no storeKeys and no params should not invoke ds
  store.commitRecords(null,null,null,null);
  ds.expect(0);
});

test("calling commitRecords() with callbacks", function() {
  var wasCalled = NO;
  var cb = function(){wasCalled = YES;};

  store.commitRecord(null, null, storeKey2, {}, cb);
  ok(store._callback_queue[storeKey2], "should have a callback in the queue");
  ok(!wasCalled, "wasn't called yet");
  store.dataSourceDidComplete(storeKey2);
  ok(wasCalled, "callback fired!");
});


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/store/connectDataSource.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================

module("connecting DataSource to a store");

test("data source passed as string should be available as after running _getDataSource", function() {
  window.MyTestDataSource = SC.DataSource.extend({
    foo: 'bar'
  });

  var store = SC.Store.create().from("MyTestDataSource");
  same(store.get("dataSource"), "MyTestDataSource");

  var dataSource = store._getDataSource();
  same(dataSource.foo, 'bar');

  same(store.get('dataSource').foo, 'bar');
});

test("data source is required, if it can't be found, error should be thrown", function() {
  expect(1);

  try {
    SC.Store.create().from("SC.YourTestDataSource")._getDataSource();
  } catch (x) {
    same(x, 'SC.YourTestDataSource could not be found');
  }
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/store/core_methods.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp Sample */

var store, Application, dataSource;

module("SC.Store Core Methods", {
  setup: function() {
    dataSource = SC.DataSource.create({ 
      
      gotParams: NO,
      
      updateRecord: function(store, storeKey, params) {
        this.gotParams = params && params['param1'] ? YES: NO;
      }
    });
    
    Application = {};
    Application._nameDidChange = 0;
    
    Application.File = SC.Record.extend({ 
      
      nameDidChange: function(object, key) {
        Application._nameDidChange++;
      }.observes('name', 'url', 'isDirectory')
      
    });
    Application.FileDisk = SC.Record.extend({ });
    
    Application.Data = {
      
      "FileDisk": [
        { guid: '14', name: 'Main Drive', parent: null, children: null }
      ],
    
      "File": [
        { guid: '10', name: 'Home', url: '/emily_parker', isDirectory: true, parent: null, children: 'Collection'},
        { guid: '11', name: 'Documents', fileType: 'documents', url: '/emily_parker/Documents', isDirectory: true, parent: '10', children: 'Collection', createdAt: 'June 15, 2007', modifiedAt: 'October 21, 2007', filetype: 'directory', isShared: false},
        { guid: '137',name: 'Library', fileType: 'library', url: '/emily_parker/Library', isDirectory: true, parent: '10', children: 'Collection', createdAt: 'June 15, 2007', modifiedAt: 'October 21, 2007', filetype: 'directory', isShared: false},
        { guid: '12', name: 'Movies', fileType: 'movies', url: '/emily_parker/Movies', isDirectory: true, parent: '10', children: 'Collection', createdAt: 'June 15, 2007', modifiedAt: 'June 15, 2007', filetype: 'directory', isShared: true, sharedAt: 'October 15, 2007', sharedUntil: 'March 31, 2008', sharedUrl: '2fhty', isPasswordRequired: true},
        { guid: '134',name: 'Music', fileType: 'music', url: '/emily_parker/Music', isDirectory: true, parent: '10', children: 'Collection', createdAt: 'June 15, 2007', modifiedAt: 'June 15, 2007', filetype: 'directory', isShared: true, sharedAt: 'October 15, 2007', sharedUntil: 'March 31, 2008', sharedUrl: '2fhty', isPasswordRequired: true},
        { guid: '135',name: 'Pictures', fileType: 'pictures', url: '/emily_parker/Pictures', isDirectory: true, parent: '10', children: 'Collection', createdAt: 'June 15, 2007', modifiedAt: 'June 15, 2007', filetype: 'directory', isShared: true, sharedAt: 'October 15, 2007', sharedUntil: 'March 31, 2008', sharedUrl: '2fhty', isPasswordRequired: true},
        { guid: '13', name: 'Auto Insurance', fileType: 'folder', url: '/emily_parker/Documents/Auto%20Insurance', isDirectory: true, parent: '11', children: 'Collection', createdAt: 'June 15, 2007', modifiedAt: 'October 21, 2007', filetype: 'directory', isShared: false},
        { guid: '14', name: 'Birthday Invitation.pdf', fileType: 'file', url: '/emily_parker/Documents/Birthday%20Invitation', isDirectory: false, parent: '11', createdAt: 'October 17, 2007', modifiedAt: 'October 21, 2007', filetype: 'pdf', isShared: false},
        { guid: '136', name: 'Software', fileType: 'software', url: '/emily_parker/Software', isDirectory: true, parent: '10', children: 'Collection', createdAt: 'June 15, 2007', modifiedAt: 'June 15, 2007', filetype: 'directory', isShared: true, sharedAt: 'October 15, 2007', sharedUntil: 'March 31, 2008', sharedUrl: '2fhty', isPasswordRequired: true}
      ]
    };
    
    SC.RunLoop.begin();
    store = SC.Store.create({ name: 'Test store'} ).from(dataSource);
    for(var i in Application.Data) {
      store.loadRecords(Application[i], Application.Data[i]);
    }
    SC.RunLoop.end();
    
    // make sure RecordType by String can map
    window.Application = Application;
  }    
});

test("Verify that SC.Store's toString() includes the store's name, if it was specified", function() {
  
  var description = store.toString();
  ok(description.indexOf('Test store') !== -1, 'should contain "Test store"');
  
});

test("Verify loadRecords() loads data", function() {
  
  equals(store.find(Application.File, '14').get('name'), 'Birthday Invitation.pdf', 'should return File 14');
  equals(store.find(Application.FileDisk, '14').get('name'), 'Main Drive', 'should return FileDisk 14');
  
});

test("Verify storeKeys() gets all store keys", function() {
  
  var storeKey;
  
  equals(store.storeKeys().length, 10, 'Length should be 10');
  
  storeKey = store.storeKeyFor(Application.File, '10');
  store.writeStatus(storeKey, SC.Record.EMPTY);
  equals(store.storeKeys().length, 9, 'Length should be one less now');
  
});

test("find() should take both SC.Record object and SC.Record string as recordtype argument", function() {
  
  equals(store.find('Application.File', '14').get('name'), 'Birthday Invitation.pdf', 'should return File 14');
  equals(store.find(Application.File, '14').get('name'), 'Birthday Invitation.pdf', 'should return FileDisk 14');
  
});

test("loading more records should not sending _flushRecordChanges() until the end of the runloop", function() {

  var moreData = [
      { guid: '55', name: 'Home', url: '/emily_parker', isDirectory: true, parent: null, children: 'Collection'},
      { guid: '56', name: 'Documents', fileType: 'documents', url: '/emily_parker/Documents', isDirectory: true, parent: '10', children: 'Collection', createdAt: 'June 15, 2007', modifiedAt: 'October 21, 2007', filetype: 'directory', isShared: false},
      { guid: '57',name: 'Library', fileType: 'library', url: '/emily_parker/Library', isDirectory: true, parent: '10', children: 'Collection', createdAt: 'June 15, 2007', modifiedAt: 'October 21, 2007', filetype: 'directory', isShared: false}
  ];
  
  SC.RunLoop.begin();
  
  var storeKeys = store.loadRecords(Application.File, moreData);
  equals(storeKeys.length, 3, 'precon - should have loaded three records');
  equals(store.recordPropertyChanges.storeKeys.length, 3, 'should be three storeKeys in changelog');
  
  SC.RunLoop.end();
  
  // recordPropertyChanges may not exist after notifications have gone out.
  // treat that like having len=0
  var changes = store.recordPropertyChanges;
  var len = (changes && changes.storeKeys) ? changes.storeKeys.length : 0;
  equals(len, 0, 'should be zero storeKeys in changelog');
  
});

test("Passing params through commitRecords()", function() {
  
  var file = store.find(Application.File, '14');
  file.set('name', 'My Great New Name');
  
  store.commitRecords(null, null, null, { param1: 'value1' });
  
  equals(dataSource.gotParams, YES, 'params should have travelled through to dataSource updateRecord() call');
  
});

test("Make sure that setting an attribute on a record will only notify respective observers once", function() {
  
  var file = store.find(Application.File, '14');
  Application._nameDidChange = 0 ;
  
  SC.RunLoop.begin();
  file.writeAttribute('name', 'My Great New Name');
  SC.RunLoop.end();
  
  equals(Application._nameDidChange, 1, 'observer should have been fired only once');

});


// test("Calling replaceIdFor() should notify the record that its id has changed", function() {
//   
//   var file = store.find(Application.File, '14');
// 
//   file.get('id'); // Just getting the id, so it gets cached.
// 
//   SC.Store.replaceIdFor(file.get('storeKey'), 999);
//   equals(file.get('id'), 999, 'the record should have the new id');
// 
// });


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/store/createRecord.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

var store, storeKey, json, hash, hash2;

module("SC.Store#createRecord", {
  setup: function() {

    MyRecordType = SC.Record.extend({
      string: SC.Record.attr(String, { defaultValue: "Untitled" }),
      number: SC.Record.attr(Number, { defaultValue: 5 }),
      bool: SC.Record.attr(Boolean, { defaultValue: YES }),
      array: SC.Record.attr(Array, { defaultValue: [1, 2] }),
      funcDef: SC.Record.attr(Array, { defaultValue: function() { return [1, 3]} }),
      noDefault: SC.Record.attr(String)
    });

    MyKeyedRecordType = SC.Record.extend({
      string: SC.Record.attr(String, { defaultValue: "Untitled", key: 'string_key' }),
      number: SC.Record.attr(Number, { defaultValue: 5, key: 'number_key' }),
      bool: SC.Record.attr(Boolean, { defaultValue: YES, key: 'bool_key' }),
      array: SC.Record.attr(Array, { defaultValue: [1, 2], key: 'array_key' }),
      funcDef: SC.Record.attr(Array, { defaultValue: function() { return [1, 3]}, key: 'funcDef_key' }),
      noDefault: SC.Record.attr(String, { key: 'noDefault_key' })
    });

    SC.RunLoop.begin();

    store = SC.Store.create();

    json = {
      string: "string",
      number: 23,
      bool:   YES
    };

    storeKey = SC.Store.generateStoreKey();

    store.writeDataHash(storeKey, json, SC.Record.READY_CLEAN);

    SC.RunLoop.end();
  }
});

test("create a record", function() {
  var sk;
  var rec = SC.Record.create();
  hash = {
    guid: "1234abcd",
    string: "abcd",
    number: 1,
    bool:   NO,
    array:  [],
    funcDef: [1, 2]
    };
  hash2 = {
    string: "abcd",
    number: 1,
    bool:   NO,
    array:  [],
    funcDef: [1, 2]
  };

  rec = store.createRecord(SC.Record, hash);
  ok(rec, "a record was created");
  sk=store.storeKeyFor(SC.Record, rec.get('id'));
  equals(store.readDataHash(sk), hash, "data hashes are equivalent");
  equals(rec.get('id'), "1234abcd", "guids are the same");

  rec = store.createRecord(SC.Record, hash2, "priKey");
  ok(rec, "a record with a custom id was created");
  sk=store.storeKeyFor(SC.Record, "priKey");
  equals(store.readDataHash(sk), hash2, "data hashes are equivalent");
  equals(rec.get('id'), "priKey", "guids are the same");

  equals(store.changelog.length, 2, "The changelog has the following number of entries:");
});

/**
  There is new functionality in the store that allows the developer to reference
  attribute names or attribute keys when creating a new record.

  For example, if the Record is defined as:

    MyApp.Record = SC.Record.extend({
      attrA: SC.RecordAttribute(String, { key: 'attr_a' });
    })

  Previously, passing the hash { attrA: 'test' } would see `attrA` added to the
  hash when it should instead be `attr_a`.  The new functionality, recognizes
  that the attribute key should be used.

  Therefore, either of these will result in the same data hash in the store:

    MyApp.store.createRecord(MyApp.Record, { attrA: 'test' })
    MyApp.store.createRecord(MyApp.Record, { attr_a: 'test' })

*/
test("Creating a keyed record", function() {
  var hash1, hash2, hash3, hash4, expectedHash, sk;

  // The actual hash that should be created.
  expectedHash = {
    string_key: "abcd",
    number_key: 1,
    bool_key:   NO,
    array_key:  [],
    funcDef_key: [1, 2]
  };

  // Uses only the attribute names
  hash1 = {
    string: "abcd",
    number: 1,
    bool:   NO,
    array:  [],
    funcDef: [1, 2]
  };

  // Uses only the attribute keys
  hash2 = {
    string_key: "abcd",
    number_key: 1,
    bool_key:   NO,
    array_key:  [],
    funcDef_key: [1, 2]
  };

  // Uses a mix of attribute names and keys
  hash3 = {
    string: "abcd",
    number_key: 1,
    bool_key:   NO,
    array:  [],
    funcDef: [1, 2]
  };

  // Uses duplicate attribute names and keys in different orders
  hash4 = {
    string: "efgh",
    string_key: "abcd",
    number_key: 1,
    bool_key:   NO,
    bool:   YES,
    array_key:  [],
    array:  ['a'],
    funcDef: [1, 2]
  };

  rec = store.createRecord(MyKeyedRecordType, hash1, 'test1');
  sk = store.storeKeyFor(MyKeyedRecordType, rec.get('id'));
  same(store.readDataHash(sk), expectedHash, "data hashes are equivalent when given only names");

  rec = store.createRecord(MyKeyedRecordType, hash2, 'test2');
  sk = store.storeKeyFor(MyKeyedRecordType, rec.get('id'));
  same(store.readDataHash(sk), expectedHash, "data hashes are equivalent when given only keys");

  rec = store.createRecord(MyKeyedRecordType, hash3, 'test3');
  sk = store.storeKeyFor(MyKeyedRecordType, rec.get('id'));
  same(store.readDataHash(sk), expectedHash, "data hashes are equivalent when given names and keys");

  rec = store.createRecord(MyKeyedRecordType, hash4, 'test4');
  sk = store.storeKeyFor(MyKeyedRecordType, rec.get('id'));
  same(store.readDataHash(sk), expectedHash, "data hashes are equivalent when given names and keys with conflicts");
});

test("Creating an empty (null) record should make the hash available", function() {

  store.createRecord(MyRecordType, null, 'guid8');
  var storeKey = store.storeKeyFor(MyRecordType, 'guid8');

  ok(store.readDataHash(storeKey), 'data hash should not be empty/undefined');

});

test("Initializing default values", function() {
  var rec1, rec2, sk1, sk2;

  //create 2 records
  rec1 = store.createRecord(MyRecordType, null, 'test1');
  rec2 = store.createRecord(MyRecordType, null, 'test2');

  //get storKeys
  sk1 = store.storeKeyFor(MyRecordType, rec1.get('id'));
  sk2 = store.storeKeyFor(MyRecordType, rec2.get('id'));

  ok(sk1, "a first record with default values was created");

  equals(store.readDataHash(sk1)['string'], "Untitled", "the default value for 'string' was initialized");
  equals(store.readDataHash(sk1)['number'], 5, "the default value for 'number' was initialized");
  equals(store.readDataHash(sk1)['bool'], YES, "the default value for 'bool' was initialized");
  same(store.readDataHash(sk1)['array'], [1, 2], "the default value for 'array' was initialized");
  same(store.readDataHash(sk1)['funcDef'], [1, 3], "the default value for 'funcDef' was initialized");
  equals(store.readDataHash(sk1)['noDefault'], null, "no value for 'noDefault' was initialized");

  ok(sk2, "a second record with default values was created");

  rec2.get('array').push(3);
  rec2.get('funcDef').push(2);

  same(store.readDataHash(sk2)['array'], [1, 2, 3], "the array for 'array' was updated");
  same(store.readDataHash(sk2)['funcDef'], [1, 3, 2], "the array for 'funcDef' was updated");

  ok(store.readDataHash(sk2)['array'] !== store.readDataHash(sk1)['array'], "the default value for 'array' is a copy not a reference");
  ok(store.readDataHash(sk2)['funcDef'] !== store.readDataHash(sk1)['funcDef'], "the default value for 'funcDef' is a copy not a reference");
});

test("Initializing default values with keyed attributes", function() {
  var rec1, rec2, sk1, sk2;

  //create 2 records
  rec1 = store.createRecord(MyKeyedRecordType, null, 'test1');
  rec2 = store.createRecord(MyKeyedRecordType, null, 'test2');

  //get storKeys
  sk1 = store.storeKeyFor(MyKeyedRecordType, rec1.get('id'));
  sk2 = store.storeKeyFor(MyKeyedRecordType, rec2.get('id'));

  ok(sk1, "a first record with default values was created");

  equals(store.readDataHash(sk1)['string_key'], "Untitled", "the default value for 'string' was initialized");
  equals(store.readDataHash(sk1)['number_key'], 5, "the default value for 'number' was initialized");
  equals(store.readDataHash(sk1)['bool_key'], YES, "the default value for 'bool' was initialized");
  same(store.readDataHash(sk1)['array_key'], [1, 2], "the default value for 'array' was initialized");
  same(store.readDataHash(sk1)['funcDef_key'], [1, 3], "the default value for 'funcDef' was initialized");
  equals(store.readDataHash(sk1)['noDefault_key'], null, "no value for 'noDefault' was initialized");

  ok(sk2, "a second record with default values was created");

  rec2.get('array').push(3);
  rec2.get('funcDef').push(2);

  same(store.readDataHash(sk2)['array_key'], [1, 2, 3], "the array for 'array' was updated");
  same(store.readDataHash(sk2)['funcDef_key'], [1, 3, 2], "the array for 'funcDef' was updated");

  ok(store.readDataHash(sk2)['array_key'] !== store.readDataHash(sk1)['array_key'], "the default value for 'array' is a copy not a reference");
  ok(store.readDataHash(sk2)['funcDef_key'] !== store.readDataHash(sk1)['funcDef_key'], "the default value for 'funcDef' is a copy not a reference");
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/store/dataHashDidChange.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// NOTE: The test below are based on the Data Hashes state chart.  This models
// the "did_change" event in the Store portion of the diagram.

var MyApp = {};

var store, child, storeKey, json;
module("SC.Store#dataHashDidChange", {
  setup: function() {
    store = SC.Store.create();
    
    json = {
      string: "string",
      number: 23,
      bool:   YES
    };
    
    storeKey = SC.Store.generateStoreKey();

    store.writeDataHash(storeKey, json, SC.Record.READY_CLEAN);
    store.editables = null; // manually patch to setup test state
    child = store.chain();  // test multiple levels deep
    
    
    MyApp.Foo = SC.Record.extend({
      prop1: SC.Record.attr(String, { defaultValue: 'Default Value for prop1' }),
      prop2: SC.Record.attr(String, { defaultValue: 'Default Value for prop2' }),
      prop3: SC.Record.attr(String, { defaultValue: 'Default Value for prop2' })
    });
    
  }
});

// ..........................................................
// BASIC STATE TRANSITIONS
// 


function testStateTransition(fromState, toState) {

  // verify preconditions
  equals(store.storeKeyEditState(storeKey), fromState, 'precond - storeKey edit state');
  if (store.chainedChanges) {
    ok(!store.chainedChanges.contains(storeKey), 'changedChanges should NOT include storeKey');
  }

  var oldrev = store.revisions[storeKey];
  
  // perform action
  equals(store.dataHashDidChange(storeKey), store, 'should return receiver');

  // verify results
  equals(store.storeKeyEditState(storeKey), toState, 'store key edit state is in same state');

  // verify revision
  ok(oldrev !== store.revisions[storeKey], 'revisions should change. was: %@ - now: %@'.fmt(oldrev, store.revisions[storeKey]));
  
} 

test("edit state = LOCKED", function() {
  SC.RunLoop.begin();
  
  store.readDataHash(storeKey); // lock
  testStateTransition(SC.Store.LOCKED, SC.Store.LOCKED);
  
  SC.RunLoop.end();
}) ;

test("edit state = EDITABLE", function() {
  SC.RunLoop.begin();
  
  store.readEditableDataHash(storeKey); // make editable
  testStateTransition(SC.Store.EDITABLE, SC.Store.EDITABLE);
  
  SC.RunLoop.end();
}) ;

// ..........................................................
// SPECIAL CASES
// 

test("calling with array of storeKeys will edit all store keys", function() {
  SC.RunLoop.begin();
  
  var storeKeys = [storeKey, SC.Store.generateStoreKey()], idx ;
  store.dataHashDidChange(storeKeys, 2000) ;
  for(idx=0;idx<storeKeys.length;idx++) {
    equals(store.revisions[storeKeys[idx]], 2000, 'storeKey at index %@ should have new revision'.fmt(idx));
  }
  
  SC.RunLoop.end();
});

test("calling dataHashDidChange twice with different statusOnly values before flush is called should trigger a non-statusOnly flush if any of the statusOnly values were NO", function() {
  SC.RunLoop.begin();

  // Create a phony record because that's the only way the 'hasDataChanges'
  // data structure will be used.
  var record = SC.Record.create({ id: 514 }) ;
  var storeKey = SC.Record.storeKeyFor(514) ;
  record = store.materializeRecord(storeKey) ;
  store.dataHashDidChange(storeKey, null, NO) ;
  store.dataHashDidChange(storeKey, null, YES) ;
  
  ok(store.recordPropertyChanges.hasDataChanges.contains(storeKey), 'recordPropertyChanges.hasDataChanges should contain the storeKey %@'.fmt(storeKey)) ;

  SC.RunLoop.end();
});

test("calling _notifyRecordPropertyChange twice, once with a key and once without, before flush is called should invalidate all cached properties when flush is finally called", function() {
  SC.RunLoop.begin();

  var mainStore = SC.Store.create();
  var record    = mainStore.createRecord(MyApp.Foo, {});
  
  // Make sure the property values get cached.
  var cacheIt = record.get('prop1');
  cacheIt     = record.get('prop2');
  
  var storeKey = record.get('storeKey');
  
  // Send an innocuous "prop2 changed" notification, because we want to be sure
  // that if we notify about a change to one property and later also change all
  // properties, all properties get changed.  (Even if we notify about yet
  // another individual property change after that, but still before the flush.)
  mainStore._notifyRecordPropertyChange(storeKey, NO, 'prop2');
  
  var nestedStore  = mainStore.chain();
  var nestedRecord = nestedStore.materializeRecord(storeKey);
  
  // Now, set the values of prop1 and prop2 to be different for the records in
  // the nested store.
  nestedRecord.set('prop1', 'New value');
  
  // Now, when we commit, we'll be changing the dataHash of the main store and
  // should notify that all properties have changed.
  nestedStore.commitChanges();
  
  // Now, we'll do one more innocuous "prop3 changed" notification to ensure
  // that the eventual flush does indeed invalidate *all* property caches, and
  // not just prop2 and prop3.
  mainStore._notifyRecordPropertyChange(storeKey, NO, 'prop3');

  // Let the flush happen.
  SC.RunLoop.end();


  // Finally, read 'prop1' from the main store's object.  It should be the new
  // value!
  equals(record.get('prop1'), 'New value', 'The main store’s record should return the correct value for prop1, not the stale cached version') ;
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/store/dataSourceCallbacks.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

var store, storeKey, json;
module("SC.Store#dataSourceCallbacks", {
  setup: function() {
    
    store = SC.Store.create();
    
    json1 = {
      guid: "commitGUID1",
      string: "string",
      number: 23,
      bool:   YES
    };
    json2 = {
      guid: "commitGUID2",
      string: "string",
      number: 23,
      bool:   YES
    };
    json3 = {
      guid: "commitGUID3",
      string: "string",
      number: 23,
      bool:   YES
    };
    json4 = {
      guid: "commitGUID4",
      string: "string",
      number: 23,
      bool:   YES
    };
    json5 = {
      guid: "commitGUID5",
      string: "string",
      number: 23,
      bool:   YES
    };
    json6 = {
      guid: "commitGUID6",
      string: "string",
      number: 23,
      bool:   YES
    };
    json7 = {
      guid: "commitGUID7",
      string: "string",
      number: 23,
      bool:   YES
    };
    json8 = {
      guid: "commitGUID8",
      string: "string",
      number: 23,
      bool:   YES
    };
    json9 = {
      guid: "commitGUID9",
      string: "string",
      number: 23,
      bool:   YES
    };
    json10 = {
      guid: "commitGUID10",
      string: "string",
      number: 23,
      bool:   YES
    };
    json11 = {
      guid: "commitGUID11",
      string: "string",
      number: 23,
      bool:   YES
    };
    json12 = {
      guid: "commitGUID12",
      string: "string",
      number: 23,
      bool:   YES
    };
    json13 = {
      guid: "commitGUID13",
      string: "string",
      number: 23,
      bool:   YES
    };
    json14 = {
      guid: "commitGUID14",
      string: "string",
      number: 23,
      bool:   YES
    };
    json15 = {
      guid: "commitGUID15",
      string: "string",
      number: 23,
      bool:   YES
    };
    json16 = {
      guid: "commitGUID16",
      string: "string",
      number: 23,
      bool:   YES
    };
    storeKey1 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey1, json1, SC.Record.READY_CLEAN);
    storeKey2 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey2, json2, SC.Record.BUSY_LOADING);
    storeKey3 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey3, json3, SC.Record.BUSY_CREATING);
    storeKey4 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey4, json4, SC.Record.BUSY_COMMITTING);
    storeKey5 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey5, json5, SC.Record.BUSY_REFRESH_CLEAN);
    storeKey6 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey6, json6, SC.Record.BUSY_REFRESH_DIRTY);
    storeKey7 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey7, json7, SC.Record.BUSY_DESTROYING);
    storeKey8 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey8, json8, SC.Record.BUSY);
  
    storeKey9 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey9, json9, SC.Record.READY_CLEAN);
    storeKey10 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey10, json10, SC.Record.BUSY_DESTROYING);
    storeKey11 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey11, json11, SC.Record.BUSY_CREATING);
  
    storeKey12 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey12, json12, SC.Record.READY_CLEAN);
    storeKey13 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey13, json13, SC.Record.BUSY_CREATING);
  
    storeKey14 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey14, json14, SC.Record.READY_CLEAN);
    storeKey15 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey15, json15, SC.Record.BUSY_CREATING);

    storeKey16 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey16, json16, SC.Record.BUSY_LOADING);
  
    SC.RunLoop.begin();
  
  },
  
  teardown: function() {
    SC.RunLoop.end();
  }
});

test("Confirm that dataSourceDidCancel switched the records to the right states", function() {
  var msg='', status;
  try{
    store.dataSourceDidCancel(storeKey1);
    msg='';  
  }catch(error){
    msg=error.message;
  }
  equals(SC.Record.BAD_STATE_ERROR.message, msg, 
    "should throw the following error ");
  
  store.dataSourceDidCancel(storeKey2);
  status = store.readStatus( storeKey2);
  equals(status, SC.Record.EMPTY, "the status should have changed to EMPTY");
  
  store.dataSourceDidCancel(storeKey3);
  status = store.readStatus( storeKey3);
  equals(status, SC.Record.READY_NEW, "the status should have changed to READY_NEW");
  
  store.dataSourceDidCancel(storeKey4);
  status = store.readStatus( storeKey4);
  equals(status, SC.Record.READY_DIRTY, "the status should have changed to READY_DIRTY");
  
  store.dataSourceDidCancel(storeKey5);
  status = store.readStatus( storeKey5);
  equals(status, SC.Record.READY_CLEAN, "the status should have changed to READY_CLEAN");
  
  store.dataSourceDidCancel(storeKey6);
  status = store.readStatus( storeKey6);
  equals(status, SC.Record.READY_DIRTY, "the status should have changed to READY_DIRTY");
  
  store.dataSourceDidCancel(storeKey7);
  status = store.readStatus( storeKey7);
  equals(status, SC.Record.DESTROYED_DIRTY, "the status should have changed to DESTROYED_DIRTY");
  
  try{
    store.dataSourceDidCancel(storeKey8);  
    msg='';
  }catch(error){
    msg=error.message;
  }
  equals(SC.Record.BAD_STATE_ERROR.message, msg, 
    "should throw the following error ");
  
});


test("Confirm that dataSourceDidComplete switched the records to the right states", function() {
  var msg='', status;
  try{
    store.dataSourceDidComplete(storeKey9);
    msg='';  
  }catch(error){
    msg=error.message;
  }
  equals(SC.Record.BAD_STATE_ERROR.message, msg, 
    "should throw the following error ");

  try{
    store.dataSourceDidComplete(storeKey10);  
    msg='';
  }catch(error){
    msg=error.message;
  }
  equals(SC.Record.BAD_STATE_ERROR.message, msg, 
    "should throw the following error ");
  
  store.dataSourceDidComplete(storeKey11);
  status = store.readStatus( storeKey11);
  equals(status, SC.Record.READY_CLEAN, "the status should have changed to READY_CLEAN.");
  
});


test("Confirm that dataSourceDidDestroy switched the records to the right states", function() {
  var msg='', status;
  try{
    store.dataSourceDidDestroy(storeKey12);  
    msg='';
  }catch(error){
    msg=error.message;
  }  
  equals(SC.Record.BAD_STATE_ERROR.message, msg, 
    "should throw the following error ");
  
  store.dataSourceDidDestroy(storeKey13);
  status = store.readStatus( storeKey13);
  equals(status, SC.Record.DESTROYED_CLEAN, "the status should have changed to DESTROYED_CLEAN.");
  
});


test("Confirm that dataSourceDidError switched the records to the right states", function() {
  var msg='', status;
  try{
    store.dataSourceDidError(storeKey14, SC.Record.BAD_STATE_ERROR);  
    msg='';
  }catch(error){
    msg = error.message;
  }
  equals(SC.Record.BAD_STATE_ERROR.message, msg, 
    "should throw the following error ");

  store.dataSourceDidError(storeKey15, SC.Record.BAD_STATE_ERROR);
  status = store.readStatus( storeKey15);
  equals(status, SC.Record.ERROR, 
    "the status shouldn't have changed.");
});

test("Confirm that errors passed to dataSourceDidError make it into the recordErrors array", function() {
  var msg = '';

  ok(!store.recordErrors, "recordErrors should be null at this point");

  try {
    store.dataSourceDidError(storeKey16, SC.Record.GENERIC_ERROR);
  } catch (error) {
    msg = error.message;
  }
 
  equals(store.recordErrors[storeKey16], SC.Record.GENERIC_ERROR,
    "recordErrors[storeKey] should be the right error object");
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/store/destroyRecord.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

var store, storeKey1,storeKey2,storeKey3,storeKey4,storeKey5, storeKey6, json;
var json1, json2, json3, json4, json5, json6;

module("SC.Store#destroyRecord", {
  setup: function() {

    SC.RunLoop.begin();

    store = SC.Store.create();
    
    json1 = {
      guid: "destroyGUID1",
      string: "string",
      number: 23,
      bool:   YES
    };
    json2 = {
      guid: "destroyGUID2",
      string: "string",
      number: 23,
      bool:   YES
    };
    json3 = {
      guid: "destroyGUID3",
      string: "string",
      number: 23,
      bool:   YES
    };
    json4 = {
      guid: "destroyGUID4",
      string: "string",
      number: 23,
      bool:   YES
    };
    json5 = {
      guid: "destroyGUID5",
      string: "string",
      number: 23,
      bool:   YES
    };
    json6 = {
      guid: "destroyGUID6",
      string: "string",
      number: 23,
      bool:   YES
    };
    
    storeKey1 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey1, json1, SC.Record.BUSY_DESTROYING);
    storeKey2 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey2, json2, SC.Record.DESTROYED);
    storeKey3 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey3, json3, SC.Record.EMPTY);
    storeKey4 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey4, json4, SC.Record.BUSY);
    storeKey5 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey5, json5, SC.Record.READY_NEW);
    storeKey6 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey6, json6, SC.Record.READY_CLEAN);

    SC.RunLoop.end();
  }
});

test("Check for different states after/before executing destroyRecord", function() {
  var throwError=false, msg, status;

  store.destroyRecord(undefined, undefined, storeKey1);
  status = store.readStatus( storeKey1);
  equals(status, SC.Record.BUSY_DESTROYING, "the status shouldn't have changed. It should be BUSY_DESTROYING ");
  
  store.destroyRecord(undefined, undefined, storeKey2);
  status = store.readStatus( storeKey2);
  equals(status, SC.Record.DESTROYED, "the status shouldn't have changed. It should be DESTROYED ");
  
  try{
    store.destroyRecord(undefined, undefined, storeKey3);
    msg='';
  }catch(error1){
    msg=error1.message;
  }
  equals(msg, SC.Record.NOT_FOUND_ERROR.message, "destroyRecord should throw the following error");
  
  try{
    store.destroyRecord(undefined, undefined, storeKey4);
    msg='';
  }catch(error2){
    msg=error2.message;
  }
  equals(msg, SC.Record.BUSY_ERROR.message, "destroyRecord should throw the following error");
  
  store.destroyRecord(undefined, undefined, storeKey5);
  status = store.readStatus( storeKey5);
  equals(status, SC.Record.DESTROYED_CLEAN, "the status should have changed to DESTROYED_CLEAN ");
  
  store.destroyRecord(undefined, undefined, storeKey6);
  status = store.readStatus( storeKey6);
  equals(status, SC.Record.DESTROYED_DIRTY, "the status should have changed to DESTROYED_DIRTY ");
  
  equals(store.changelog.length, 1, "The changelog has the following number of entries:");
  
  
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/store/error_methods.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

var store, Application;

module("SC.Store Error Methods", {
  setup: function() {

    Application = {};
    Application.Thing = SC.Record.extend({
      name: SC.Record.attr(String)
    });

    SC.RunLoop.begin();
    store = SC.Store.create();

    var records = [
      { guid: 1, name: 'Thing One' },
      { guid: 2, name: 'Thing Two' }
    ];

    var types = [ Application.Thing, Application.Thing ];

    store.loadRecords(types, records);
    SC.RunLoop.end();
  },

  teardown: function() {
    store = null;
    Application = null;
  }
});

test("Verify readError() returns correct errors", function() {
  var thing1 = store.find(Application.Thing, 1);
  var storeKey = thing1.get('storeKey');

  SC.RunLoop.begin();
  store.writeStatus(storeKey, SC.Record.BUSY_LOADING);
  store.dataSourceDidError(storeKey, SC.Record.GENERIC_ERROR);
  SC.RunLoop.end();

  equals(store.readError(storeKey), SC.Record.GENERIC_ERROR,
    "store.readError(storeKey) should return the correct error object");
});

test("Verify readQueryError() returns correct errors", function() {
  var q = SC.Query.local(Application.Thing);
  var things = store.find(q);

  SC.RunLoop.begin();
  things.set('status', SC.Record.BUSY_LOADING);
  store.dataSourceDidErrorQuery(q, SC.Record.GENERIC_ERROR);
  SC.RunLoop.end();

  equals(store.readQueryError(q), SC.Record.GENERIC_ERROR,
    "store.readQueryError(q) should return the correct error object");
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/store/find.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// test querying through find() on the store
module("SC.Query querying find() on a store", {
  setup: function() {
    SC.RunLoop.begin();
    // setup dummy app and store
    MyApp = SC.Object.create({});

    // setup a dummy model
    MyApp.Foo = SC.Record.extend();
    MyApp.Bar = SC.Record.extend();

    // setup data source that just returns cached storeKeys
    MyApp.DataSource = SC.DataSource.create({

      fetch: function(store, query) {
        this.query = query;
        this.store = store;
        this.fetchCount++ ;

        // used by tests to verify remote queries
        if (query.get('location') === SC.Query.REMOTE) {
          if (query.get('recordType') === MyApp.Foo) {
            store.loadQueryResults(query, this.get('storeKeys'));
          }
        }

        return YES ;
      },

      reset: function() {
        this.query = this.store = null ;
        this.fetchCount = this.prepareCount = 0 ;
      },

      fetchEquals: function(store, query, count, desc) {
        if (desc===undefined && typeof count === 'string') {
          desc = count;  count = undefined;
        }
        if (count===undefined) count = 1;

        equals(this.store, store, desc + ': should get store');
        equals(this.query, query, desc + ': should get query');
        equals(this.fetchCount, count, desc + ': should get count');
      },

      destroyRecord: function(store, storeKey){
        store.dataSourceDidDestroy(storeKey);
        return YES;
      }

    });

    MyApp.store = SC.Store.create().from(MyApp.DataSource);

    var records = [
      { guid: 1, firstName: "John", lastName: "Doe", married: true },
      { guid: 2, firstName: "Jane", lastName: "Doe", married: false },
      { guid: 3, firstName: "Emily", lastName: "Parker", bornIn: 1975, married: true },
      { guid: 4, firstName: "Johnny", lastName: "Cash", married: true },
      { guid: 5, firstName: "Bert", lastName: "Berthold", married: true }
    ];

    // load some data
    MyApp.DataSource.storeKeys = MyApp.store.loadRecords(MyApp.Foo, records);
    SC.RunLoop.end();

    SC.RunLoop.begin();
    // for sanity check, load two record types
    MyApp.store.loadRecords(MyApp.Bar, records);
    SC.RunLoop.end();

  },

  teardown: function() {
    MyApp = null ;
    SC.Record.subclasses.clear(); //reset
  }

});

// ..........................................................
// FINDING SINGLE RECORDS
//

test("find(recordType, id)", function() {

  equals(MyApp.store.find('MyApp.Foo', 1).get('firstName'), 'John', 'should return foo(1)');
  equals(MyApp.store.find(MyApp.Foo, 1).get('firstName'), 'John', 'should return foo(1)');
});

test("find(record)", function() {

  var rec1 = MyApp.store.find(MyApp.Foo, 1);
  equals(MyApp.store.find(rec1), rec1, 'find(rec1) should return rec1');

  var rec2 = MyApp.store.chain().find(rec1);
  ok(rec2 !== rec1, 'nested.find(rec1) should not return same instance');
  equals(rec2.get('storeKey'), rec1.get('storeKey'), 'nested.find(rec1) should return same record in nested store');
});

// ..........................................................
// RECORD ARRAY CACHING
//

test("caching for a single store", function() {
  var r1 = MyApp.store.find(MyApp.Foo);
  var r2 = MyApp.store.find(MyApp.Foo);
  ok(!!r1, 'should return a record array');
  ok(r1.isEnumerable, 'returned item should be enumerable');
  equals(r1.get('store'), MyApp.store, 'return object should be owned by store');
  equals(r2, r1, 'should return same record array for multiple calls');
});

test("find() caching for a chained store", function() {
  var r1 = MyApp.store.find(MyApp.Foo);

  var child = MyApp.store.chain();
  var r2 = child.find(MyApp.Foo);
  var r3 = child.find(MyApp.Foo);

  ok(!!r1, 'should return a record array from base store');
  equals(r1.get('store'), MyApp.store, 'return object should be owned by store');

  ok(!!r2, 'should return a recurd array from child store');
  equals(r2.get('store'), child, 'return object should be owned by child store');

  ok(r2 !== r1, 'return value for child store should not be same as parent');
  equals(r3, r2, 'return value from child store should be the same after multiple calls');

  // check underlying queries
  ok(!!r1.get('query'), 'record array should have a query');
  equals(r2.get('query'), r1.get('query'), 'record arrays from parent and child stores should share the same query');
});

test("data source must get the right calls", function() {
  var ds = MyApp.store.get('dataSource');

  ds.reset();
  var records = MyApp.store.find(MyApp.Foo);
  var q = SC.Query.local(MyApp.Foo);
  ds.fetchEquals(MyApp.store, q, 'after fetch');
});

// ..........................................................
// RECORD PROPERTIES
//

test("should find records based on boolean", function() {
  SC.RunLoop.begin();
  var q = SC.Query.local(MyApp.Foo, "married=YES");
  var records = MyApp.store.find(q);
  equals(records.get('length'), 4, 'record length should be 4');
  SC.RunLoop.end();
});

test("should find records based on query string", function() {

  SC.RunLoop.begin();
  var q = SC.Query.local(MyApp.Foo, { conditions:"firstName = 'John'" });
  var records = MyApp.store.find(q);
  equals(records.get('length'), 1, 'record length should be 1');
  equals(records.objectAt(0).get('firstName'), 'John', 'name should be John');
  SC.RunLoop.end();
});

test("should find records based on SC.Query", function() {
  var q = SC.Query.create({
    recordType: MyApp.Foo,
    conditions:"firstName = 'Jane'"
  });

  var records = MyApp.store.find(q);

  equals(records.get('length'), 1, 'record length should be 1');
  equals(records.objectAt(0).get('firstName'), 'Jane', 'name should be Jane');
});

test("modifying a record should update RecordArray automatically", function() {
  var q    = SC.Query.local(MyApp.Foo, "firstName = 'Jane'"),
      recs = MyApp.store.find(q);

  equals(recs.get('length'), 1, 'record length should be 1');
  equals(recs.objectAt(0).get('firstName'), 'Jane', 'name should be Jane');

  SC.RunLoop.begin();

  var r2 = MyApp.store.find(MyApp.Foo, 3);
  ok(r2.get('firstName') !== 'Jane', 'precond - firstName is not Jane');
  r2.set('firstName', 'Jane');

  SC.RunLoop.end();

  equals(recs.get('length'), 2, 'record length should increase');
  same(recs.getEach('firstName'), ['Jane', 'Jane'], 'check all firstNames are Jane');

  // try the other direction...
  SC.RunLoop.begin();
  r2.set('firstName', 'Ester');
  SC.RunLoop.end();

  equals(recs.get('length'), 1, 'record length should decrease');

});

test("should find records based on SC.Query without recordType", function() {

  var q = SC.Query.local(SC.Record, { conditions: "lastName = 'Doe'", orderBy: "firstName" });

  var records = MyApp.store.find(q);
  equals(records.get('length'), 4, 'record length should be 4');

  same(records.getEach('firstName'), 'Jane Jane John John'.w(), 'firstNames should match');
});

test("should find records within a passed record array", function() {

  SC.RunLoop.begin();

  var q = SC.Query.create({
    recordType: MyApp.Foo,
    conditions: "firstName = 'Emily'"
  });

  var recArray = MyApp.store.find(MyApp.Foo);
  var records  = recArray.find(q);

  equals(records.get('length'), 1, 'record length should be 1');
  equals(records.objectAt(0).get('firstName'), 'Emily', 'name should be Emily');

  SC.RunLoop.end();

});

test("sending a new store key array from the data source should update record array", function() {

  var q       = SC.Query.remote(MyApp.Foo),
      records = MyApp.store.find(q);

  SC.RunLoop.begin();
  equals(records.get('length'), 5, 'record length should be 5');
  SC.RunLoop.end();

  var newStoreKeys = MyApp.DataSource.storeKeys.copy();
  newStoreKeys.pop();

  // .replace() will call .enumerableContentDidChange()
  SC.RunLoop.begin();
  MyApp.store.loadQueryResults(q, newStoreKeys);
  SC.RunLoop.end();

  equals(records.get('length'), 4, 'record length should be 4');

});


test("loading more data into the store should propagate to record array", function() {

  var records = MyApp.store.find(MyApp.Foo);

  equals(records.get('length'), 5, 'record length before should be 5');

  SC.RunLoop.begin();

  var newStoreKeys = MyApp.store.loadRecords(MyApp.Foo, [
    { guid: 10, firstName: "John", lastName: "Johnson" }
  ]);

  SC.RunLoop.end();

  equals(records.get('length'), 6, 'record length after should be 6');
});

test("loading more data into the store should propagate to record array with query", function() {

  var q = SC.Query.local(MyApp.Foo, "firstName = 'John'"),
      records = MyApp.store.find(q);

  equals(records.get('length'), 1, 'record length before should be 1');

  SC.RunLoop.begin();
  var newStoreKeys = MyApp.store.loadRecords(MyApp.Foo, [
    { guid: 10, firstName: "John", lastName: "Johnson" }
  ]);
  SC.RunLoop.end();

  // .replace() will call .enumerableContentDidChange()
  // and should fire original SC.Query again
  equals(records.get('length'), 2, 'record length after should be 2');

  // subsequent updates to store keys should also work
  SC.RunLoop.begin();
  var newStoreKeys2 = MyApp.store.loadRecords(MyApp.Foo, [
    { guid: 11, firstName: "John", lastName: "Norman" }
  ]);
  SC.RunLoop.end();

  equals(records.get('length'), 3, 'record length after should be 3');
});

test("Loading records after SC.Query should show up", function() {

  var q = SC.Query.local(MyApp.Foo, "firstName = 'John'"),
      records = MyApp.store.find(q);

  equals(records.get('length'), 1, 'record length should be 1');
  equals(records.objectAt(0).get('firstName'), 'John', 'name should be John');

  var recordsToLoad = [
    { guid: 20, firstName: "John", lastName: "Johnson" },
    { guid: 21, firstName: "John", lastName: "Anderson" },
    { guid: 22, firstName: "Barbara", lastName: "Jones" }
  ];

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Foo, recordsToLoad);
  SC.RunLoop.end();

  equals(records.get('length'), 3, 'record length should be 3');

  equals(records.objectAt(0).get('firstName'), 'John', 'name should be John');
  equals(records.objectAt(1).get('firstName'), 'John', 'name should be John');
  equals(records.objectAt(2).get('firstName'), 'John', 'name should be John');
});

test("Loading records after getting empty record array based on SC.Query should update", function() {

  var q = SC.Query.local(MyApp.Foo, "firstName = 'Maria'");
  var records = MyApp.store.find(q);
  equals(records.get('length'), 0, 'record length should be 0');

  var recordsToLoad = [
    { guid: 20, firstName: "Maria", lastName: "Johnson" }
  ];

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Foo, recordsToLoad);
  SC.RunLoop.end();

  equals(records.get('length'), 1, 'record length should be 1');

  equals(records.objectAt(0).get('firstName'), 'Maria', 'name should be Maria');
});

test("Changing a record should make it show up in RecordArrays based on SC.Query", function() {

  var q, records, record;

  q = SC.Query.local(MyApp.Foo, "firstName = 'Maria'");
  records = MyApp.store.find(q);
  equals(records.get('length'), 0, 'record length should be 0');

  SC.RunLoop.begin();
  record = MyApp.store.find(MyApp.Foo, 1);
  record.set('firstName', 'Maria');
  SC.RunLoop.end();

  equals(records.get('length'), 1, 'record length should be 1');
  equals(records.objectAt(0).get('firstName'), 'Maria', 'name should be Maria');
});

test("Deleting a record should make the RecordArray based on SC.Query update accordingly", function() {

  var q, records;

  q = SC.Query.local(MyApp.Foo, "firstName = 'John'");
  records = MyApp.store.find(q);
  equals(records.get('length'), 1, 'record length should be 1');

  SC.RunLoop.begin();
  records.objectAt(0).destroy();
  SC.RunLoop.end();

  equals(records.get('length'), 0, 'record length should be 0');
});

test("Using find() with SC.Query on store with no data source should work", function() {

  var q, records, recordsToLoad;

  SC.RunLoop.begin();

  // create a store with no data source
  MyApp.store3 = SC.Store.create();

  q = SC.Query.local(MyApp.Foo, "firstName = 'John'");
  records = MyApp.store3.find(q);
  equals(records.get('length'), 0, 'record length should be 0');

  recordsToLoad = [
    { guid: 20, firstName: "John", lastName: "Johnson" },
    { guid: 21, firstName: "John", lastName: "Anderson" },
    { guid: 22, firstName: "Barbara", lastName: "Jones" }
  ];

  MyApp.store3.loadRecords(MyApp.Foo, recordsToLoad);

  SC.RunLoop.end();

  equals(records.get('length'), 2, 'record length should be 2');
});

test("Using orderBy in SC.Query returned from find()", function() {

  var q, records;

  q = SC.Query.local(MyApp.Foo, { orderBy: "firstName ASC" });
  records = MyApp.store.find(q);
  equals(records.get('length'), 5, 'record length should be 5');

  same(records.getEach('firstName'), ["Bert", "Emily", "Jane", "John", "Johnny"], 'first name should be properly sorted');
});

test("Using orderBy in SC.Query returned from find() and loading more records to original store key array", function() {

  var q, records, newStoreKeys2;

  q = SC.Query.local(MyApp.Foo, { orderBy:"firstName ASC" });
  records = MyApp.store.find(q);
  equals(records.get('length'), 5, 'record length should be 5');

  equals(records.objectAt(0).get('firstName'), 'Bert', 'name should be Bert');
  equals(records.objectAt(4).get('firstName'), 'Johnny', 'name should be Johnny');

  SC.RunLoop.begin();
  newStoreKeys2 = MyApp.store.loadRecords(MyApp.Foo, [
    { guid: 11, firstName: "Anna", lastName: "Petterson" }
  ]);
  SC.RunLoop.end();

  equals(records.objectAt(0).get('firstName'), 'Anna', 'name should be Anna');
  equals(records.objectAt(1).get('firstName'), 'Bert', 'name should be Bert');
  equals(records.objectAt(5).get('firstName'), 'Johnny', 'name should be Johnny');

});


test("Using orderBy in SC.Query and loading more records to the store", function() {

  var q, records;

  SC.RunLoop.begin();
  q = SC.Query.local(MyApp.Foo, { orderBy:"firstName ASC" });
  records = MyApp.store.find(q);
  equals(records.get('length'), 5, 'record length should be 5');
  equals(records.objectAt(0).get('firstName'), 'Bert', 'name should be Bert');

  MyApp.store.loadRecords(MyApp.Foo, [
    { guid: 11, firstName: "Anna", lastName: "Petterson" }
  ]);
  SC.RunLoop.end();

  equals(records.get('length'), 6, 'record length should be 6');

  equals(records.objectAt(0).get('firstName'), 'Anna', 'name should be Anna');
  equals(records.objectAt(5).get('firstName'), 'Johnny', 'name should be Johnny');

});

test("Chaining find() queries", function() {

  var q, records, q2, records2;

  q = SC.Query.local(MyApp.Foo, "lastName='Doe'");
  records = MyApp.store.find(q);
  equals(records.get('length'), 2, 'record length should be 2');

  q2 = SC.Query.local(MyApp.Foo, "firstName='John'");
  records2 = records.find(q2);

  equals(records2.get('length'), 1, 'record length should be 1');
  equals(records2.objectAt(0).get('firstName'), 'John', 'name should be John');

});

test("Chaining find() queries and loading more records", function() {

  var q, q2, records;

  SC.RunLoop.begin();
  q = SC.Query.local(MyApp.Foo, "lastName='Doe'");
  q2 = SC.Query.local(MyApp.Foo, "firstName='John'");

  records = MyApp.store.find(q).find(q2);
  equals(records.get('length'), 1, 'record length should be 1');

  MyApp.store.loadRecords(MyApp.Foo, [
    { guid: 11, firstName: "John", lastName: "Doe" }
  ]);
  SC.RunLoop.end();

  equals(records.get('length'), 2, 'record length should be 2');
});


module("create record");

test("creating record appears in future find()", function() {
  var Rec, store, r;

  Rec = SC.Record.extend({ title: SC.Record.attr(String) });
  store = SC.Store.create();

  SC.run(function() {
    store.loadRecords(Rec,
      [ { title: "A", guid: 1 },
        { title: "B", guid: 2 } ]);
  });

  equals(store.find(Rec).get('length'), 2, 'should have two initial record');

  SC.run(function() {
    store.createRecord(Rec, { title: "C" });

    // NOTE: calling find() here should flush changes to the record arrays
    // so that find() always returns an accurate result
    r = store.find(Rec);
    equals(r.get('length'), 3, 'should return additional record');
  });

  r = store.find(Rec);
  equals(r.get('length'), 3, 'should return additional record');
});


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/store/init.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// This file tests the initial state of the store when it is first created
// either independently or as a chained store.

module("SC.Store#init");

test("initial setup for root store", function() {
  var store = SC.Store.create();
  
  equals(SC.typeOf(store.dataHashes), SC.T_HASH, 'should have dataHashes');
  equals(SC.typeOf(store.revisions), SC.T_HASH, 'should have revisions');
  equals(SC.typeOf(store.statuses), SC.T_HASH, 'should have statuses');
  ok(!store.editables, 'should not have editables');
  ok(!store.recordErrors, 'should not have recordErrors');
  ok(!store.queryErrors, 'should not have queryErrors');
}); 


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/store/loadRecord.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

var store, dataHashes;
var Person;


module("SC.Store#loadRecord", {
  setup: function() {
  
    Person = SC.Record.extend({
      first: SC.Record.attr(String, { isRequired: YES}),
      last: SC.Record.attr(String),
      age: SC.Record.attr(Number),
      isAlive: SC.Record.attr(Boolean)
    });
    
    SC.RunLoop.begin();

    store = SC.Store.create();
    
    dataHashes = [ 
    
    Person.create({ 
      guid: 1,
      first: "John",
      last: "Sproutish",
      age: 35,
      isAlive: YES}),
      
    Person.create({
      guid: 2,
      first: "Sarah",
      last: "Coop",
      age: 28,
      isAlive: YES })];

    SC.RunLoop.end();
  }
});

test("loadRecord loads new / update existing record in store", function() {
  var aDataHash = dataHashes[0];  
  var storeKey = store.loadRecord(Person, aDataHash);
  ok(storeKey, "A store key is generated for a new record.");
  
  var doesStoreKeyResolveToPK = aDataHash.get('guid') === store.idFor(storeKey);
  ok(doesStoreKeyResolveToPK, "The storeKey resolves to the correct Primary Key");
  
  var isStatusCorrect = store.peekStatus(storeKey) & SC.Record.READY_CLEAN;
  ok(isStatusCorrect, "Record is in SC.Record.READY_CLEAN state after loading into store.");
  
  // Change the record
  aDataHash['age'] = 40;
  var storeKeyAfterUpdate = store.loadRecord(Person, aDataHash);
  ok(storeKey === storeKeyAfterUpdate, "When the same record is loaded a second time its store key remains unchanged.");
  
  var record = store.materializeRecord(storeKey);
  ok(record.get('age') === 40, "Record in store is updated with new values from data hash.");  
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/store/loadRecords.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

(function() {
  var store, people, places, Person, Place;

  module("SC.Store#loadRecords", {
    setup: function() {
      Person = SC.Record.extend({
        first: SC.Record.attr(String, { isRequired: YES}),
        last: SC.Record.attr(String),
        age: SC.Record.attr(Number),
        isAlive: SC.Record.attr(Boolean)
      });

      Place = SC.Record.extend({
        name: SC.Record.attr(String)
      });

      SC.RunLoop.begin();

      store = SC.Store.create();

      people = [ 
        Person.create({ 
          guid: 1,
          first: "John",
          last: "Sproutish",
          age: 35,
          isAlive: YES
        }),
        Person.create({
          guid: 2,
          first: "Sarah",
          last: "Coop",
          age: 28,
          isAlive: YES
        })
      ];

      places = [
        Place.create({
          guid: 3,
          name: "San Francisco"
        }),
        Place.create({
          guid: 4,
          name: "St. John's"
        })
      ];

      SC.RunLoop.end();
    },
    teardown: function() {
      store = people = places = Person = Place = null;
    }
  });

  test("loadRecords with single Record type loads new records in store", function() {
    var storeKeys = store.loadRecords(Person, people),
        isStatusCorrect;

    ok(SC.isArray(storeKeys), "An array of store keys is returned");

    storeKeys.forEach(function(storeKey, index) {
      equals(store.idFor(storeKeys[index]), people[index].get('guid'), "The storeKey resolves to the correct Primary Key for index %@".fmt(index));

      ok(store.peekStatus(storeKey) & SC.Record.READY_CLEAN, "Record is in SC.Record.READY_CLEAN state after loading into store for index %@".fmt(index));
    });
  });

  test("loadRecords with multiple Record types loads new records in store", function() {
    var things = [],
        types = [Person, Person, Place, Place],
        storeKeys, record;

    things.pushObjects(people);
    things.pushObjects(places);

    things.forEach(function(thing, index) {
      ok(SC.kindOf(thing, types[index]), "precond - types array contains correct record type for index %@".fmt(index));
    });

    storeKeys = store.loadRecords(types, things);

    ok(SC.isArray(storeKeys), "An array of store keys is returned");

    storeKeys.forEach(function(storeKey, index) {
      record = store.materializeRecord(storeKey);
      
      equals(store.idFor(storeKeys[index]), things[index].get('guid'), "The storeKey resolves to the correct Primary Key for index %@".fmt(index));
      ok(SC.kindOf(record, types[index]), "store returns a record of the correct type for index %@".fmt(index));
      ok(store.peekStatus(storeKey) & SC.Record.READY_CLEAN, "Record is in SC.Record.READY_CLEAN state after loading into store for index %@".fmt(index));
    });
  });
})();

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/store/pushChanges.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

var store, storeKey, json;
module("SC.Store#pushChanges", {
  setup: function() {
    SC.RunLoop.begin();
    store = SC.Store.create();
    
    json = {
      string: "string",
      number: 23,
      bool:   YES
    };
    
    storeKey1 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey1, json, SC.Record.EMPTY);

    storeKey2 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey2, json, SC.Record.EMPTY);

    storeKey3 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey3, json, SC.Record.EMPTY);

    storeKey4 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey4, json, SC.Record.BUSY_LOADING);

    storeKey5 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey5, json, SC.Record.BUSY_LOADING);

    storeKey6 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey6, json, SC.Record.BUSY_LOADING);
    SC.RunLoop.end();
  }
});

test("Do a pushRetrieve and check if there is conflicts", function() {
  var res = store.pushRetrieve(SC.Record, undefined, undefined, storeKey1);
  equals(res, storeKey1, "There is no conflict, pushRetrieve was succesful.");
  res = store.pushRetrieve(SC.Record, undefined, undefined, storeKey4);
  ok(!res, "There is a conflict, because of the state, this is expected.");
});

test("Do a pushDestroy and check if there is conflicts", function() {
  var res = store.pushDestroy(SC.Record, undefined, storeKey2);
  equals(res, storeKey2, "There is no conflict, pushDestroy was succesful.");
  res = store.pushRetrieve(SC.Record, undefined, undefined, storeKey5);
  ok(!res, "There is a conflict, because of the state, this is expected.");
});

test("Issue a pushError and check if there is conflicts", function() {
  var res = store.pushError(SC.Record, undefined, SC.Record.NOT_FOUND_ERROR, storeKey3);
  equals(res, storeKey3, "There is no conflict, pushError was succesful.");
  res = store.pushRetrieve(SC.Record, undefined, undefined, storeKey6);
  ok(!res, "There is a conflict, because of the state, this is expected.");
});

test("A pushRetrieve updating the id of an existing record should update the primary Key cache", function(){
  var tmpid, recFirst, recSecond, sK;
  
  tmpid = "@2345235asddsgfd";
  recFirst = { firstname: 'me', lastname: 'too', guid: tmpid };
  recSecond = { firstname: 'me', lastname: 'too', guid: 1 };
  SC.RunLoop.begin();
  var sK = store.loadRecord(SC.Record, recFirst, tmpid);
  SC.RunLoop.end();
  equals(store.idFor(sK),tmpid); //check whether the id is indeed tmpid
  SC.RunLoop.begin();
  store.pushRetrieve(SC.Record,1,recSecond,sK);
  SC.RunLoop.end();
  equals(store.idFor(sK),1); // id should now have been updated
});


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/store/pushRelationships.js"; 
}
(function() {
/*globals MyApp module test ok equals same stop start */

module("Propogating relationships with Store#pushRetrieve and Store#pushDestroy", {
  setup: function () {
    var MyApp = window.MyApp = SC.Object.create({
      store: SC.Store.create(SC.RelationshipSupport)
    });
  }
});

// ..........................................................
// pushRetrieve BEHAVIOR
//

/**
 [master] --> [slave]

  precond - master has a slave
  test - slave has a master
 */
test("Master updates a slave [one(master) to one(slave)].", function () {
  MyApp.Master = SC.Record.extend({
    slave: SC.Record.toOne('MyApp.Slave', {
      inverse: 'master',
      isMaster: YES
    })
  });

  MyApp.Slave = SC.Record.extend({
    master: SC.Record.toOne('MyApp.Master', {
      inverse: 'slave',
      isMaster: NO
    })
  });

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Slave, [
    { guid: 's1' }
  ]);

  MyApp.store.loadRecords(MyApp.Master, [
    { guid: 'm1', slave: 's1' }
  ]);
  SC.RunLoop.end();

  var s1 = MyApp.store.find(MyApp.Slave, 's1'),
      m1 = MyApp.store.find(MyApp.Master, 'm1');

  equals(m1.get('slave'), s1, 'precond - m1 should have a slave');
  equals(s1.get('master'), m1, 's1 should have a master');
});

/**
 [master]
  v
  |
  +--> [slave1]
  |
 ...
  |
  +--> [slaveN]

  precond - master has slaves
  test - slaves have a master
 */
test("A master updates many slave [one(master) to many(slave)].", function () {
  MyApp.Slave = SC.Record.extend({
    master: SC.Record.toOne('MyApp.Master', {
      inverse: 'slaves',
      isMaster: NO
    })
  });

  MyApp.Master = SC.Record.extend({
    slaves: SC.Record.toMany('MyApp.Slave', {
      inverse: 'master',
      isMaster: YES
    })
  });

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Slave, [
    { guid: 's1' },
    { guid: 's2' }
  ]);

  MyApp.store.loadRecords(MyApp.Master, [
    { guid: 'm1', slaves: ['s1', 's2'] }
  ]);
  SC.RunLoop.end();

  var s1 = MyApp.store.find(MyApp.Slave, 's1'),
      s2 = MyApp.store.find(MyApp.Slave, 's2'),
      m1 = MyApp.store.find(MyApp.Master, 'm1');

  equals(m1.get('slaves').length(), 2, 'precond - m1 has 2 slaves');
  equals(s1.get('master'), m1, 's1 should have master m1');
  equals(s2.get('master'), m1, 's2 should have master m1');
});

/**
 [slave]
  ^
  |
  +--< [master1]
  |
 ...
  |
  +--< [masterN]

  precond - master has a slave
  test - slave has many masters
 */
test("Many parent master updates a slave [many(master) to one(slave)]", function () {
  MyApp.Slave = SC.Record.extend({
    masters: SC.Record.toMany('MyApp.Master', {
      inverse: 'slave',
      isMaster: NO
    })
  });

  MyApp.Master = SC.Record.extend({
    slave: SC.Record.toOne('MyApp.Slave', {
      inverse: 'masters',
      isMaster: YES
    })
  });

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Slave, [
    { guid: 's1' }
  ]);

  MyApp.store.loadRecords(MyApp.Master, [
    { guid: 'm1', slave: 's1' },
    { guid: 'm2', slave: 's1' }
  ]);
  SC.RunLoop.end();

  var m1 = MyApp.store.find(MyApp.Master, 'm1'),
      m2 = MyApp.store.find(MyApp.Master, 'm2'),
      s1 = MyApp.store.find(MyApp.Slave, 's1');

  equals(m1.get('slave'), s1, 'precond - m1 should have slave s1');
  equals(m2.get('slave'), s1, 'precond - m2 should have slave s1');

  equals(s1.get('masters').length(), 2, 'slave has 2 masters');
  ok(s1.get('masters').indexOf(m1) !== -1, 'slave has master m1');
  ok(s1.get('masters').indexOf(m2) !== -1, 'slave has master m2');
});

/**
 [master1] ... [masterN]
  v             v
  |             |
  >------- ... -> [slave1]
  |             |
 ...           ...
  |             |
  >------- ... -> [slaveN]

  precond - masters have many slaves
  test - slaves have many masters
 */
test("Many masters update many slaves [many(master) to many(slave)]", function () {
  MyApp.Master = SC.Record.extend({
    slaves: SC.Record.toMany('MyApp.Slave', {
      inverse: 'masters',
      isMaster: YES
    })
  });

  MyApp.Slave = SC.Record.extend({
    masters: SC.Record.toMany('MyApp.Master', {
      inverse: 'slaves',
      isMaster: NO
    })
  });

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Slave, [
    { guid: 's1' },
    { guid: 's2' }
  ]);

  MyApp.store.loadRecords(MyApp.Master, [
    { guid: 'm1', slaves: ['s1', 's2'] },
    { guid: 'm2', slaves: ['s1', 's2'] }
  ]);
  SC.RunLoop.end();

  var m1 = MyApp.store.find(MyApp.Master, 'm1'),
      m2 = MyApp.store.find(MyApp.Master, 'm2'),
      s1 = MyApp.store.find(MyApp.Slave, 's1'),
      s2 = MyApp.store.find(MyApp.Slave, 's2');

  equals(m1.get('slaves').length(), 2, 'precond - m1 should have 2 slaves');
  equals(m2.get('slaves').length(), 2, 'precond - m2 should have 2 slaves');

  equals(s1.get('masters').length(), 2, 's1 should have 2 masters');
  ok(s1.get('masters').indexOf(m1) !== -1, 's1 should have m1 as a master');
  ok(s1.get('masters').indexOf(m2) !== -1, 's1 should have m2 as a master');

  equals(s2.get('masters').length(), 2, 's2 should have 2 masters');
  ok(s2.get('masters').indexOf(m1) !== -1, 's2 should have m1 as a master');
  ok(s2.get('masters').indexOf(m2) !== -1, 's2 should have m2 as a master');
});

/**
 [slave] >--- X ---> [*]

  precond - * is related to slave
  test - after update to slave, * is related to slave
 */
test("A slave does NOT update a relationship [one(slave) to *]", function () {
  MyApp.Slave = SC.Record.extend({
    relative: SC.Record.toOne('MyApp.Relative', {
      inverse: 'slave',
      isMaster: NO
    })
  });

  MyApp.Relative = SC.Record.extend({
    slave: SC.Record.toOne('MyApp.Slave', {
      inverse: 'relative',
      isMaster: YES
    })
  });

  // case create slave WITHOUT relationship
  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Slave, [
    { guid: 's1' }
  ]);

  MyApp.store.loadRecords(MyApp.Relative, [
    { guid: 'r1', slave: 's1' }
  ]);
  SC.RunLoop.end();

  var s1 = MyApp.store.find(MyApp.Slave, 's1'),
      r1 = MyApp.store.find(MyApp.Relative, 'r1');

  equals(s1.get('relative'), r1, 'precond1 - s1 has relative r1');

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Slave, [
    { guid: 's1' }
  ]);
  SC.RunLoop.end();

  ok(SC.none(s1.get('relative')), 'precond2 - s1 has no relative');
  equals(r1.get('slave'), s1, 'test1- r1 is related to s1');

  // case - create slave WITH relationship
  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Relative, [
    { guid: 'r2'}
  ]);

  MyApp.store.loadRecords(MyApp.Slave, [
    { guid: 's2', relative: 'r2' }
  ]);
  SC.RunLoop.end();

  var s2 = MyApp.store.find(MyApp.Slave, 's2'),
      r2 = MyApp.store.find(MyApp.Relative, 'r2');

  equals(s2.get('relative'), r2, 'precond3 - s2 is related to r2');
  ok(SC.none(r2.get('slave')), 'test2 - r2 should NOT have a slave');
});

/**
 [master1] <----> [master2]

  precond - master1 has master2
  test - master2 has master1
 */
test("A master will mutually update a master [one(master) to one(master)].", function () {
  MyApp.Master = SC.Record.extend({
    relative: SC.Record.toOne('MyApp.Master', {
      inverse: 'relative',
      isMaster: YES
    })
  });

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Master, [
    { guid: 'm1' }
  ]);

  MyApp.store.loadRecords(MyApp.Master, [
    { guid: 'm2', relative: 'm1' }
  ]);
  SC.RunLoop.end();

  var m1 = MyApp.store.find(MyApp.Master, 'm1'),
      m2 = MyApp.store.find(MyApp.Master, 'm2');

  equals(m1.get('relative'), m2, 'precond - m1 should have a relative "m2"');
  equals(m2.get('relative'), m1, 'm2 should have a relative "m1"');
});

// ..........................................................
// REPLACING RELATIONSHIPS
//

/**
 [master1] <--> [slave]

  precond - master1 has slave
  precond - slave has master1

 ...relate master2 to slave...

 [master1] --> [slave]
                ^
                |
 [master2] <----+

  precond - master2 has slave
  precond - slave has master2
  test - master1 has slave
 */
test("Stealing relationship does NOT propagate to other masters [one(master) to one(slave)]", function () {
  MyApp.Slave = SC.Record.extend({
    master: SC.Record.toOne('MyApp.Master', {
      inverse: 'slave',
      isMaster: NO
    })
  });

  MyApp.Master = SC.Record.extend({
    slave: SC.Record.toOne('MyApp.Slave', {
      inverse: 'master',
      isMaster: YES
    })
  });

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Slave, [
    { guid: 's1' }
  ]);

  MyApp.store.loadRecords(MyApp.Master, [
    { guid: 'm1', slave: 's1' }
  ]);
  SC.RunLoop.end();

  var s1 = MyApp.store.find(MyApp.Slave, 's1'),
      m1 = MyApp.store.find(MyApp.Master, 'm1');

  equals(m1.get('slave'), s1, 'precond - m1 should have s1');
  equals(s1.get('master'), m1, 'precond - s1 should relate to m1');

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Master, [
    { guid: 'm2', slave: 's1' }
  ]);
  SC.RunLoop.end();

  var m2 = MyApp.store.find(MyApp.Master, 'm2');

  equals(m2.get('slave'), s1, 'precond - m2 should have s1');
  equals(s1.get('master'), m2, 'precond - s1 should relate to m2');

  equals(m1.get('slave'), s1, 'm1 should have child s1');
});


// ..........................................................
// RELINQUISHING RELATIONSHIPS
//

/**
 [master] <----> [slave1]

  precond - master has slave1
  precond - slave1 has master

 [master] <----> [slave2]

            X--- [slave1]

  precond - master has slave2
  precond - slave2 has master

  test - slave1 does NOT have master
 */
test("Relinquishing relationship on master<->* does propagate [one(master) to one(*)]", function () {
  MyApp.Slave = SC.Record.extend({
    master: SC.Record.toOne('MyApp.Master', {
      inverse: 'slave',
      isMaster: NO
    })
  });

  MyApp.Master = SC.Record.extend({
    slave: SC.Record.toOne('MyApp.Slave', {
      inverse: 'master',
      isMaster: YES
    })
  });

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Slave, [
    { guid: 's1' },
    { guid: 's2' }
  ]);

  MyApp.store.loadRecords(MyApp.Master, [
    { guid: 'm1', slave: 's1' }
  ]);
  SC.RunLoop.end();

  var s1 = MyApp.store.find(MyApp.Slave, 's1'),
      s2 = MyApp.store.find(MyApp.Slave, 's2'),
      m1 = MyApp.store.find(MyApp.Master, 'm1');

  equals(m1.get('slave'), s1, 'precond - m1 should have s1');
  equals(s1.get('master'), m1, 'precond - s1 should relate to m1');
  ok(SC.none(s2.get('master')), 'precond - s2 has NO master');

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Master, [
    { guid: 'm1', slave: 's2' }
  ]);
  SC.RunLoop.end();

  equals(m1.get('slave'), s2, 'precond - m1 should have s2');
  equals(s2.get('master'), m1, 'precond - s2 should relate to m1');

  ok(SC.none(s1.get('master')), 'test1 - s1 should have NO master');
});

/**
 [master] <----> [slave1, ..., slaveN]

  precond - master has slaves
  precond - slaves have master

 [master] ---X [slave1]

  precond - master does NOT have slave1
  test - slave1 does NOT have master
 */
test("Relinquishing a toMany relationship does propagate from master [one(master) to many(*)]", function () {
  MyApp.Slave = SC.Record.extend({
    master: SC.Record.toOne('MyApp.Master', {
      inverse: 'slaves',
      isMaster: NO
    })
  });

  MyApp.Master = SC.Record.extend({
    slaves: SC.Record.toMany('MyApp.Slave', {
      inverse: 'master',
      isMaster: YES
    })
  });

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Slave, [
    { guid: 's1' },
    { guid: 's2' }
  ]);

  MyApp.store.loadRecords(MyApp.Master, [
    { guid: 'm1', slaves: ['s1', 's2'] }
  ]);
  SC.RunLoop.end();

  var s1 = MyApp.store.find(MyApp.Slave, 's1'),
      s2 = MyApp.store.find(MyApp.Slave, 's2'),
      m1 = MyApp.store.find(MyApp.Master, 'm1');

  equals(m1.get('slaves').length(), 2, 'precond1 - m1 should have 2 slaves');
  equals(s1.get('master'), m1, 'precond2 - s1 should relate to m1');
  equals(s2.get('master'), m1, 'precond3 - s2 should relate to m1');

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Master, [
    { guid: 'm1', slaves: ['s1'] }
  ]);
  SC.RunLoop.end();

  equals(m1.get('slaves').length(), 1, 'precond4 - m1 should have 1 slave');
  equals(m1.get('slaves').objectAt(0), s1, 'precond5 - m1 should have slave s1');
  equals(s1.get('master'), m1, 'precond6 - s1 should relate to m1');

  ok(SC.none(s2.get('master')), 's2 should NOT have master');
});

/**
 [slave]
  ^
  |
  +--< [master1]
  |
 ...
  |
  +--< [masterN]

   precond - master1 has relationship to slave
   precond - slave has relationship many masters
   precond - slave has relationship to master1

  ...master1 relinquishes relationship to slave...

 [slave]
  ^
  |
 ...
  |
  +--< [masterN]

   precond - master1 has no slave
   test - slave has many masters, none of which is master1

 */
test("Relinquish propagates from many master to one slave [many(master) to one(slave)]", function () {
  MyApp.Master = SC.Record.extend({
    slave: SC.Record.toOne('MyApp.Slave', {
      inverse: 'masters',
      isMaster: YES
    })
  });

  MyApp.Slave = SC.Record.extend({
    masters: SC.Record.toMany('MyApp.Master', {
      inverse: 'slave',
      isMaster: NO
    })
  });

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Slave, [
    { guid: 's1' }
  ]);

  MyApp.store.loadRecords(MyApp.Master, [
    { guid: 'm1', slave: 's1' },
    { guid: 'm2', slave: 's1' }
  ]);
  SC.RunLoop.end();

  var m1 = MyApp.store.find(MyApp.Master, 'm1'),
      m2 = MyApp.store.find(MyApp.Master, 'm2'),
      s1 = MyApp.store.find(MyApp.Slave, 's1');

  equals(s1.get('masters').length(), 2, 'precond - s1 should have 2 masters');
  equals(m1.get('slave'), s1, 'precond - m1 should have slave s1');
  equals(m2.get('slave'), s1, 'precond - m2 should have slave s1');

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Master, [
    { guid: 'm1' }
  ]);
  SC.RunLoop.end();

  ok(SC.none(m1.get('slave')), 'precond - m1 should NOT have relationship with s1');
  equals(s1.get('masters').length(), 1, 's1 should have 1 master');
  equals(s1.get('masters').indexOf(m1), -1, 'm1 should NOT be that master');
});

/**
 [master1] ... [masterN]
  v             v
  |             |
  >------- ... -> [slave1]
  |             |
 ...           ...
  |             |
  >------- ... -> [slaveN]

  precond - masters have many slaves
  precond - slaves have many masters

  ... master1 relinquishes relationship to slave1 ...

 [master1] ... [masterN]
  v             v
  |             |
  >-- X         > [slave1]
  |             |
 ...           ...
  |             |
  >------- ... -> [slaveM]

  precond - master1 has M-1 slaves (& not slave 1)

  test - slave1 has N-1 masters
  test - slave does NOT have relationship to master1
 */
test("Removing a relationship propagates from many master to many slave [many(master) to many(slave)]", function () {
  MyApp.Master = SC.Record.extend({
    slaves: SC.Record.toMany('MyApp.Slave', {
      inverse: 'masters',
      isMaster: YES
    })
  });

  MyApp.Slave = SC.Record.extend({
    masters: SC.Record.toMany('MyApp.Master', {
      inverse: 'slaves',
      isMaster: NO
    })
  });

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Slave, [
    { guid: 's1' },
    { guid: 's2' }
  ]);

  MyApp.store.loadRecords(MyApp.Master, [
    { guid: 'm1', slaves: ['s1', 's2'] },
    { guid: 'm2', slaves: ['s1', 's2'] }
  ]);
  SC.RunLoop.end();

  var m1 = MyApp.store.find(MyApp.Master, 'm1'),
      m2 = MyApp.store.find(MyApp.Master, 'm2'),
      s1 = MyApp.store.find(MyApp.Slave, 's1'),
      s2 = MyApp.store.find(MyApp.Slave, 's2');

  equals(m1.get('slaves').length(), 2, 'precond - m1 should have 2 slaves');
  equals(m2.get('slaves').length(), 2, 'precond - m2 should have 2 slaves');
  ok(s1.get('masters').indexOf(m1) !== -1, 'precond - s1 should have m1 as a master');
  ok(s1.get('masters').indexOf(m2) !== -1, 'precond - s1 should have m2 as a master');
  ok(s2.get('masters').indexOf(m1) !== -1, 'precond - s2 should have m1 as a master');
  ok(s2.get('masters').indexOf(m2) !== -1, 'precond - s2 should have m2 as a master');

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Master, [
    { guid: 'm1', slaves: ['s2'] }
  ]);
  SC.RunLoop.end();

  equals(m1.get('slaves').length(), 1, 'precond - m1 should have 1 slave');
  equals(m1.get('slaves').objectAt(0), s2, 'precond - m1 should have relationship to s2');

  ok(s1.get('masters').indexOf(m1) === -1, 's1 should NOT have m1 as a master');
  ok(s1.get('masters').indexOf(m2) !== -1, 's1 should have m2 as a master');
});

// ..........................................................
// pushDestroy BEHAVIOR
//

/**
 [master] --> [slave]

  precond - master has slave
  precond - slave has master

 ... pushDestroy master ...

  test - slave has NO master
 */
test("pushDestroy record propagates from master to slave [*(master) to one(slave)]", function () {
  MyApp.Master = SC.Record.extend({
    slave: SC.Record.toOne('MyApp.Slave', {
      inverse: 'master',
      isMaster: YES
    })
  });

  MyApp.Slave = SC.Record.extend({
    master: SC.Record.toOne('MyApp.Master', {
      inverse: 'slave',
      isMaster: NO
    })
  });

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Slave, [
    { guid: 's1' }
  ]);

  MyApp.store.loadRecords(MyApp.Master, [
    { guid: 'm1', slave: 's1' }
  ]);
  SC.RunLoop.end();

  var m1 = MyApp.store.find(MyApp.Master, 'm1'),
      s1 = MyApp.store.find(MyApp.Slave, 's1');

  equals(m1.get('slave'), s1, 'precond - m1 should have s1 as slave');
  equals(s1.get('master'), m1, 'precond - s1 should have m1 as slave');

  SC.RunLoop.begin();
  MyApp.store.pushDestroy(MyApp.Master, 'm1');
  SC.RunLoop.end();

  equals(m1.get('status'), SC.Record.DESTROYED_CLEAN, 'precond - m1 was destroyed');
  ok(SC.none(s1.get('master')), 's1 should NOT have a master');
});

/**
 [master] --> [slave]

  precond - master has slave
  precond - slave has master

 ... pushDestroy master ...

  test - slave has NO master
 */
test("pushDestroy record propagates from master to many slaves [*(master) to many(slave)]", function () {
  MyApp.Master = SC.Record.extend({
    slaves: SC.Record.toMany('MyApp.Slave', {
      inverse: 'masters',
      isMaster: YES
    })
  });

  MyApp.Slave = SC.Record.extend({
    masters: SC.Record.toMany('MyApp.Master', {
      inverse: 'slaves',
      isMaster: NO
    })
  });

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Slave, [
    { guid: 's1' },
    { guid: 's2' }
  ]);

  MyApp.store.loadRecords(MyApp.Master, [
    { guid: 'm1', slaves: ['s1', 's2'] }
  ]);
  SC.RunLoop.end();

  var m1 = MyApp.store.find(MyApp.Master, 'm1'),
      s1 = MyApp.store.find(MyApp.Slave, 's1'),
      s2 = MyApp.store.find(MyApp.Slave, 's2');

  equals(m1.get('slaves').length(), 2, 'precond - m1 should have 2 slaves');
  ok(s1.get('masters').indexOf(m1) !== -1, 'precond - s1 should have m1 as a master');
  ok(s2.get('masters').indexOf(m1) !== -1, 'precond - s2 should have m1 as a master');

  SC.RunLoop.begin();
  MyApp.store.pushDestroy(MyApp.Master, 'm1');
  SC.RunLoop.end();

  equals(m1.get('status'), SC.Record.DESTROYED_CLEAN, 'precond - m1 was destroyed');
  equals(s1.get('masters').length(), 0, 's1 should NOT have a master');
  equals(s2.get('masters').length(), 0, 's2 should NOT have a master');
});

/**
  [master] --> [slave]

  precond - slave has a master
  precond - master has a slave

  slave.destroy();

  precond - slave is destroyed

  ... pushDestroy master ...

  test - slave does NOT exist
  test - master does NOT exist
 */
test("pushDestroy record doesn't create a slave when it's been destroyed [*(master) to one(slave)]", function () {
  MyApp.Master = SC.Record.extend({
    slave: SC.Record.toOne('MyApp.Slave', {
      inverse: 'master',
      isMaster: YES
    })
  });

  MyApp.Slave = SC.Record.extend({
    master: SC.Record.toOne('MyApp.Master', {
      inverse: 'slave',
      isMaster: NO
    })
  });

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Slave, [
    { guid: 's1' }
  ]);

  MyApp.store.loadRecords(MyApp.Master, [
    { guid: 'm1', slave: 's1' }
  ]);
  SC.RunLoop.end();

  var m1 = MyApp.store.find(MyApp.Master, 'm1'),
      s1 = MyApp.store.find(MyApp.Slave, 's1');

  equals(m1.get('slave'), s1, 'precond - m1 should have 2 slaves');
  equals(s1.get('master'), m1, 'precond - s1 should have m1 as a master');

  SC.RunLoop.begin();
  s1.destroy();
  MyApp.store.commitRecords();
  MyApp.store.dataSourceDidDestroy(s1.storeKey);
  SC.RunLoop.end();

  ok(s1.isDestroyed(), 'precond - s1 should be destroyed');

  SC.RunLoop.begin();
  MyApp.store.pushDestroy(MyApp.Master, 'm1');
  SC.RunLoop.end();

  ok(s1.isDestroyed(), 'test - s1 should be destroyed');
  ok(m1.isDestroyed(), 'test - m1 should be destroyed');
});

/**
  Standard Sproutcore Behaviors

  This is data showing up from the server- after pushing in changes,
  all records should have status READY_CLEAN.
 */
test("Record status for master and slave should be READY_CLEAN", function () {
  MyApp.Master = SC.Record.extend({
    master: SC.Record.toOne('MyApp.Slave', {
      inverse: 'slave',
      isMaster: YES
    })
  });

  MyApp.Slave = SC.Record.extend({
    slave: SC.Record.toOne('MyApp.Master', {
      inverse: 'master',
      isMaster: NO
    })
  });

  // link one -> one
  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Slave, [
    { guid: 's1' }
  ]);
  SC.RunLoop.end();

  var s1 = MyApp.store.find(MyApp.Slave, 's1');
  ok(s1.get('status') & SC.Record.READY_CLEAN, 'precond - s1 should be ready clean');

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Master, [
    { guid: 'm1', slave: 's1' }
  ]);
  SC.RunLoop.end();

  var m1 = MyApp.store.find(MyApp.Master, 'm1');

  ok(m1.get('status') & SC.Record.READY_CLEAN, 'm1 should be ready clean after linkage');
  ok(s1.get('status') & SC.Record.READY_CLEAN, 's1 should be ready clean after linkage');

  // unlink
  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Master, [
    { guid: 'm1' }
  ]);
  SC.RunLoop.end();

  ok(m1.get('status') & SC.Record.READY_CLEAN, 'm1 should be ready clean after unlink');
  ok(s1.get('status') & SC.Record.READY_CLEAN, 's1 should be ready clean after unlink');
});

test("Record relationships are NOT propagated if related store item does NOT exist at load time", function () {
  MyApp.Generic = SC.Record.extend({
    relative: SC.Record.toOne('MyApp.Generic', {
      inverse: 'relative',
      isMaster: YES
    })
  });

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Generic, [
    { guid: 'g2', relative: 'g1' },
    { guid: 'g1' }
  ]);
  SC.RunLoop.end();

  var g1 = MyApp.store.find(MyApp.Generic, 'g1'),
      g2 = MyApp.store.find(MyApp.Generic, 'g2');

  equals(g2.get('relative'), g1, 'precond - g2 should be relative of g1');
  ok(SC.none(g1.get('relative')), 'g1 should not be related to g2');
});

test("Record Attribute can reference renamed attribute key", function () {
  MyApp.Master = SC.Record.extend({
    slave: SC.Record.toOne('MyApp.Slave', {
      inverse: 'master',
      isMaster: YES,
      key: 'alice'
    })
  });

  MyApp.Slave = SC.Record.extend({
    master: SC.Record.toOne('MyApp.Master', {
      inverse: 'slave',
      isMaster: NO
    })
  });

  // link one -> one
  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Slave, [
    { guid: 's1' }
  ]);
  SC.RunLoop.end();


  var s1 = MyApp.store.find(MyApp.Slave, 's1');
  ok(s1.get('status') & SC.Record.READY_CLEAN, 'precond - s1 should be ready clean');

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Master, [
    { guid: 'm1', alice: 's1' }
  ]);
  SC.RunLoop.end();

  var m1 = MyApp.store.find(MyApp.Master, 'm1');

  equals(m1.get('slave'), s1, 'm1 should be master of s1');
  equals(s1.get('master'), m1, 's1 should have master of m1');
});

test("Record Attribute can reference renamed attribute key (1 to many)", function () {
  MyApp.Master = SC.Record.extend({
    slave: SC.Record.toOne('MyApp.Slave', {
      inverse: 'masters',
      isMaster: YES
    })
  });

  MyApp.Slave = SC.Record.extend({
    masters: SC.Record.toMany('MyApp.Master', {
      inverse: 'slave',
      isMaster: NO,
      key: 'master_ids'
    })
  });

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Slave, [
    { guid: 's1' }
  ]);
  SC.RunLoop.end();

  var s1 = MyApp.store.find(MyApp.Slave, 's1');
  ok(s1.get('status') & SC.Record.READY_CLEAN, 'precond - s1 should be ready clean');

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Master, [
    { guid: 'm1', slave: 's1' }
  ]);
  SC.RunLoop.end();

  var m1 = MyApp.store.find(MyApp.Master, 'm1');

  equals(m1.get('slave'), s1, 'm1 should be master of s1');
  same(s1.get('masters').toArray(), [m1], 's1 should have m1 in masters');
  same(s1.get('attributes').master_ids, [m1.get('id')], 's1.attributes should have master_ids key');
});

test("Record Attribute can reference renamed attribute key (on remote side)", function () {
  MyApp.Master = SC.Record.extend({
    slave: SC.Record.toOne('MyApp.Slave', {
      inverse: 'master',
      isMaster: YES
    })
  });

  MyApp.Slave = SC.Record.extend({
    master: SC.Record.toOne('MyApp.Master', {
      inverse: 'slave',
      isMaster: NO,
      key: 'bob'
    })
  });

  // link one -> one
  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Slave, [
    { guid: 's1' }
  ]);
  SC.RunLoop.end();


  var s1 = MyApp.store.find(MyApp.Slave, 's1');
  ok(s1.get('status') & SC.Record.READY_CLEAN, 'precond - s1 should be ready clean');

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Master, [
    { guid: 'm1', slave: 's1' }
  ]);
  SC.RunLoop.end();

  var m1 = MyApp.store.find(MyApp.Master, 'm1');

  equals(m1.get('slave'), s1, 'm1 should be master of s1');
  equals(s1.get('master'), m1, 's1 should have master of m1');
});

test("Record property does change on linkage", function () {
  MyApp.Generic = SC.Record.extend({
    relative: SC.Record.toOne('MyApp.Generic', {
      inverse: 'relative',
      isMaster: YES
    }),

    callCount: 0,

    _relativeObserver: function () {
      this.incrementProperty('callCount');
    }.observes('relative')
  });

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Generic, [
    { guid: 'g1' },
    { guid: 'g2' }
  ]);
  SC.RunLoop.end();

  var g1 = MyApp.store.find(MyApp.Generic, 'g1'),
      g2 = MyApp.store.find(MyApp.Generic, 'g2');

  equals(g1.get('callCount'), 0, 'precond - g1._relativeObserver should NOT have fired yet');
  equals(g2.get('callCount'), 0, 'precond - g2._relativeObserver should NOT have fired yet');

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Generic, [
    { guid: 'g2', relative: 'g1' }
  ]);
  SC.RunLoop.end();

  equals(g1.get('relative'), g2, 'precond - g1 should be relative of g2');
  equals(g2.get('relative'), g1, 'precond - g2 should be relative of g1');

  equals(g1.get('callCount'), 1, 'g1._relativeObserver should fire once');
  equals(g2.get('callCount'), 1, 'g2._relativeObserver should fire once');
});

// ..........................................................
// RECORD ATTRIBUTE
//

/**
  lazilyInstantiate RecordAttribute flag tests.
 */
test("RecordAttribute flag 'lazilyInstantiate' tests", function () {
  MyApp.Master = SC.Record.extend({
    slave: SC.Record.toOne('MyApp.Slave', {
      inverse: 'master',
      isMaster: YES,
      lazilyInstantiate: YES
    })
  });

  MyApp.Slave = SC.Record.extend({
    master: SC.Record.toOne('MyApp.Master', {
      inverse: 'slave',
      isMaster: NO,
      lazilyInstantiate: YES // should be a noop
    })
  });

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Master, [
    { guid: 'm1', slave: 's1' }
  ]);

  MyApp.store.loadRecords(MyApp.Slave, [
    { guid: 's2', master: 'm2' }
  ]);
  SC.RunLoop.end();

  var m1 = MyApp.store.find(MyApp.Master, 'm1'),
      m2 = MyApp.store.find(MyApp.Master, 'm2'),
      s1 = MyApp.store.find(MyApp.Slave, 's1'),
      s2 = MyApp.store.find(MyApp.Slave, 's2');

  // test lazy creation on isMaster => YES
  ok(s1, 's1 should be created lazily');
  equals(m1.get('slave'), s1, 'm1 should be master of s1');

  // test lazy creation fails on isMaster => NO
  ok(SC.none(m2), 'm2 should NOT have been created');
  ok(!s2.get('master') ||
      s2.get('master').get('status') & SC.Record.ERROR, 's2 should have no master record');
});

/**
  lazilyInstantiate RecordAttribute flag can be a function.
 */
test("RecordAttribute flag 'lazilyInstantiate' can be a function", function () {
  MyApp.Master = SC.Record.extend({
    slave: SC.Record.toOne('MyApp.Slave', {
      inverse: 'master',
      isMaster: YES,
      lazilyInstantiate: function () {
        return NO;
      }
    })
  });

  MyApp.Slave = SC.Record.extend({
    master: SC.Record.toOne('MyApp.Master', {
      inverse: 'slave',
      isMaster: NO,
      lazilyInstantiate: YES // should be a noop
    })
  });

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.Master, [
    { guid: 'm1', slave: 's1' }
  ]);

  MyApp.store.loadRecords(MyApp.Slave, [
    { guid: 's2', master: 'm2' }
  ]);
  SC.RunLoop.end();

  var m1 = MyApp.store.find(MyApp.Master, 'm1'),
      m2 = MyApp.store.find(MyApp.Master, 'm2'),
      s1 = MyApp.store.find(MyApp.Slave, 's1'),
      s2 = MyApp.store.find(MyApp.Slave, 's2');

  // test lazy creation on isMaster => NO
  ok(!s1, 's1 should NOT be created lazily');

  // test lazy creation fails on isMaster => NO
  ok(SC.none(m2), 'm2 should NOT have been created');
  ok(!s2.get('master') ||
      s2.get('master').get('status') & SC.Record.ERROR, 's2 should have no master record');
});


/**
   lazilyInstantiate should ride the chain all the way to the top.

   That is, if a record's primaryKey is a record that has the
   flag 'lazilyInstantiate' on it, it should lazily create that one,
   and so on.
 */
test("RecordAttribute flag 'lazilyInstantiate' will create chains of records properly", function () {
  MyApp.SuperMaster = SC.Record.extend({
    master: SC.Record.toOne('MyApp.Master', {
      inverse: 'superMaster',
      isMaster: YES,
      lazilyInstantiate: YES
    })
  });

  MyApp.Master = SC.Record.extend({
    primaryKey: 'slave',

    superMaster: SC.Record.toOne('MyApp.SuperMaster', {
      inverse: 'master',
      isMaster: NO
    }),

    slave: SC.Record.toOne('MyApp.Slave', {
      inverse: 'master',
      isMaster: YES,
      lazilyInstantiate: YES
    })
  });

  MyApp.Slave = SC.Record.extend({
    primaryKey: 'subSlave',

    master: SC.Record.toOne('MyApp.Master', {
      inverse: 'slave',
      isMaster: NO
    }),

    subSlave: SC.Record.toOne('MyApp.SubSlave', {
      inverse: 'slave',
      isMaster: YES,
      lazilyInstantiate: YES
    })
  });

  MyApp.SubSlave = SC.Record.extend({
    slave: SC.Record.toOne('MyApp.Slave', {
      inverse: 'subSlave',
      isMaster: NO
    })
  });

  SC.RunLoop.begin();
  MyApp.store.loadRecords(MyApp.SuperMaster, [
    { guid: 'sm', master: 's' }
  ]);
  SC.RunLoop.end();

  var sm = MyApp.store.find(MyApp.SuperMaster, 'sm'),
      m = MyApp.store.find(MyApp.Master, 's'),
      s = MyApp.store.find(MyApp.Slave, 's'),
      ss = MyApp.store.find(MyApp.SubSlave, 's');

  ok(m, 'm should be created lazily');
  equals(m.get('superMaster'), sm, 'sm should be master of m');

  ok(s, 's should be created lazily');
  equals(s.get('master'), m, 'm should be master of s');

  ok(ss, 'ss should be created lazily');
  equals(ss.get('slave'), s, 's should be master of ss');
});


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/store/readDataHash.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// NOTE: The test below are based on the Data Hashes state chart.  This models
// the "read" event in the Store portion of the diagram.

var store, storeKey, json;
module("SC.Store#readDataHash", {
  setup: function() {
    store = SC.Store.create();
    
    json = {
      string: "string",
      number: 23,
      bool:   YES
    };
    
    storeKey = SC.Store.generateStoreKey();

    store.writeDataHash(storeKey, json, SC.Record.READY_CLEAN);
    store.editables = null; // manually patch to setup test state
  }
});

test("data state=LOCKED", function() {
  
  // preconditions
  equals(store.storeKeyEditState(storeKey), SC.Store.LOCKED, 'precond - data state should be LOCKED');
  var oldrev = store.revisions[storeKey];
  
  // perform read
  var ret = store.readDataHash(storeKey);
  
  // verify
  equals(ret, json, 'should read same data hash once locked');
  equals(store.storeKeyEditState(storeKey), SC.Store.LOCKED, 'should remain in locked state');

  // test revisions
  equals(store.revisions[storeKey], oldrev, 'should not change revision');
  if (!SC.none(oldrev)) {
    ok(store.revisions.hasOwnProperty(storeKey), 'should copy reference to revision');
  }
});

test("data state=EDITABLE", function() {
  
  // preconditions
  var ret1 = store.readEditableDataHash(storeKey);
  equals(store.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'precond - data state should be EDITABLE');
  var oldrev = store.revisions[storeKey];
  
  // perform read
  var ret2 = store.readDataHash(storeKey);
  
  // verify
  equals(ret1, ret2, 'should read same data hash once editable');
  equals(store.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'should remain in editable state');

  // test revisions
  equals(store.revisions[storeKey], oldrev, 'should not change revision');
  if (!SC.none(oldrev)) {
    ok(store.revisions.hasOwnProperty(storeKey), 'should copy reference to revision');
  }
});

test("should return null when accessing an unknown storeKey", function() {
  equals(store.readDataHash(20000000), null, 'should return null for non-existent store key');
  equals(store.storeKeyEditState(storeKey), SC.Store.LOCKED, 'should put into locked edit state');
});


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/store/readEditableDataHash.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// NOTE: The test below are based on the Data Hashes state chart.  This models
// the "read_editable" event in the Store portion of the diagram.

var store, storeKey, json;
module("SC.Store#readEditableDataHash", {
  setup: function() {
    store = SC.Store.create();
    
    json = {
      string: "string",
      number: 23,
      bool:   YES
    };
    
    storeKey = SC.Store.generateStoreKey();

    store.writeDataHash(storeKey, json, SC.Record.READY_CLEAN);
  }
});

test("data state=LOCKED", function() {
  
  // test preconditions
  store.editables = null ; // manually reset for testing state
  equals(store.storeKeyEditState(storeKey), SC.Store.LOCKED, 'precond - edit state should be LOCKED');
  var oldrev = store.revisions[storeKey] ;

  // perform read
  var ret = store.readEditableDataHash(storeKey);
  
  // validate
  same(ret, json, 'should return equivalent json object');
  ok(!(ret===json), 'should not return same json instance');
  
  equals(store.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'edit state should be editable');
  
  // should not change revisions, but should copy it...
  equals(store.revisions[storeKey], oldrev, 'should not change revision');
  if (!SC.none(oldrev)) {
    ok(store.revisions.hasOwnProperty(storeKey), 'should clone revision reference');
  }
  
});

test("data state=EDITABLE", function() {
  
  // test preconditions
  equals(store.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'precond - edit state should be EDITABLE');
  var oldrev = store.revisions[storeKey] ;

  // perform read
  var ret = store.readEditableDataHash(storeKey);
  
  // validate
  equals(ret, json, 'should return same editable json instance');
  
  equals(store.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'edit state should be editable');
  
  // should not change revisions, but should copy it...
  equals(store.revisions[storeKey], oldrev, 'should not change revision');
  if (!SC.none(oldrev)) {
    ok(store.revisions.hasOwnProperty(storeKey), 'should clone revision reference');
  }
  
});



})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/store/recordDidChange.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

var store, storeKey, json;
module("SC.Store#recordDidChange", {
  setup: function() {
    SC.RunLoop.begin();

    store = SC.Store.create();

    json1 = {
      guid: "commitGUID1",
      string: "string",
      number: 23,
      bool:   YES
    };
    json2 = {
      guid: "commitGUID2",
      string: "string",
      number: 23,
      bool:   YES
    };
    json3 = {
      guid: "commitGUID3",
      string: "string",
      number: 23,
      bool:   YES
    };
    json4 = {
      guid: "commitGUID4",
      string: "string",
      number: 23,
      bool:   YES
    };
    

    storeKey1 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey1, json1, SC.Record.BUSY_LOADING);
    storeKey2 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey2, json2, SC.Record.EMPTY);
    storeKey3 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey3, json3, SC.Record.READY_NEW);
    storeKey4 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey4, json4, SC.Record.READY_CLEAN);

    SC.RunLoop.end();
  }
});

test("recordDidChange", function() {
  var status;
  try{
    store.recordDidChange(undefined, undefined, storeKey1);
  }catch(error1){
    equals(SC.Record.BUSY_ERROR.message, error1.message, "the status shouldn't have changed.");
  }
  
  try{
    store.recordDidChange(undefined, undefined, storeKey2);
  }catch(error2){
    equals(SC.Record.NOT_FOUND_ERROR.message, error2.message, "the status shouldn't have changed.");
  }
  
  store.recordDidChange(undefined, undefined, storeKey3);
   status = store.readStatus( storeKey3);
   equals(status, SC.Record.READY_NEW, "the status shouldn't have changed.");

   store.recordDidChange(undefined, undefined, storeKey4);
   status = store.readStatus( storeKey4);
   equals(status, SC.Record.READY_DIRTY, "the status shouldn't have changed.");
  
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/store/removeDataHash.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// NOTE: The test below are based on the Data Hashes state chart.  This models
// the "remove" event in the Store portion of the diagram.

var store, child, storeKey, json;
module("SC.Store#removeDataHash", {
  setup: function() {
    store = SC.Store.create();
    
    json = {
      string: "string",
      number: 23,
      bool:   YES
    };
    
    storeKey = SC.Store.generateStoreKey();

    store.writeDataHash(storeKey, json, SC.Record.READY_CLEAN);
    store.editables = null; // manually patch to setup test state
    child = store.chain();  // test multiple levels deep
  }
});

// ..........................................................
// BASIC STATE TRANSITIONS
// 

// The transition from each base state performs the same operation, so just
// run the same test on each state.
function testRemoveDataHash() {
  var oldrev = store.revisions[storeKey];
  
  // perform test
  equals(store.removeDataHash(storeKey, SC.Record.DESTROYED_CLEAN), store, 'should return receiver');
  
  // verify
  equals(store.storeKeyEditState(storeKey), SC.Store.LOCKED, 'new edit state should be locked');
  
  equals(store.readDataHash(storeKey), null, 'should have NO json data');
  equals(store.readStatus(storeKey), SC.Record.DESTROYED_CLEAN, 'should have new status');

  equals(store.revisions[storeKey], oldrev, 'should not change revision');
  if (!SC.none(oldrev)) {
    ok(store.revisions.hasOwnProperty(storeKey), 'should clone reference to revision');
  }
}


test("edit state=LOCKED", function() {
  
  // test preconditions
  equals(store.storeKeyEditState(storeKey), SC.Store.LOCKED, 'precond - edit state should be locked');
  
  testRemoveDataHash();

});

test("edit state=EDITABLE", function() {
  
  // test preconditions
  store.readEditableDataHash(storeKey);
  equals(store.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'precond - edit state should be editable');
  
  testRemoveDataHash();

});

// ..........................................................
// REMOVE NON-EXISTING 
// 

test("remove a non-existing hash", function() {
  storeKey = SC.Store.generateStoreKey(); // new store key!
  equals(store.readDataHash(storeKey), null, 'precond - store should not have a data hash for store key yet');
  
  // perform write
  equals(store.removeDataHash(storeKey, SC.Record.DESTROYED_CLEAN), store, 'should return receiver');
  
  // verify change
  equals(store.storeKeyEditState(storeKey), SC.Store.LOCKED, 'new status should be locked');
  equals(store.readDataHash(storeKey), null, 'should still be null');
  equals(store.readStatus(storeKey), SC.Record.DESTROYED_CLEAN, 'should have new record status');
});

// ..........................................................
// PROPOGATING TO NESTED STORES
// 

test("change should propogate to child if child edit state = INHERITED", function() {

  // verify preconditions
  equals(child.storeKeyEditState(storeKey), SC.Store.INHERITED, 'precond - child edit state should be INHERITED');

  // perform change
  store.removeDataHash(storeKey, SC.Record.DESTROYED_CLEAN);
  
  // verify
  same(child.readDataHash(storeKey), null, 'child should pick up change');
  equals(child.readStatus(storeKey), SC.Record.DESTROYED_CLEAN, 'child should pick up new status');
});


function testLockedOrEditableChild() {
  // perform change
  store.removeDataHash(storeKey, SC.Record.DESTROYED_CLEAN);
  
  // verify
  same(child.readDataHash(storeKey), json, 'child should NOT pick up change');
  equals(child.readStatus(storeKey), SC.Record.READY_CLEAN, 'child should pick up new status');
}


test("change should not propogate to child if child edit state = LOCKED", function() {

  // verify preconditions
  child.readDataHash(storeKey);
  equals(child.storeKeyEditState(storeKey), SC.Store.LOCKED, 'precond - child edit state should be LOCKED');

  testLockedOrEditableChild();
});

test("change should not propogate to child if child edit state = EDITABLE", function() {

  // verify preconditions
  child.readEditableDataHash(storeKey);
  equals(child.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'precond - child edit state should be EDITABLE');

  testLockedOrEditableChild();
});










})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/store/retrieveRecord.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */


var store, storeKey1, storeKey2, storeKey3, storeKey4, storeKey5, storeKey6;
var storeKey7, storeKey8, json, json1, json2, json3, json4, json5, json6 ;
var json7, json8;

module("SC.Store#retrieveRecord", {
  setup: function() {
    
    store = SC.Store.create();
    
    json1 = {
      guid: "retrieveGUID1",
      string: "string",
      number: 23,
      bool:   YES
    };
    json2 = {
      guid: "retrieveGUID2",
      string: "string",
      number: 23,
      bool:   YES
    };
    json3 = {
      guid: "retrieveGUID3",
      string: "string",
      number: 23,
      bool:   YES
    };
    json4 = {
      guid: "retrieveGUID4",
      string: "string",
      number: 23,
      bool:   YES
    };
    json5 = {
      guid: "retrieveGUID5",
      string: "string",
      number: 23,
      bool:   YES
    };
    json6 = {
      guid: "retrieveGUID6",
      string: "string",
      number: 23,
      bool:   YES
    };
    json7 = {
      guid: "retrieveGUID7",
      string: "string",
      number: 23,
      bool:   YES
    };
    json8 = {
      guid: "retrieveGUID8",
      string: "string",
      number: 23,
      bool:   YES
    };
    
    storeKey1 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey1, json1, SC.Record.EMPTY);
    storeKey2 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey2, json2, SC.Record.ERROR);
    storeKey3 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey3, json3, SC.Record.DESTROYED_CLEAN);
    storeKey4 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey4, json4, SC.Record.BUSY_DESTROYING);
    storeKey5 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey5, json5, SC.Record.BUSY_CREATING);
    storeKey6 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey6, json6, SC.Record.BUSY_COMMITTING);
    storeKey7 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey7, json7, SC.Record.DESTROYED_DIRTY);
    storeKey8 = SC.Store.generateStoreKey();
    store.writeDataHash(storeKey8, json8, SC.Record.READY_CLEAN);
    }
});
  
function testStates(canLoad) {
  var msg, status;
  
  SC.RunLoop.begin();
  
  store.retrieveRecord(undefined, undefined, storeKey1, YES);
  status = store.readStatus( storeKey1);
  if (canLoad) {
    equals(status, SC.Record.BUSY_LOADING, "the status should have changed to BUSY_LOADING");
  } else {
    equals(status, SC.Record.ERROR, "the status should remain empty");
  }
  
  
  store.retrieveRecord(undefined, undefined, storeKey2, YES);
  status = store.readStatus( storeKey2);
  if (canLoad) {
    equals(status, SC.Record.BUSY_LOADING, "the status should have changed to BUSY_LOADING");
  } else {
    equals(status, SC.Record.ERROR, "the status should become empty");
  }
  
  store.retrieveRecord(undefined, undefined, storeKey3, YES);
  status = store.readStatus( storeKey3);
  if (canLoad) {
    equals(status, SC.Record.BUSY_LOADING, "the status should have changed to BUSY_LOADING");
  } else {
    equals(status, SC.Record.ERROR, "the status should become empty");
  }
  
  try{
    store.retrieveRecord(undefined, undefined, storeKey4, YES);
    msg='';
  }catch(error1){
    msg=error1.message;
  }
  equals(msg, SC.Record.BUSY_ERROR.message, "should throw error");

  try{
    store.retrieveRecord(undefined, undefined, storeKey5, YES);
    msg='';
  }catch(error2){
    msg=error2.message;
  }
  equals(msg, SC.Record.BUSY_ERROR.message, "should throw error");
  
  try{
    store.retrieveRecord(undefined, undefined, storeKey6, YES);
    msg='';
  }catch(error3){
    msg=error3.message;
  }
  equals(msg, SC.Record.BUSY_ERROR.message, "should throw error");

  try{
    store.retrieveRecord(undefined, undefined, storeKey7, YES);
    msg='';
  }catch(error4){
    msg=error4.message;
  }
  equals(msg, SC.Record.BAD_STATE_ERROR.message, "should throw error");


  store.retrieveRecord(undefined, undefined, storeKey8, YES);
  status = store.readStatus( storeKey8);
  if (canLoad) {
    ok(SC.Record.BUSY_REFRESH | (status & 0x03), "the status changed to BUSY_REFRESH.");
  } else {
    equals(status, SC.Record.READY_CLEAN, "the status should remain ready clean");
  }
  
  SC.RunLoop.end();
}  

test("Retrieve a record without a data source", function() {
  testStates(NO);
});

test("Retrieve a record without a working data source and check for different errors and states", function() {
  // build a fake data source that claims to NOT handle retrieval
  var source = SC.DataSource.create({
    retrieveRecords: function() { return NO ; }
  });
  store.set('dataSource', source);

  testStates(NO);

});

test("Retrieve a record with working data source and check for different errors and states", function() {
  // build a fake data source that claims to handle retrieval
  var source = SC.DataSource.create({
    retrieveRecords: function() { return YES ; }
  });
  store.set('dataSource', source);

  testStates(YES);

});

test("Retrieve a record with callback", function() {
  // build a fake data source that claims to handle retrieval
  var source = SC.DataSource.create({
    retrieveRecords: function() { return YES ; }
  });
  store.set('dataSource', source);
  var callback = NO;
  store.retrieveRecord(undefined, undefined, storeKey1, YES, function(){callback = YES;});
  
  ok(store._callback_queue[storeKey1], "The callback exists in the queue");
  
  store.dataSourceDidComplete(storeKey1);
  
  ok(callback, "Callback did fire");
});
})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/store/unloadRecord.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================

(function() {
  var store, Person, Place;

  module("SC.Store#unloadRecord", {
    setup: function() {
      Person = SC.Record.extend({
        name: SC.Record.attr(String)
      });

      Place = SC.Record.extend({
        name: SC.Record.attr(String)
      });

      SC.RunLoop.begin();

      store = SC.Store.create();

      store.loadRecords(Person, [
        {guid: 1, name: 'Soups'},
        {guid: 2, name: 'Palmdale'},
        {guid: 3, name: 'Dubs'}
      ]);

      store.loadRecords(Place, [
        {guid: 4, name: "San Francisco"},
        {guid: 5, name: "St. John's"}
      ]);

      SC.RunLoop.end();
    },
    teardown: function() {
      store = Person = Place = null;
    }
  });

  test("Unload one record via storeKey", function() {
    var people = store.find(Person),
        record = store.find(Person, 1);

    equals(people.get('length'), 3, "precond - there are 3 People records in the store");

    store.unloadRecord(Person, 1);

    people = store.find(Person);
    equals(people.get('length'), 2, "there are 2 People records in the store after calling unloadRecord");
    ok(store.peekStatus(record) & SC.Record.EMPTY, "Record now has status of SC.Record.EMPTY");
  });

})();

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/store/unloadRecords.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================

(function() {
  var store, Person, Place;

  module("SC.Store#unloadRecords", {
    setup: function() {
      Person = SC.Record.extend({
        name: SC.Record.attr(String)
      });

      Place = SC.Record.extend({
        name: SC.Record.attr(String)
      });

      SC.RunLoop.begin();

      store = SC.Store.create();

      store.loadRecords(Person, [
        {guid: 1, name: 'Soups'},
        {guid: 2, name: 'Palmdale'},
        {guid: 3, name: 'Dubs'}
      ]);

      store.loadRecords(Place, [
        {guid: 4, name: "San Francisco"},
        {guid: 5, name: "St. John's"}
      ]);

      SC.RunLoop.end();
    },
    teardown: function() {
      store = Person = Place = null;
    }
  });

  test("Unload all records of a record type", function() {
    var records = store.find(Person);
    equals(records.get('length'), 3, "precond - store has 3 records loaded");
    store.unloadRecords(Person);
    records = store.find(Person);
    equals(records.get('length'), 0, "Number of People records left");
  });

  test("Unload only certain records of a record type", function() {
    var records = store.find(Person);
    equals(records.get('length'), 3, "precond - store has 3 records loaded");
    store.unloadRecords(Person, [1, 2]);
    records = store.find(Person);
    equals(records.get('length'), 1, "Number of People records left");
  });

  test("Unload all records of passed record types", function() {
    var people = store.find(Person),
        places = store.find(Place);

    equals(people.get('length'), 3, "precond - store has 3 Person records loaded");
    equals(places.get('length'), 2, "precond - store has 2 Place records loaded");

    store.unloadRecords([Person, Place]);

    people = store.find(Person);
    places = store.find(Place);

    equals(people.get('length'), 0, "Number of People records left");
    equals(places.get('length'), 0, "Number of Place records left");
  });

  test("Unload certain records of passed record types", function() {
    var people = store.find(Person),
        places = store.find(Place);

    equals(people.get('length'), 3, "precond - store has 3 Person records loaded");
    equals(places.get('length'), 2, "precond - store has 2 Place records loaded");

    store.unloadRecords([Person, Person, Place], [1, 2, 4]);

    people = store.find(Person);
    places = store.find(Place);

    equals(people.get('length'), 1, "Number of People records left");
    equals(places.get('length'), 1, "Number of Place records left");
  });

})();

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/datastore/en/current/tests/system/store/writeDataHash.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2011 Apple Inc. and contributors.
// License:   Licensed under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// NOTE: The test below are based on the Data Hashes state chart.  This models
// the "write" event in the NestedStore portion of the diagram.

var store, child, storeKey, json;
module("SC.Store#writeDataHash", {
  setup: function() {
    store = SC.Store.create();
    
    json = {
      string: "string",
      number: 23,
      bool:   YES
    };
    
    storeKey = SC.Store.generateStoreKey();
    child = store.chain();  // test multiple levels deep
  }
});

// ..........................................................
// BASIC STATE TRANSITIONS
// 

// The transition from each base state performs the same operation, so just
// run the same test on each state.
function testWriteDataHash() {
  var oldrev = store.revisions[storeKey];
  
  // perform test
  var json2 = { foo: "bar" };
  equals(store.writeDataHash(storeKey, json2, SC.Record.READY_NEW), store, 'should return receiver');
  
  // verify
  equals(store.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'new edit state should be editable');
  
  equals(store.readDataHash(storeKey), json2, 'should have new json data hash');
  equals(store.readStatus(storeKey), SC.Record.READY_NEW, 'should have new status');

  equals(store.revisions[storeKey], oldrev, 'should not change revision');
  if (!SC.none(oldrev)) {
    ok(store.revisions.hasOwnProperty(storeKey), 'should clone reference to revision');
  }
}


test("edit state=LOCKED - also writes a NEW hash", function() {
  
  // test preconditions
  equals(store.storeKeyEditState(storeKey), SC.Store.LOCKED, 'precond - edit state should be locked');
  
  testWriteDataHash();
});

test("edit state=EDITABLE - also overwrites an EXISTING hash", function() {
  
  // test preconditions
  store.writeDataHash(storeKey, { foo: "bar" });
  equals(store.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'precond - edit state should be editable');
  
  testWriteDataHash();

});

// ..........................................................
// PROPOGATING TO NESTED STORES
// 

test("change should propogate to child if child edit state = INHERITED", function() {

  // verify preconditions
  equals(child.storeKeyEditState(storeKey), SC.Store.INHERITED, 'precond - child edit state should be INHERITED');

  // perform change
  var json2 = { version: 2 };
  store.writeDataHash(storeKey, json2, SC.Record.READY_NEW);
  
  // verify
  same(child.readDataHash(storeKey), json2, 'child should pick up change');
  equals(child.readStatus(storeKey), SC.Record.READY_NEW, 'child should pick up new status');
});


function testLockedOrEditableChild() {
  // perform change
  var json2 = { version: 2 };
  store.writeDataHash(storeKey, json2, SC.Record.READY_NEW);
  
  // verify
  same(child.readDataHash(storeKey), json, 'child should NOT pick up change');
  equals(child.readStatus(storeKey), SC.Record.READY_CLEAN, 'child should pick up new status');
}


test("change should not propogate to child if child edit state = LOCKED", function() {
  store.writeDataHash(storeKey, json, SC.Record.READY_CLEAN);
  store.editables = null ; // clear to simulate locked mode.
  
  // verify preconditions
  child.readDataHash(storeKey);
  equals(child.storeKeyEditState(storeKey), SC.Store.LOCKED, 'precond - child edit state should be LOCKED');

  testLockedOrEditableChild();
});

test("change should not propogate to child if child edit state = EDITABLE", function() {
  store.writeDataHash(storeKey, json, SC.Record.READY_CLEAN);
  store.editables = null ; // clear to simulate locked mode.

  // verify preconditions
  child.readEditableDataHash(storeKey);
  equals(child.storeKeyEditState(storeKey), SC.Store.EDITABLE, 'precond - child edit state should be EDITABLE');

  testLockedOrEditableChild();
});





})();
</script>

  <script>
    SC.benchmarkPreloadEvents['bodyEnd'] = new Date().getTime();
  </script>
  </body>
</html>
